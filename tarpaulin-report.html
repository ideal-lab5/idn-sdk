<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","gossipsub.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Gossipsub Network Subscription Client\n//!\n//! The `GossipsubNetwork` is a libp2p node designed to ingest well-formatted messages\n//! from a gossipsub topic. The implemention is intended to be used with\n//! the Drand beacon gossipsub topic, to which `Pulse` messages are published as protobuf messages.\n//!\n//! ## Overview\n//!\n//! - runs a libp2p node and handles peer connections\n//! - subscribes to a gossipsub topic and writes well-formed messages to a [`SharedState`]\n//!\n//! ## Examples\n//!\n//! ``` no_run\n//! use sc_consensus_randomness_beacon::gossipsub::GossipsubNetwork;\n//! use sc_consensus_randomness_beacon::types::*;\n//! use futures::StreamExt;\n//! use libp2p::{\n//! \t\tgossipsub,\n//! \t\tgossipsub::{\n//! \t\t\tBehaviour as GossipsubBehaviour, Config as GossipsubConfig, IdentTopic, MessageAuthenticity,\n//! \t\t},\n//! \t\tidentity::Keypair,\n//! \t\tswarm::{Swarm, SwarmEvent},\n//! \t\tMultiaddr, SwarmBuilder,\n//! };\n//! use sc_utils::mpsc::tracing_unbounded;\n//! use prost::Message;\n//! use std::sync::{Arc, Mutex};\n//!\n//! let topic_str: \u0026str =\n//! \t\"/drand/pubsub/v0.0.0/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971\";\n//! let maddr1: Multiaddr =\n//! \t\"/ip4/184.72.27.233/tcp/44544/p2p/12D3KooWBhAkxEn3XE7QanogjGrhyKBMC5GeM3JUTqz54HqS6VHG\"\n//! \t\t.parse()\n//! \t\t.expect(\"The string is a well-formatted multiaddress. qed.\");\n//! let maddr2: Multiaddr =\n//! \t\"/ip4/54.193.191.250/tcp/44544/p2p/12D3KooWQqDi3D3KLfDjWATQUUE4o5aSshwBFi9JM36wqEPMPD5y\"\n//! \t\t.parse()\n//! \t\t.expect(\"The string is a well-formatted multiaddress. qed.\");\n//! let local_identity: Keypair = Keypair::generate_ed25519();\n//! let (tx, rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n//! let gossipsub_config = GossipsubConfig::default();\n//! let mut gossipsub = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None).unwrap();\n//! tokio::spawn(async move {\n//! \tif let Err(e) = gossipsub.run(topic_str, vec![maddr1, maddr2]).await {\n//! \t\tlog::error!(\"Failed to run gossipsub network: {:?}\", e);\n//! \t}\n//! });\n//! ```\nuse crate::types::*;\nuse futures::StreamExt;\nuse libp2p::{\n\tgossipsub,\n\tgossipsub::{\n\t\tBehaviour as GossipsubBehaviour, Config as GossipsubConfig, IdentTopic, MessageAuthenticity,\n\t},\n\tidentity::Keypair,\n\tswarm::{Swarm, SwarmEvent},\n\tMultiaddr, SwarmBuilder,\n};\nuse prost::Message;\nuse sc_utils::mpsc::TracingUnboundedSender;\n\n/// The default address instructing libp2p to choose a random open port on the local machine\nconst RAND_LISTEN_ADDR: \u0026str = \"/ip4/0.0.0.0/tcp/0\";\n\n/// Various errors that can be encountered\n#[derive(Debug, Clone, PartialEq)]\npub enum Error {\n\t/// The signature buffer expects 48 bytes, but more were provided\n\tSignatureBufferCapacityExceeded,\n\t/// The message did not follow the expected format\n\tUnexpectedMessageFormat,\n\t/// The provided gossipsub behaviour is invalid\n\tInvalidGossipsubNetworkBehaviour,\n\t/// The multiaddress is invalid (likely the protocol is not supported)\n\tInvalidMultiaddress { who: Multiaddr },\n\t/// The swarm could not listen on the given port\n\tSwarmListenFailure,\n}\n\n/// A gossipsub network with any behaviour and shared state\npub struct GossipsubNetwork {\n\t/// The behaviour config for the swam\n\tswarm: Swarm\u003cGossipsubBehaviour\u003e,\n\t/// The mpsc channel sender\n\tsender: TracingUnboundedSender\u003cOpaquePulse\u003e,\n\t/// The number of peers the node is connected to\n\tpub(crate) connected_peers: u8,\n}\n\nimpl GossipsubNetwork {\n\t/// Build a new gossipsub network.\n\t/// It constructs a libp2p [swarm](https://docs.rs/libp2p/latest/libp2p/struct.Swarm.html)\n\t/// where message authenticity requires signatures from the provided key and with a tcp-based\n\t/// transport layer.\n\t///\n\t/// * `key`: A libp2p keypair\n\t/// * `gossipsub_config`: A gossipsub config\n\t/// * `sender`: A `TracingUnboundedSender` that can send an `OpaquePulse`\n\t/// * `listen_addr`: An optional address to listen on. If None, a random local port is assigned.\n\tpub fn new(\n\t\tkey: \u0026Keypair,\n\t\tgossipsub_config: GossipsubConfig,\n\t\tsender: TracingUnboundedSender\u003cOpaquePulse\u003e,\n\t\tlisten_addr: Option\u003c\u0026Multiaddr\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet message_authenticity = MessageAuthenticity::Signed(key.clone());\n\t\tlet gossipsub = GossipsubBehaviour::new(message_authenticity, gossipsub_config)\n\t\t\t.map_err(|_| Error::InvalidGossipsubNetworkBehaviour)?;\n\t\t// setup a libp2p swarm with tcp transport, using noise protocol for encryption\n\t\t// and yamux for multiplexing\n\t\tlet mut swarm = SwarmBuilder::with_existing_identity(key.clone())\n\t\t\t.with_tokio()\n\t\t\t.with_tcp(\n\t\t\t\tlibp2p::tcp::Config::default(),\n\t\t\t\tlibp2p::noise::Config::new,\n\t\t\t\tlibp2p::yamux::Config::default,\n\t\t\t)\n\t\t\t.expect(\"The TCP config is correct.\")\n\t\t\t.with_behaviour(|_| gossipsub)\n\t\t\t.expect(\"The behaviour is well defined.\")\n\t\t\t.build();\n\n\t\t// fallback to a randomly assigned open port if one was not provided\n\t\tlet fallback = \u0026RAND_LISTEN_ADDR.parse().expect(\"The multiaddress is well-formatted;QED.\");\n\t\tlet listen_addr = listen_addr.unwrap_or(fallback);\n\n\t\tswarm.listen_on(listen_addr.clone()).map_err(|_| Error::SwarmListenFailure)?;\n\n\t\tOk(Self { swarm, sender, connected_peers: 0 })\n\t}\n\n\t/// Start the gossipsub network.\n\t/// It waits for peers to establish a connection, then writes well-formed messages received\n\t/// from the gossipsub topic to the shared state.\n\t///\n\t/// * `topic_str`: The gossipsub topic to subscribe to.\n\t/// * `peers`: A list of peers to dial.\n\tpub async fn run(\u0026mut self, topic_str: \u0026str, peers: Vec\u003cMultiaddr\u003e) -\u003e Result\u003c(), Error\u003e {\n\t\tif !peers.is_empty() {\n\t\t\tfor peer in \u0026peers {\n\t\t\t\tself.swarm.dial((*peer).clone()).map_err(|_| {\n\t\t\t\t\treturn Error::InvalidMultiaddress { who: (*peer).clone() };\n\t\t\t\t})?;\n\t\t\t}\n\t\t\tself.wait_for_peers(peers.len()).await;\n\t\t}\n\n\t\tself.subscribe(topic_str).await\n\t}\n\n\t/// Executes until at least `target_count` ConnectionEstablished events\n\t/// have been observed.\n\t/// * `target_count`: The number of connection established events to observe until it terminates\n\tasync fn wait_for_peers(\u0026mut self, target_count: usize) {\n\t\tlet mut connected_peers = 0;\n\t\twhile connected_peers \u003c target_count {\n\t\t\tif let Some(SwarmEvent::ConnectionEstablished { .. }) = self.swarm.next().await {\n\t\t\t\tconnected_peers += 1;\n\t\t\t}\n\t\t}\n\t\tself.connected_peers = connected_peers as u8;\n\t}\n\n\t/// Create a subscription to a gossipsub topic.\n\t/// It writes new messages to the SharedState whenever they are decodable as Pulses\n\t/// and ignores and messages it cannot understand.\n\t///\n\t/// * `topic_str`: The gossipsub topic to subscribe to.\n\tasync fn subscribe(\u0026mut self, topic_str: \u0026str) -\u003e Result\u003c(), Error\u003e {\n\t\tlet topic = IdentTopic::new(topic_str);\n\t\t// *SRLabs: The error can never be encountered\n\t\t// Q: Can we use an expect, or is this unsafe?\n\t\t// Ref: https://docs.rs/libpp-gossipsub/0.48.0/src/libp2p_gossipsub/behaviour.rs.html#532\n\t\t// The error can only occur if the subscription filter rejects it, but we specify no filter.\n\t\tself.swarm\n\t\t\t.behaviour_mut()\n\t\t\t.subscribe(\u0026topic)\n\t\t\t.expect(\"The libp2p gossipsub behavior has no subscription filter.\");\n\n\t\tloop {\n\t\t\tmatch self.swarm.next().await {\n\t\t\t\tSome(SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. })) =\u003e {\n\t\t\t\t\tmatch try_handle_pulse(\u0026message.data) {\n\t\t\t\t\t\tOk(pulse) =\u003e {\n\t\t\t\t\t\t\tself.sender.unbounded_send(pulse.clone()).unwrap();\n\t\t\t\t\t\t},\n\t\t\t\t\t\tErr(_) =\u003e {\n\t\t\t\t\t\t\t// handle non-decodable messages: https://github.com/ideal-lab5/idn-sdk/issues/60\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t_ =\u003e {\n\t\t\t\t\t// ignore all other events\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n}\n\npub(crate) fn try_handle_pulse(data: \u0026[u8]) -\u003e Result\u003cOpaquePulse, Error\u003e {\n\tlet pulse = Pulse::decode(data).map_err(|_| Error::UnexpectedMessageFormat)?;\n\tlet pulse: OpaquePulse =\n\t\tpulse.try_into().map_err(|_| Error::SignatureBufferCapacityExceeded)?;\n\n\tOk(pulse)\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\tuse sc_utils::mpsc::{tracing_unbounded, TracingUnboundedReceiver};\n\tuse tokio::time::{sleep, Duration};\n\n\t#[test]\n\tfn can_convert_valid_data_to_opaque_pulse() {\n\t\tlet pulse = Pulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: [\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230, 117,\n\t\t\t]\n\t\t\t.to_vec(),\n\t\t};\n\t\tlet opaque: OpaquePulse = pulse.clone().try_into().unwrap();\n\t\tlet mut data = Vec::new();\n\t\tpulse.encode(\u0026mut data).unwrap();\n\n\t\tlet actual_opaque = try_handle_pulse(\u0026data).unwrap();\n\t\tassert_eq!(opaque, actual_opaque, \"The output should match the input\");\n\t}\n\n\t#[test]\n\tfn can_fail_when_data_not_decodable_to_pulse() {\n\t\tlet res = try_handle_pulse(\u0026[1; 32]);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(\n\t\t\tres,\n\t\t\tErr(Error::UnexpectedMessageFormat),\n\t\t\t\"There should be an `UnexpectedMessageFormat` error.\"\n\t\t);\n\t}\n\n\t#[test]\n\tfn can_fail_when_pulse_signature_exceeds_buffer() {\n\t\tlet pulse = Pulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: [\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t]\n\t\t\t.to_vec(),\n\t\t};\n\n\t\tlet expected_error = Error::SignatureBufferCapacityExceeded;\n\n\t\tlet mut data = Vec::new();\n\t\tpulse.encode(\u0026mut data).unwrap();\n\n\t\tlet res = try_handle_pulse(\u0026data);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(\n\t\t\tres,\n\t\t\tErr(expected_error),\n\t\t\t\"There should be an `SignatureBufferCapacityExceeded` error.\"\n\t\t);\n\t}\n\n\tfn build_node() -\u003e (GossipsubNetwork, TracingUnboundedReceiver\u003cOpaquePulse\u003e) {\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\t(GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None).unwrap(), rx)\n\t}\n\n\t#[tokio::test]\n\tasync fn can_not_build_node_with_invalid_gossipsub_behavior() {\n\t\t// supply a signing key but set anon validation, an invalid config\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = libp2p::gossipsub::ConfigBuilder::default()\n\t\t\t.validation_mode(libp2p::gossipsub::ValidationMode::Anonymous)\n\t\t\t.build()\n\t\t\t.unwrap();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet res = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None);\n\t\tassert!(res.is_err());\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_new_node() {\n\t\tlet (node, _rx) = build_node();\n\t\tassert!(node.connected_peers == 0, \"There should be no connected peers.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_new_node_with_listen_addr() {\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet listen_addr: Multiaddr = \"/ip4/0.0.0.0/tcp/4001\".parse().unwrap();\n\t\tlet node = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, Some(\u0026listen_addr))\n\t\t\t.unwrap();\n\t\tassert!(node.connected_peers == 0, \"There should be no connected peers.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_node_and_run_without_peers() {\n\t\tlet topic_str = \"test\";\n\t\tlet (mut node, _rx) = build_node();\n\n\t\tlet mut is_err: bool = false;\n\n\t\ttokio::spawn(async move {\n\t\t\tif let Err(_e) = node.run(topic_str, vec![]).await {\n\t\t\t\tis_err = true;\n\t\t\t}\n\t\t});\n\n\t\tsleep(Duration::from_secs(1)).await;\n\n\t\tassert!(!is_err, \"There should be no errors.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_node_and_fail_with_random_peers() {\n\t\tlet topic_str = \"test\";\n\t\tlet (mut node, _rx) = build_node();\n\n\t\tlet fake_peer: Multiaddr = Multiaddr::empty().with_p2p(libp2p::PeerId::random()).unwrap();\n\n\t\tlet mut is_err: bool = false;\n\n\t\ttokio::spawn(async move {\n\t\t\tif let Err(_e) = node.run(topic_str, vec![fake_peer]).await {\n\t\t\t\tis_err = true;\n\t\t\t}\n\t\t});\n\n\t\tsleep(Duration::from_secs(2)).await;\n\n\t\tassert!(!is_err, \"There should not be an error.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_fail_when_bad_listen_addr_provided() {\n\t\tlet fake_listen_addr: Multiaddr =\n\t\t\t\"/ip4/127.0.0.2/tcp/1010/p2p/12D3KooWBhAkxEn3XE7QanogjGrhyKBMC5GeM3JUTqz54HqS6VHG\"\n\t\t\t\t.parse()\n\t\t\t\t.unwrap();\n\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet res =\n\t\t\tGossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, Some(\u0026fake_listen_addr));\n\t\tassert!(res.is_err());\n\t\tassert!(matches!(res, Err(Error::SwarmListenFailure)), \"Expected SwarmListenFailure error\");\n\t}\n\n\t#[tokio::test]\n\tasync fn test_gossipsub_network_listen_failure() {\n\t\tlet key = Keypair::generate_ed25519();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet config = GossipsubConfig::default();\n\t\tlet invalid_addr: Multiaddr = Multiaddr::empty();\n\n\t\tlet result = GossipsubNetwork::new(\u0026key, config, tx, Some(\u0026invalid_addr));\n\t\tassert!(result.is_err(), \"Expected failure due to invalid listen address\");\n\t}\n}\n","traces":[{"line":119,"address":[9105198,9103456,9105325],"length":1,"stats":{"Line":7}},{"line":125,"address":[5190479,5190591],"length":1,"stats":{"Line":14}},{"line":126,"address":[5190920,5190651,5192121],"length":1,"stats":{"Line":9}},{"line":127,"address":[5190888],"length":1,"stats":{"Line":3}},{"line":130,"address":[5191253,5191147,5190978,5191100,5190873],"length":1,"stats":{"Line":5}},{"line":133,"address":[5191040],"length":1,"stats":{"Line":1}},{"line":138,"address":[5191189],"length":1,"stats":{"Line":3}},{"line":143,"address":[5191333,5191405],"length":1,"stats":{"Line":2}},{"line":144,"address":[5191539,5191478],"length":1,"stats":{"Line":2}},{"line":146,"address":[5191918,5191547],"length":1,"stats":{"Line":4}},{"line":148,"address":[5191679],"length":1,"stats":{"Line":4}},{"line":157,"address":[3152342,3152191,3152160,3153089,3153204,3153485],"length":1,"stats":{"Line":8}},{"line":158,"address":[3152461,3152316],"length":1,"stats":{"Line":4}},{"line":159,"address":[3152556,3152979,3152684,3152467],"length":1,"stats":{"Line":4}},{"line":160,"address":[3153776,3152863,3153884,3152705,3153016],"length":1,"stats":{"Line":2}},{"line":161,"address":[3153789,3153846],"length":1,"stats":{"Line":0}},{"line":164,"address":[3152644,3152372,3153236,3152755],"length":1,"stats":{"Line":4}},{"line":167,"address":[3152393,3152502,3153421,3153494],"length":1,"stats":{"Line":4}},{"line":173,"address":[5192285,5192272],"length":1,"stats":{"Line":4}},{"line":174,"address":[3154014],"length":1,"stats":{"Line":1}},{"line":175,"address":[3154027,3154060],"length":1,"stats":{"Line":2}},{"line":176,"address":[3154121,3154050,3154431,3154194,3154551],"length":1,"stats":{"Line":4}},{"line":177,"address":[3154433,3154392],"length":1,"stats":{"Line":0}},{"line":180,"address":[3154499],"length":1,"stats":{"Line":0}},{"line":188,"address":[5192322,5192304],"length":1,"stats":{"Line":4}},{"line":189,"address":[3154729],"length":1,"stats":{"Line":1}},{"line":194,"address":[3154818,3154896],"length":1,"stats":{"Line":2}},{"line":196,"address":[3154882],"length":1,"stats":{"Line":1}},{"line":199,"address":[3156145],"length":1,"stats":{"Line":1}},{"line":200,"address":[3154936,3155283,3156340,3155040,3154761,3154976],"length":1,"stats":{"Line":5}},{"line":201,"address":[3155318],"length":1,"stats":{"Line":0}},{"line":202,"address":[3155356,3155447],"length":1,"stats":{"Line":0}},{"line":203,"address":[3155465],"length":1,"stats":{"Line":0}},{"line":204,"address":[3155529,3155862,3155673],"length":1,"stats":{"Line":0}},{"line":219,"address":[5192878,5192352,5192903],"length":1,"stats":{"Line":2}},{"line":220,"address":[3156384,3156393],"length":1,"stats":{"Line":5}},{"line":221,"address":[3156432,3156436],"length":1,"stats":{"Line":6}},{"line":224,"address":[5192760],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":38},{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nextern crate alloc;\n\npub mod gossipsub;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","types.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse alloc::{\n\tformat,\n\tstring::{String, ToString},\n\tvec::Vec,\n};\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::G1Affine as G1AffineOpt;\n\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::G1Affine as G1AffineOpt;\n\nuse ark_serialize::CanonicalDeserialize;\n\n/// A `pulse` represents the output from a verifiable randomness beacon, specifically an 'unchained'\n/// one\n#[derive(Clone, PartialEq, ::prost::Message, Serialize, Deserialize)]\npub struct Pulse {\n\t/// The round of the protocol when the signature was computed\n\t#[prost(uint64, tag = \"1\")]\n\tpub round: u64,\n\t/// The interpolated threshold BLS sigs\n\t#[prost(bytes = \"vec\", tag = \"2\")]\n\tpub signature: ::prost::alloc::vec::Vec\u003cu8\u003e,\n}\n\n/// This struct is used to encode pulses in the runtime, where we obtain an OpaquePulse by\n/// converting a Pulse\n#[derive(Clone, Debug, PartialEq, codec::MaxEncodedLen, scale_info::TypeInfo, Encode, Decode)]\npub struct OpaquePulse {\n\t/// The round of the beacon protocol\n\tpub round: u64,\n\t/// A compressed BLS signature\n\tpub signature: [u8; 48],\n}\n\nimpl TryInto\u003cOpaquePulse\u003e for Pulse {\n\ttype Error = String;\n\t/// Converts a Pulse into an OpaquePulse\n\tfn try_into(self) -\u003e Result\u003cOpaquePulse, Self::Error\u003e {\n\t\tlet signature: [u8; 48] = self\n\t\t\t.signature\n\t\t\t.clone()\n\t\t\t.try_into()\n\t\t\t.map_err(|e| format!(\"The signature must be 48 bytes: {:?}\", e))?;\n\n\t\tOk(OpaquePulse { round: self.round, signature })\n\t}\n}\n\nimpl OpaquePulse {\n\t/// Serialize the opaque pulse as a vector\n\tpub fn serialize_to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n\t\tlet mut vec = Vec::new();\n\t\tvec.extend_from_slice(\u0026self.round.to_le_bytes());\n\t\tvec.extend_from_slice(\u0026self.signature);\n\t\tvec\n\t}\n\n\t/// Deserialize from a slice\n\t///\n\t/// * `data`: The data to attempt to deserialize\n\tpub fn deserialize_from_vec(data: \u0026[u8]) -\u003e Result\u003cSelf, String\u003e {\n\t\tif data.len() != 56 {\n\t\t\treturn Err(format!(\n\t\t\t\t\"Invalid buffer size, expected 56 bytes but received {}\",\n\t\t\t\tdata.len()\n\t\t\t));\n\t\t}\n\n\t\tlet bytes = data[0..8].try_into().map_err(|_| \"Failed to parse round\".to_string())?;\n\t\tlet round = u64::from_le_bytes(bytes);\n\n\t\tlet signature: [u8; 48] =\n\t\t\tdata[8..56].try_into().map_err(|_| \"Failed to parse signature\".to_string())?;\n\n\t\tOk(OpaquePulse { round, signature })\n\t}\n\n\t/// Compute the signature as a group element\n\tpub fn signature_point(\u0026self) -\u003e Result\u003cG1AffineOpt, String\u003e {\n\t\tG1AffineOpt::deserialize_compressed(\u0026mut self.signature.as_slice()).map_err(|e| {\n\t\t\tformat!(\"Failed to deserialize the signature bytes to a point on the G1 curve: {:?}\", e)\n\t\t})\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\tfn valid_pulse() -\u003e Pulse {\n\t\tPulse { round: 14475418, signature: VALID_SIG.to_vec() }\n\t}\n\n\tfn invalid_pulse() -\u003e Pulse {\n\t\tPulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: vec![\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230,\n\t\t\t],\n\t\t}\n\t}\n\n\tpub const SERIALIZED_VALID: \u0026[u8] = \u0026[\n\t\t154, 224, 220, 0, 0, 0, 0, 0, 146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242,\n\t\t43, 61, 28, 75, 93, 37, 95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104,\n\t\t76, 235, 84, 49, 223, 95, 22, 186, 113, 163, 202, 195, 230, 117,\n\t];\n\n\tpub const VALID_SIG: \u0026[u8] = \u0026[\n\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37, 95,\n\t\t131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49, 223, 95,\n\t\t22, 186, 113, 163, 202, 195, 230, 117,\n\t];\n\n\t#[test]\n\tfn test_pulse_to_opaque_pulse_conversion() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet result: Result\u003cOpaquePulse, _\u003e = valid_pulse.clone().try_into();\n\t\tassert!(result.is_ok(), \"Valid pulse should convert to OpaquePulse\");\n\t\tlet opaque_pulse = result.unwrap();\n\t\tassert_eq!(opaque_pulse.round, valid_pulse.round);\n\t\tassert_eq!(opaque_pulse.signature, valid_pulse.signature[..]);\n\t}\n\n\t#[test]\n\tfn test_pulse_with_invalid_signature_fails() {\n\t\tlet result: Result\u003cOpaquePulse, _\u003e = invalid_pulse().try_into();\n\t\tassert!(result.is_err(), \"Pulse with invalid signature should not convert\");\n\t}\n\n\t#[test]\n\tfn test_serialize_to_vec() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet opaque_pulse: OpaquePulse = valid_pulse.clone().try_into().unwrap();\n\t\tlet serialized = opaque_pulse.serialize_to_vec();\n\t\tassert_eq!(serialized, SERIALIZED_VALID, \"Serialization should match expected byte output\");\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_valid_vec() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet result = OpaquePulse::deserialize_from_vec(SERIALIZED_VALID);\n\t\tassert!(result.is_ok(), \"Deserialization should succeed for valid input\");\n\t\tlet opaque_pulse = result.unwrap();\n\t\tassert_eq!(opaque_pulse.round, valid_pulse.round);\n\t\tassert_eq!(opaque_pulse.signature, valid_pulse.signature[..]);\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_invalid_length() {\n\t\tlet invalid_data = \u0026[0; 50]; // Less than 56 bytes\n\t\tlet result = OpaquePulse::deserialize_from_vec(invalid_data);\n\t\tassert!(result.is_err(), \"Deserialization should fail for short input\");\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_excess_length() {\n\t\tlet invalid_data = \u0026[0; 60]; // More than 56 bytes\n\t\tlet result = OpaquePulse::deserialize_from_vec(invalid_data);\n\t\tassert!(result.is_err(), \"Deserialization should fail for long input\");\n\t}\n\n\t#[test]\n\tfn test_signature_point_invalid() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet mut opaque_pulse: OpaquePulse = valid_pulse.clone().try_into().unwrap();\n\t\t// corrupt the signature\n\t\topaque_pulse.signature = [1; 48];\n\t\tlet result = opaque_pulse.signature_point();\n\t\tassert!(\n\t\t\tresult.is_err(),\n\t\t\t\"Signature should not deserialize to a valid G1 point with random bytes\"\n\t\t);\n\t}\n}\n","traces":[{"line":58,"address":[4560071,4559712],"length":1,"stats":{"Line":1}},{"line":59,"address":[8671129,8671062,8671369],"length":1,"stats":{"Line":3}},{"line":63,"address":[9076247,9076080,9076101],"length":1,"stats":{"Line":4}},{"line":65,"address":[8671248],"length":1,"stats":{"Line":1}},{"line":71,"address":[8671677,8671456],"length":1,"stats":{"Line":2}},{"line":72,"address":[8671480],"length":1,"stats":{"Line":2}},{"line":73,"address":[8671555,8671499],"length":1,"stats":{"Line":4}},{"line":74,"address":[4560248],"length":1,"stats":{"Line":2}},{"line":75,"address":[4560286],"length":1,"stats":{"Line":2}},{"line":81,"address":[4560336],"length":1,"stats":{"Line":2}},{"line":82,"address":[4560379],"length":1,"stats":{"Line":2}},{"line":83,"address":[4560707,4560837],"length":1,"stats":{"Line":2}},{"line":85,"address":[4560699],"length":1,"stats":{"Line":1}},{"line":89,"address":[4560876,4560594,4561245],"length":1,"stats":{"Line":4}},{"line":90,"address":[8672254],"length":1,"stats":{"Line":2}},{"line":92,"address":[4808636,4808624],"length":1,"stats":{"Line":4}},{"line":95,"address":[4561353],"length":1,"stats":{"Line":2}},{"line":99,"address":[4561520],"length":1,"stats":{"Line":2}},{"line":100,"address":[4561556],"length":1,"stats":{"Line":3}},{"line":101,"address":[4808712,4808760],"length":1,"stats":{"Line":2}}],"covered":20,"coverable":20},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","impls.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Implementations of public traits\n\nuse crate::{\n\tself as pallet_idn_manager,\n\ttraits::{BalanceDirection, DiffBalance, FeesError},\n\tHoldReason, Subscription, SubscriptionTrait,\n};\nuse codec::Encode;\nuse frame_support::{\n\tpallet_prelude::DispatchError,\n\ttraits::{\n\t\ttokens::{fungible::hold::Mutate, Fortitude, Precision, Restriction},\n\t\tGet,\n\t},\n};\nuse sp_arithmetic::traits::Unsigned;\nuse sp_runtime::{traits::Zero, AccountId32, Saturating};\nuse sp_std::{cmp::Ordering, marker::PhantomData};\n\nimpl\u003cAccountId, BlockNumber: Unsigned, Metadata\u003e SubscriptionTrait\u003cAccountId\u003e\n\tfor Subscription\u003cAccountId, BlockNumber, Metadata\u003e\n{\n\tfn subscriber(\u0026self) -\u003e \u0026AccountId {\n\t\t\u0026self.details.subscriber\n\t}\n}\n\nimpl SubscriptionTrait\u003c()\u003e for () {\n\tfn subscriber(\u0026self) -\u003e \u0026() {\n\t\t\u0026()\n\t}\n}\n\n/// A FeesManager implementation that holds a dynamic treasury account.\npub struct FeesManagerImpl\u003cTreasury, BaseFee, Sub, Balances\u003e {\n\tpub _phantom: FeesManagerPhantom\u003cTreasury, BaseFee, Sub, Balances\u003e,\n}\ntype FeesManagerPhantom\u003cTreasury, BaseFee, Sub, Balances\u003e =\n\t(PhantomData\u003cTreasury\u003e, PhantomData\u003cBaseFee\u003e, PhantomData\u003cSub\u003e, PhantomData\u003cBalances\u003e);\n\nimpl\u003c\n\t\tT: Get\u003cAccountId32\u003e,\n\t\tB: Get\u003cBalances::Balance\u003e,\n\t\tS: SubscriptionTrait\u003cAccountId32\u003e,\n\t\tBalances: Mutate\u003cAccountId32\u003e,\n\t\u003e pallet_idn_manager::FeesManager\u003cBalances::Balance, u64, S, DispatchError, AccountId32\u003e\n\tfor FeesManagerImpl\u003cT, B, S, Balances\u003e\nwhere\n\tBalances::Reason: From\u003cHoldReason\u003e,\n\tBalances::Balance: From\u003cu64\u003e,\n{\n\t/// Calculate the subscription fees based on the number of requested credits.\n\t///\n\t/// This function implements a tiered pricing model with volume discounts:\n\t/// - Tier 1 (1-10 credits): 100% of base fee per credit (no discount)\n\t/// - Tier 2 (11-100 credits): 95% of base fee per credit (5% discount)\n\t/// - Tier 3 (101-1000 credits): 90% of base fee per credit (10% discount)\n\t/// - Tier 4 (1001-10000 credits): 80% of base fee per credit (20% discount)\n\t/// - Tier 5 (10001+ credits): 70% of base fee per credit (30% discount)\n\t///\n\t/// The fee calculation processes each tier sequentially:\n\t/// 1. For each tier, calculate how many credits fall within that tier\n\t/// 2. Apply the corresponding discount rate to those credits\n\t/// 3. Sum up the fees across all tiers\n\t///\n\t/// # Parameters\n\t/// * `credits` - The total number of credits requested for the subscription\n\t///\n\t/// # Returns\n\t/// The total fee required for the requested number of credits, converted to the\n\t/// appropriate balance type\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// // 100 credits would incur a fee of:\n\t/// // - 10 credits at full price: 10 * 100 = 1000\n\t/// // - 90 credits at 5% discount: 90 * 95 = 8550\n\t/// // Total: 9550\n\t/// let fees = calculate_subscription_fees(\u0026100u64);\n\t/// assert_eq!(fees, 9550u64.into());\n\t/// ```\n\tfn calculate_subscription_fees(credits: \u0026u64) -\u003e Balances::Balance {\n\t\t// Define tier boundaries and their respective discount rates (in basis points)\n\t\tconst TIERS: [(u64, u64); 5] = [\n\t\t\t(1, 0),        // 0-10: 0% discount\n\t\t\t(11, 500),     // 11-100: 5% discount\n\t\t\t(101, 1000),   // 101-1000: 10% discount\n\t\t\t(1001, 2000),  // 1001-10000: 20% discount\n\t\t\t(10001, 3000), // 10001+: 30% discount\n\t\t];\n\n\t\tconst BASE_FEE: u64 = 100;\n\n\t\tlet mut total_fee = 0u64;\n\t\tlet mut remaining_credits = *credits;\n\n\t\tfor (i, \u0026(current_tier_start, current_tier_discount)) in TIERS.iter().enumerate() {\n\t\t\t// If no remaining credits exit loop.\n\t\t\tif remaining_credits == 0 {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet next_tier_start = TIERS.get(i + 1).map(|\u0026(start, _)| start).unwrap_or(u64::MAX);\n\n\t\t\tlet credits_in_tier =\n\t\t\t\t(credits.min(\u0026next_tier_start.saturating_sub(1)) - current_tier_start + 1)\n\t\t\t\t\t.min(remaining_credits);\n\n\t\t\tlet tier_fee = BASE_FEE\n\t\t\t\t.saturating_mul(credits_in_tier)\n\t\t\t\t.saturating_mul(10_000 - current_tier_discount)\n\t\t\t\t.saturating_div(10_000);\n\n\t\t\ttotal_fee = total_fee.saturating_add(tier_fee);\n\t\t\tremaining_credits = remaining_credits.saturating_sub(credits_in_tier);\n\t\t}\n\n\t\ttotal_fee.into()\n\t}\n\n\t/// Calculate the difference in fees when a subscription changes, determining whether\n\t/// additional fees should be collected or excess fees should be released. This is useful for\n\t/// subscription updates and kills for holding or releasing fees. Or when collecting fees from a\n\t/// subscriber.\n\t///\n\t/// This function compares the fees required before and after a subscription change,\n\t/// then returns:\n\t/// - The fee difference amount\n\t/// - The direction of the balance transfer (collect from user, release to user, or no change)\n\t///\n\t/// # Parameters\n\t/// * `old_credits`\n\t///   - For an update operation, this represents the original requested credits\n\t///   - For a kill and collect operation, this is the number of credits left in the subscription\n\t/// * `new_credits`\n\t///   - For an update operation, this represents the new requested credits\n\t///   - For a kill operation, this is 0\n\t///   - For a collect operation, this is the actual number of credits consumed\n\t///\n\t/// # Returns\n\t/// A `DiffBalance` struct containing:\n\t/// - `balance`: The amount of fees to collect or release\n\t/// - `direction`: Whether to collect additional fees, release excess fees, or do nothing\n\t///\n\t/// # Examples\n\t/// ```no_compile\n\t/// // When increasing credits, additional fees are collected:\n\t/// // Old: 10 credits (1000 fee), New: 50 credits (5000 fee)\n\t/// let diff = calculate_diff_fees(\u002610, \u002650);\n\t/// assert_eq!(diff.balance, 4000);\n\t/// assert_eq!(diff.direction, BalanceDirection::Collect);\n\t///\n\t/// // When decreasing credits, excess fees are released:\n\t/// // Old: 100 credits (9550 fee), New: 10 credits (1000 fee)\n\t/// let diff = calculate_diff_fees(\u0026100, \u002610);\n\t/// assert_eq!(diff.balance, 8550);\n\t/// assert_eq!(diff.direction, BalanceDirection::Release);\n\t///\n\t/// // When credits remain the same, no fee changes occur:\n\t/// // Old: 50 credits (5000 fee), New: 50 credits (5000 fee)\n\t/// let diff = calculate_diff_fees(\u002650, \u002650);\n\t/// assert_eq!(diff.balance, 0);\n\t/// assert_eq!(diff.direction, BalanceDirection::None);\n\t/// ```\n\tfn calculate_diff_fees(old_credits: \u0026u64, new_credits: \u0026u64) -\u003e DiffBalance\u003cBalances::Balance\u003e {\n\t\tlet old_fees = Self::calculate_subscription_fees(old_credits);\n\t\tlet new_fees = Self::calculate_subscription_fees(new_credits);\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_fees.cmp(\u0026old_fees) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tnew_fees - old_fees\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\told_fees - new_fees\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\n\t/// Attempts to collect subscription fees from a subscriber and transfer them to the treasury\n\t/// account.\n\t///\n\t/// This function:\n\t/// 1. Transfers the specified fees from the subscriber's held balance to the treasury account\n\t/// 2. Verifies that the full fee amount was successfully collected\n\t/// 3. Returns the actual amount collected or an appropriate error\n\t///\n\t/// # Parameters\n\t/// * `fees` - The amount of fees to collect\n\t/// * `sub` - The subscription object containing the subscriber account information\n\t///\n\t/// # Returns\n\t/// - `Ok(collected)` - The amount of fees successfully collected and transferred\n\t/// - `Err(FeesError)` - If the transfer operation fails\n\t///\n\t/// # Notes\n\t/// - This function uses `transfer_on_hold` which transfers from the subscriber's held balance\n\t/// - The fees are held under the `HoldReason::Fees` reason code\n\t/// - The transfer uses `Precision::BestEffort` which allows partial transfers if full amount\n\t///   isn't available\n\t/// - Despite using best effort, this function will return an error if less than the requested\n\t///   amount is collected\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// let fees = 1000u64.into();\n\t/// let result = FeesManagerImpl::\u003cTreasury, BaseFee, Subscription, Balances\u003e::collect_fees(\n\t///     \u0026fees,\n\t///     \u0026subscription\n\t/// );\n\t///\n\t/// match result {\n\t///     Ok(collected) =\u003e println!(\"Successfully collected {} in fees\", collected),\n\t///     Err(FeesError::NotEnoughBalance { needed, balance }) =\u003e {\n\t///         println!(\"Insufficient balance: needed {}, had {}\", needed, balance);\n\t///     },\n\t///     Err(FeesError::Other(err)) =\u003e println!(\"Transfer error: {:?}\", err),\n\t/// }\n\t/// ```\n\tfn collect_fees(\n\t\tfees: \u0026Balances::Balance,\n\t\tsub: \u0026S,\n\t) -\u003e Result\u003cBalances::Balance, FeesError\u003cBalances::Balance, DispatchError\u003e\u003e {\n\t\t// Collect the held fees from the subscriber\n\t\tlet collected = Balances::transfer_on_hold(\n\t\t\t\u0026HoldReason::Fees.into(),\n\t\t\tsub.subscriber(),\n\t\t\t\u0026T::get(),\n\t\t\t*fees,\n\t\t\tPrecision::BestEffort,\n\t\t\tRestriction::Free,\n\t\t\tFortitude::Polite,\n\t\t)\n\t\t.map_err(FeesError::Other)?;\n\n\t\t// Ensure the correct credits was collected.\n\t\t// TODO: error to bubble up and be handled by caller https://github.com/ideal-lab5/idn-sdk/issues/107\n\t\tif collected \u003c *fees {\n\t\t\treturn Err(FeesError::NotEnoughBalance { needed: *fees, balance: collected });\n\t\t}\n\n\t\tOk(collected)\n\t}\n}\n\npub struct DepositCalculatorImpl\u003cSDMultiplier: Get\u003cDeposit\u003e, Deposit\u003e {\n\tpub _phantom: (PhantomData\u003cSDMultiplier\u003e, PhantomData\u003cDeposit\u003e),\n}\n\nimpl\u003c\n\t\tS: SubscriptionTrait\u003cAccountId32\u003e + Encode,\n\t\tSDMultiplier: Get\u003cDeposit\u003e,\n\t\tDeposit: Saturating + From\u003cu64\u003e + Ord,\n\t\u003e pallet_idn_manager::DepositCalculator\u003cDeposit, S\u003e\n\tfor DepositCalculatorImpl\u003cSDMultiplier, Deposit\u003e\n{\n\t/// Calculate the storage deposit required for a subscription.\n\t///\n\t/// This function computes the storage deposit amount based on the encoded size of the\n\t/// subscription object multiplied by a configurable deposit multiplier.\n\t///\n\t/// # Parameters\n\t/// * `sub` - The subscription object for which to calculate the storage deposit\n\t///\n\t/// # Returns\n\t/// The amount of deposit required for the subscription's storage\n\t///\n\t/// # Security Considerations\n\t/// This function handles potential overflow scenarios by:\n\t/// 1. Converting the encoded size from `usize` to `u64` with fallback to `u64::MAX` if the\n\t///    conversion fails\n\t/// 2. Using saturating multiplication to prevent arithmetic overflow\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// let subscription = Subscription {\n\t///     // subscription details...\n\t/// };\n\t///\n\t/// // If SDMultiplier is 2 and the subscription encodes to 100 bytes:\n\t/// let deposit = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_storage_deposit(\u0026subscription);\n\t/// assert_eq!(deposit, 200);\n\t/// ```\n\tfn calculate_storage_deposit(sub: \u0026S) -\u003e Deposit {\n\t\t// [SRLabs] Note: There is a theoretical edge case where if the `Deposit` type (e.g., u64)\n\t\t// is larger than the machine architecture size (e.g., 32-bit platforms), an attacker\n\t\t// could create a subscription object larger than u32::MAX bits and only pay a deposit for\n\t\t// u32::MAX bits, not the full size. This risk is mitigated in practice by platform\n\t\t// constraints and cost barriers.\n\t\tlet storage_deposit_multiplier = SDMultiplier::get();\n\t\tlet encoded_size = u64::try_from(sub.encoded_size()).unwrap_or(u64::MAX);\n\t\tstorage_deposit_multiplier.saturating_mul(encoded_size.into())\n\t}\n\n\t/// Calculate the difference in storage deposit between two subscriptions.\n\t///\n\t/// This function compares the storage deposit requirements of two subscription states\n\t/// and returns the difference along with the direction of the balance adjustment.\n\t///\n\t/// # Parameters\n\t/// * `old_sub` - The original subscription before changes\n\t/// * `new_sub` - The updated subscription after changes\n\t///\n\t/// # Returns\n\t/// A `DiffBalance` struct containing:\n\t/// - `balance`: The absolute difference between the old and new deposit amounts\n\t/// - `direction`: Whether to collect additional deposit, release excess deposit, or make no\n\t///   change\n\t///\n\t/// # How It Works\n\t/// 1. Calculates the storage deposit for both the old and new subscription states\n\t/// 2. Compares the two deposits to determine if more deposit is needed, some can be released,\n\t///    or no change is required\n\t/// 3. Returns both the amount and direction of the required deposit adjustment\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// // When subscription size increases (e.g., metadata added):\n\t/// let old_sub = /* subscription with 100 bytes encoded size */;\n\t/// let new_sub = /* same subscription with 150 bytes encoded size */;\n\t///\n\t/// // If SDMultiplier is 2:\n\t/// // Old deposit = 2 * 100 = 200\n\t/// // New deposit = 2 * 150 = 300\n\t/// let diff = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_diff_deposit(\u0026old_sub, \u0026new_sub);\n\t/// assert_eq!(diff.balance, 100); // 300 - 200 = 100 more needed\n\t/// assert_eq!(diff.direction, BalanceDirection::Collect);\n\t///\n\t/// // When subscription size decreases (e.g., metadata removed):\n\t/// let old_sub = /* subscription with 150 bytes encoded size */;\n\t/// let new_sub = /* same subscription with 100 bytes encoded size */;\n\t///\n\t/// // Old deposit = 2 * 150 = 300\n\t/// // New deposit = 2 * 100 = 200\n\t/// let diff = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_diff_deposit(\u0026old_sub, \u0026new_sub);\n\t/// assert_eq!(diff.balance, 100); // 300 - 200 = 100 to release\n\t/// assert_eq!(diff.direction, BalanceDirection::Release);\n\t/// ```\n\tfn calculate_diff_deposit(old_sub: \u0026S, new_sub: \u0026S) -\u003e DiffBalance\u003cDeposit\u003e {\n\t\tlet old_deposit = Self::calculate_storage_deposit(old_sub);\n\t\tlet new_deposit = Self::calculate_storage_deposit(new_sub);\n\t\tlet direction = match new_deposit.cmp(\u0026old_deposit) {\n\t\t\tOrdering::Greater =\u003e BalanceDirection::Collect,\n\t\t\tOrdering::Less =\u003e BalanceDirection::Release,\n\t\t\tOrdering::Equal =\u003e BalanceDirection::None,\n\t\t};\n\t\tDiffBalance { balance: new_deposit.saturating_sub(old_deposit), direction }\n\t}\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[3840896],"length":1,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[3387202,3387104],"length":1,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":310,"address":[],"length":0,"stats":{"Line":4}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":1}}],"covered":46,"coverable":55},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # IDN Manager Pallet\n//!\n//! This pallet manages subscriptions for random value distribution.\n//!\n//! ## Subscription State Lifecycle\n//! ```mermaid\n//! stateDiagram-v2\n//!     [*] --\u003e Active\n//!     Active --\u003e Paused\n//!     Paused --\u003e Active\n//!     Paused --\u003e [*]\n//!     Active --\u003e [*]\n//! ```\n//! ### States\n//!\n//! 1. Active (Default)\n//!    - Randomness is actively distributed\n//!    - IDN delivers random values according to subscription parameters\n//!\n//! 2. Paused\n//!    - Randomness distribution temporarily suspended\n//!    - Subscription remains in storage\n//!    - Can be reactivated\n//!\n//! ### Termination\n//! Subscription ends when:\n//! - All allocated random values are consumed\n//! - Manually killed by the original caller\n//!\n//! Upon termination:\n//! - Removed from storage\n//! - Storage deposit returned\n//! - Unused credits refunded to the origin\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n#[cfg(test)]\nmod tests;\n\npub mod impls;\npub mod traits;\npub mod weights;\n\nuse crate::traits::FeesError;\nuse codec::{Codec, Decode, Encode, MaxEncodedLen};\nuse frame_support::{\n\tpallet_prelude::{\n\t\tensure, Blake2_128Concat, DispatchError, DispatchResult, Hooks, IsType, OptionQuery,\n\t\tStorageMap, Zero,\n\t},\n\tsp_runtime::traits::AccountIdConversion,\n\ttraits::{\n\t\tfungible::{hold::Mutate as HoldMutate, Inspect},\n\t\ttokens::Precision,\n\t\tGet,\n\t},\n\tBoundedVec,\n};\nuse frame_system::{\n\tensure_signed,\n\tpallet_prelude::{BlockNumberFor, OriginFor},\n};\nuse scale_info::TypeInfo;\nuse sp_arithmetic::traits::Unsigned;\nuse sp_core::H256;\nuse sp_io::hashing::blake2_256;\nuse sp_runtime::{traits::One, Saturating};\nuse sp_std::fmt::Debug;\nuse traits::{\n\tBalanceDirection, DepositCalculator, DiffBalance, FeesManager,\n\tSubscription as SubscriptionTrait,\n};\nuse xcm::{\n\tv5::{prelude::*, Location},\n\tVersionedLocation, VersionedXcm,\n};\nuse xcm_builder::SendController;\n\npub use pallet::*;\npub use weights::WeightInfo;\n\npub type BalanceOf\u003cT\u003e =\n\t\u003c\u003cT as Config\u003e::Currency as Inspect\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e\u003e::Balance;\n\npub type MetadataOf\u003cT\u003e = BoundedVec\u003cu8, \u003cT as Config\u003e::SubMetadataLen\u003e;\n\npub type SubscriptionOf\u003cT\u003e =\n\tSubscription\u003c\u003cT as frame_system::Config\u003e::AccountId, BlockNumberFor\u003cT\u003e, MetadataOf\u003cT\u003e\u003e;\n\n#[derive(Encode, Decode, Clone, TypeInfo, MaxEncodedLen, Debug)]\npub struct Subscription\u003cAccountId, BlockNumber: Unsigned, Metadata\u003e {\n\tdetails: SubscriptionDetails\u003cAccountId, Metadata\u003e,\n\t// Number of random values left to distribute\n\tcredits_left: BlockNumber,\n\tstate: SubscriptionState,\n\tcreated_at: BlockNumber,\n\tupdated_at: BlockNumber,\n\tcredits: BlockNumber,\n\tfrequency: BlockNumber,\n}\n\n// TODO: details should be immutable, they are what make the subscription unique\n// https://github.com/ideal-lab5/idn-sdk/issues/114\n#[derive(Encode, Decode, Clone, TypeInfo, MaxEncodedLen, Debug)]\npub struct SubscriptionDetails\u003cAccountId, Metadata\u003e {\n\tsubscriber: AccountId,\n\ttarget: Location,\n\tmetadata: Metadata,\n}\n\nimpl\u003cAccountId, BlockNumber, Metadata\u003e Subscription\u003cAccountId, BlockNumber, Metadata\u003e\nwhere\n\tAccountId: Encode,\n\tBlockNumber: Encode + Copy + Unsigned,\n\tMetadata: Encode + Clone,\n{\n\tpub fn id(\u0026self) -\u003e SubscriptionId {\n\t\tlet id_tuple = (\n\t\t\tself.created_at,\n\t\t\t\u0026self.details.subscriber,\n\t\t\tself.details.target.clone(),\n\t\t\tself.details.metadata.clone(),\n\t\t);\n\t\t// Encode the tuple using SCALE codec.\n\t\tlet encoded = id_tuple.encode();\n\t\t// Hash the encoded bytes using blake2_256.\n\t\tH256::from_slice(\u0026blake2_256(\u0026encoded))\n\t}\n}\n\ntype SubscriptionId = H256;\n\n#[derive(Encode, Decode, Clone, PartialEq, TypeInfo, MaxEncodedLen, Debug)]\npub enum SubscriptionState {\n\tActive,\n\tPaused,\n}\n\n#[derive(Encode, Decode, Debug, PartialEq, Eq, Clone, TypeInfo)]\npub enum Call {\n\t#[codec(index = 1)]\n\tDistributeRnd,\n}\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\n\t\t/// The currency type for handling subscription payments\n\t\ttype Currency: Inspect\u003c\u003cSelf as frame_system::pallet::Config\u003e::AccountId\u003e\n\t\t\t+ HoldMutate\u003c\n\t\t\t\t\u003cSelf as frame_system::pallet::Config\u003e::AccountId,\n\t\t\t\tReason = Self::RuntimeHoldReason,\n\t\t\t\u003e;\n\n\t\t/// Overarching hold reason.\n\t\ttype RuntimeHoldReason: From\u003cHoldReason\u003e;\n\n\t\t/// Fees calculator implementation\n\t\ttype FeesManager: FeesManager\u003c\n\t\t\tBalanceOf\u003cSelf\u003e,\n\t\t\tBlockNumberFor\u003cSelf\u003e,\n\t\t\tSubscriptionOf\u003cSelf\u003e,\n\t\t\tDispatchError,\n\t\t\t\u003cSelf as frame_system::pallet::Config\u003e::AccountId,\n\t\t\u003e;\n\n\t\t/// Storage deposit calculator implementation\n\t\ttype DepositCalculator: DepositCalculator\u003cBalanceOf\u003cSelf\u003e, SubscriptionOf\u003cSelf\u003e\u003e;\n\n\t\t/// The type for the randomness\n\t\ttype Rnd;\n\n\t\t// The weight information for this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// A type that exposes XCM APIs, allowing contracts to interact with other parachains, and\n\t\t/// execute XCM programs.\n\t\ttype Xcm: xcm_builder::Controller\u003c\n\t\t\tOriginFor\u003cSelf\u003e,\n\t\t\t\u003cSelf as frame_system::Config\u003e::RuntimeCall,\n\t\t\tBlockNumberFor\u003cSelf\u003e,\n\t\t\u003e;\n\n\t\t/// The IDN Manager pallet id.\n\t\t#[pallet::constant]\n\t\ttype PalletId: Get\u003cframe_support::PalletId\u003e;\n\n\t\t/// Maximum metadata size\n\t\ttype SubMetadataLen: Get\u003cu32\u003e + TypeInfo;\n\t}\n\n\t#[pallet::storage]\n\tpub type Subscriptions\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tBlake2_128Concat,\n\t\tSubscriptionId,\n\t\tSubscription\u003cT::AccountId, BlockNumberFor\u003cT\u003e, MetadataOf\u003cT\u003e\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// A new subscription was created (includes single-block subscriptions)\n\t\tSubscriptionCreated { sub_id: SubscriptionId },\n\t\t/// A subscription has finished\n\t\tSubscriptionRemoved { sub_id: SubscriptionId },\n\t\t/// A subscription was paused\n\t\tSubscriptionPaused { sub_id: SubscriptionId },\n\t\t/// A subscription was updated\n\t\tSubscriptionUpdated { sub_id: SubscriptionId },\n\t\t/// A subscription was reactivated\n\t\tSubscriptionReactivated { sub_id: SubscriptionId },\n\t\t/// Randomness was successfully distributed\n\t\tRandomnessDistributed { sub_id: SubscriptionId },\n\t\t/// Fees collected\n\t\tFeesCollected { sub_id: SubscriptionId, fees: BalanceOf\u003cT\u003e },\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// A Subscription already exists\n\t\tSubscriptionAlreadyExists,\n\t\t/// A Subscription does not exist\n\t\tSubscriptionDoesNotExist,\n\t\t/// Subscription is already active\n\t\tSubscriptionAlreadyActive,\n\t\t/// Subscription is already paused\n\t\tSubscriptionAlreadyPaused,\n\t\t/// The origin isn't the subscriber\n\t\tNotSubscriber,\n\t}\n\n\t/// A reason for the IDN Manager Pallet placing a hold on funds.\n\t#[pallet::composite_enum]\n\tpub enum HoldReason {\n\t\t/// The IDN Manager Pallet holds balance for future charges.\n\t\t#[codec(index = 0)]\n\t\tFees,\n\t\t/// Storage deposit\n\t\t#[codec(index = 1)]\n\t\tStorageDeposit,\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\tfn on_finalize(_n: BlockNumberFor\u003cT\u003e) {\n\t\t\t// Look for subscriptions that should be finished\n\t\t\tfor (sub_id, sub) in\n\t\t\t\tSubscriptions::\u003cT\u003e::iter().filter(|(_, sub)| sub.credits_left == Zero::zero())\n\t\t\t{\n\t\t\t\t// finish the subscription\n\t\t\t\tlet _ = Self::finish_subscription(\u0026sub, sub_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Creates a subscription for one or multiple blocks\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(T::WeightInfo::create_subscription())]\n\t\tpub fn create_subscription(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\t// Number of random values to receive\n\t\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\t\t// XCM multilocation for random value delivery\n\t\t\ttarget: Location,\n\t\t\t// Distribution interval for random values\n\t\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\t\t// Bounded vector for additional data\n\t\t\tmetadata: Option\u003cMetadataOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSelf::create_subscription_internal(subscriber, credits, target, frequency, metadata)\n\t\t}\n\n\t\t/// Temporarily halts randomness distribution\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(T::WeightInfo::pause_subscription())]\n\t\tpub fn pause_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\t\t\t\tensure!(\n\t\t\t\t\tsub.state != SubscriptionState::Paused,\n\t\t\t\t\tError::\u003cT\u003e::SubscriptionAlreadyPaused\n\t\t\t\t);\n\t\t\t\tsub.state = SubscriptionState::Paused;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionPaused { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Ends the subscription before its natural conclusion\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(T::WeightInfo::kill_subscription())]\n\t\tpub fn kill_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\n\t\t\tlet sub =\n\t\t\t\tSelf::get_subscription(\u0026sub_id).ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\n\t\t\tSelf::finish_subscription(\u0026sub, sub_id)\n\t\t}\n\n\t\t/// Updates a subscription\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(T::WeightInfo::update_subscription())]\n\t\tpub fn update_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t\t// New number of random values\n\t\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\t\t// New distribution interval\n\t\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\n\t\t\t\tlet fees_diff = T::FeesManager::calculate_diff_fees(\u0026sub.credits, \u0026credits);\n\t\t\t\tlet deposit_diff = T::DepositCalculator::calculate_diff_deposit(\n\t\t\t\t\tsub,\n\t\t\t\t\t\u0026Subscription { credits, frequency, ..sub.clone() },\n\t\t\t\t);\n\n\t\t\t\tsub.credits = credits;\n\t\t\t\tsub.frequency = frequency;\n\t\t\t\tsub.updated_at = frame_system::Pallet::\u003cT\u003e::block_number();\n\n\t\t\t\t// Hold or refund diff fees\n\t\t\t\tSelf::manage_diff_fees(\u0026subscriber, \u0026fees_diff)?;\n\t\t\t\t// Hold or refund diff deposit\n\t\t\t\tSelf::manage_diff_deposit(\u0026subscriber, \u0026deposit_diff)?;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionUpdated { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Reactivates a paused subscription\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(T::WeightInfo::reactivate_subscription())]\n\t\tpub fn reactivate_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\t\t\t\tensure!(\n\t\t\t\t\tsub.state != SubscriptionState::Active,\n\t\t\t\t\tError::\u003cT\u003e::SubscriptionAlreadyActive\n\t\t\t\t);\n\t\t\t\tsub.state = SubscriptionState::Active;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionReactivated { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\t}\n}\n\nimpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t/// Finishes a subscription by removing it from storage and emitting a finish event.\n\tpub(crate) fn finish_subscription(\n\t\tsub: \u0026SubscriptionOf\u003cT\u003e,\n\t\tsub_id: SubscriptionId,\n\t) -\u003e DispatchResult {\n\t\t// fees left and deposit to refund\n\t\tlet fees_diff = T::FeesManager::calculate_diff_fees(\u0026sub.credits_left, \u0026Zero::zero());\n\t\tlet sd = T::DepositCalculator::calculate_storage_deposit(sub);\n\n\t\tSelf::manage_diff_fees(\u0026sub.details.subscriber, \u0026fees_diff)?;\n\t\tSelf::release_deposit(\u0026sub.details.subscriber, sd)?;\n\n\t\tSelf::deposit_event(Event::SubscriptionRemoved { sub_id });\n\n\t\tSubscriptions::\u003cT\u003e::remove(sub_id);\n\t\tSelf::deposit_event(Event::SubscriptionRemoved { sub_id });\n\t\tOk(())\n\t}\n\n\tfn pallet_account_id() -\u003e T::AccountId {\n\t\tT::PalletId::get().into_account_truncating()\n\t}\n\n\t/// Distribute randomness to subscribers\n\t/// Returns a weight based on the number of storage reads and writes performed\n\t// TODO: finish off this as part of https://github.com/ideal-lab5/idn-sdk/issues/77\n\tfn distribute(rnd: T::Rnd) -\u003e DispatchResult {\n\t\t// Filter for active subscriptions only\n\t\tfor (sub_id, sub) in\n\t\t\tSubscriptions::\u003cT\u003e::iter().filter(|(_, sub)| sub.state == SubscriptionState::Active)\n\t\t{\n\t\t\tif let Ok(msg) = Self::construct_randomness_xcm(sub.details.target.clone(), \u0026rnd) {\n\t\t\t\tlet versioned_target: Box\u003cVersionedLocation\u003e =\n\t\t\t\t\tBox::new(sub.details.target.clone().into());\n\t\t\t\tlet versioned_msg: Box\u003cVersionedXcm\u003c()\u003e\u003e =\n\t\t\t\t\tBox::new(xcm::VersionedXcm::V5(msg.into()));\n\t\t\t\tlet origin = frame_system::RawOrigin::Signed(Self::pallet_account_id());\n\t\t\t\tif T::Xcm::send(origin.into(), versioned_target, versioned_msg).is_ok() {\n\t\t\t\t\t// We consume a fixed one credit per distribution\n\t\t\t\t\tlet credits_consumed = One::one();\n\t\t\t\t\tSelf::collect_fees(\u0026sub, credits_consumed)?;\n\t\t\t\t\tSelf::consume_credits(\u0026sub_id, sub.clone(), credits_consumed);\n\t\t\t\t\tSelf::deposit_event(Event::RandomnessDistributed { sub_id });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tfn consume_credits(\n\t\tsub_id: \u0026SubscriptionId,\n\t\tmut sub: SubscriptionOf\u003cT\u003e,\n\t\tcredits_consumed: BlockNumberFor\u003cT\u003e,\n\t) {\n\t\t// Decrease credits_left by `credits_consumed` using saturating_sub\n\t\tsub.credits_left = sub.credits_left.saturating_sub(credits_consumed);\n\t\t// Update the subscription in storage\n\t\tSubscriptions::\u003cT\u003e::insert(sub_id, sub)\n\t}\n\n\tfn collect_fees(\n\t\tsub: \u0026SubscriptionOf\u003cT\u003e,\n\t\tcredits_consumed: BlockNumberFor\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tlet fees_to_collect = T::FeesManager::calculate_diff_fees(\n\t\t\t\u0026sub.credits_left,\n\t\t\t\u0026sub.credits_left.saturating_sub(credits_consumed),\n\t\t)\n\t\t.balance;\n\t\tlet fees = T::FeesManager::collect_fees(\u0026fees_to_collect, sub).map_err(|e| match e {\n\t\t\tFeesError::NotEnoughBalance { .. } =\u003e DispatchError::Other(\"NotEnoughBalance\"),\n\t\t\tFeesError::Other(de) =\u003e de,\n\t\t})?;\n\t\tSelf::deposit_event(Event::FeesCollected { sub_id: sub.id(), fees });\n\t\tOk(())\n\t}\n\n\t/// Internal function to handle subscription creation\n\tfn create_subscription_internal(\n\t\tsubscriber: T::AccountId,\n\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\ttarget: Location,\n\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\tmetadata: Option\u003cMetadataOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\t// Calculate and hold the subscription fees\n\t\tlet fees = Self::calculate_subscription_fees(\u0026credits);\n\n\t\tSelf::hold_fees(\u0026subscriber, fees)?;\n\n\t\tlet current_block = frame_system::Pallet::\u003cT\u003e::block_number();\n\t\tlet details = SubscriptionDetails {\n\t\t\tsubscriber: subscriber.clone(),\n\t\t\ttarget: target.clone(),\n\t\t\tmetadata: metadata.unwrap_or_default(),\n\t\t};\n\t\tlet subscription = Subscription {\n\t\t\tstate: SubscriptionState::Active,\n\t\t\tcredits_left: credits,\n\t\t\tdetails,\n\t\t\tcreated_at: current_block,\n\t\t\tupdated_at: current_block,\n\t\t\tcredits,\n\t\t\tfrequency,\n\t\t};\n\n\t\tSelf::hold_deposit(\n\t\t\t\u0026subscriber,\n\t\t\tT::DepositCalculator::calculate_storage_deposit(\u0026subscription),\n\t\t)?;\n\n\t\tlet sub_id = subscription.id();\n\n\t\tensure!(!Subscriptions::\u003cT\u003e::contains_key(sub_id), Error::\u003cT\u003e::SubscriptionAlreadyExists);\n\n\t\tSubscriptions::\u003cT\u003e::insert(sub_id, subscription);\n\n\t\tSelf::deposit_event(Event::SubscriptionCreated { sub_id });\n\n\t\tOk(())\n\t}\n\n\tfn hold_fees(subscriber: \u0026T::AccountId, fees: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tT::Currency::hold(\u0026HoldReason::Fees.into(), subscriber, fees)\n\t}\n\n\tfn release_fees(subscriber: \u0026T::AccountId, fees: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tlet _ = T::Currency::release(\u0026HoldReason::Fees.into(), subscriber, fees, Precision::Exact)?;\n\t\tOk(())\n\t}\n\n\tfn manage_diff_fees(\n\t\tsubscriber: \u0026T::AccountId,\n\t\tdiff: \u0026DiffBalance\u003cBalanceOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\tmatch diff.direction {\n\t\t\tBalanceDirection::Collect =\u003e Self::hold_fees(subscriber, diff.balance),\n\t\t\tBalanceDirection::Release =\u003e Self::release_fees(subscriber, diff.balance),\n\t\t\tBalanceDirection::None =\u003e Ok(()),\n\t\t}\n\t}\n\n\tfn hold_deposit(subscriber: \u0026T::AccountId, deposit: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tT::Currency::hold(\u0026HoldReason::StorageDeposit.into(), subscriber, deposit)\n\t}\n\n\tfn release_deposit(subscriber: \u0026T::AccountId, deposit: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tlet _ = T::Currency::release(\n\t\t\t\u0026HoldReason::StorageDeposit.into(),\n\t\t\tsubscriber,\n\t\t\tdeposit,\n\t\t\tPrecision::BestEffort,\n\t\t)?;\n\t\tOk(())\n\t}\n\n\tfn manage_diff_deposit(\n\t\tsubscriber: \u0026T::AccountId,\n\t\tdiff: \u0026DiffBalance\u003cBalanceOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\tmatch diff.direction {\n\t\t\tBalanceDirection::Collect =\u003e Self::hold_deposit(subscriber, diff.balance),\n\t\t\tBalanceDirection::Release =\u003e Self::release_deposit(subscriber, diff.balance),\n\t\t\tBalanceDirection::None =\u003e Ok(()),\n\t\t}\n\t}\n\n\t/// Helper function to construct XCM message for randomness distribution\n\t// TODO: finish this off as part of https://github.com/ideal-lab5/idn-sdk/issues/77\n\tfn construct_randomness_xcm(_target: Location, _rnd: \u0026T::Rnd) -\u003e Result\u003cXcm\u003c()\u003e, Error\u003cT\u003e\u003e {\n\t\tOk(Xcm(vec![]))\n\t}\n\n\t/// Computes the fee for a given credits\n\tpub fn calculate_subscription_fees(credits: \u0026BlockNumberFor\u003cT\u003e) -\u003e BalanceOf\u003cT\u003e {\n\t\tT::FeesManager::calculate_subscription_fees(credits)\n\t}\n\n\t/// Retrieves a specific subscription\n\tpub fn get_subscription(sub_id: \u0026SubscriptionId) -\u003e Option\u003cSubscriptionOf\u003cT\u003e\u003e {\n\t\tSubscriptions::\u003cT\u003e::get(sub_id)\n\t}\n\n\t/// Retrieves all subscriptions for a specific subscriber\n\tpub fn get_subscriptions_for_subscriber(subscriber: \u0026T::AccountId) -\u003e Vec\u003cSubscriptionOf\u003cT\u003e\u003e {\n\t\tSubscriptions::\u003cT\u003e::iter()\n\t\t\t.filter(|(_, sub)| \u0026sub.details.subscriber == subscriber)\n\t\t\t.map(|(_, sub)| sub)\n\t\t\t.collect()\n\t}\n}\n\nimpl\u003cT: Config\u003e idn_traits::rand::Dispatcher\u003cT::Rnd, DispatchResult\u003e for Pallet\u003cT\u003e {\n\tfn dispatch(rnd: T::Rnd) -\u003e DispatchResult {\n\t\tPallet::\u003cT\u003e::distribute(rnd)\n\t}\n}\n\nsp_api::decl_runtime_apis! {\n\t#[api_version(1)]\n\tpub trait IdnManagerApi\u003cBalance, BlockNumber, Metadata, AccountId\u003e where\n\t\tBalance: Codec,\n\t\tBlockNumber: Codec + Unsigned,\n\t\tMetadata: Codec,\n\t\tAccountId: Codec,\n\t{\n\t\t/// Computes the fee for a given credits\n\t\t///\n\t\t/// See [`crate::Pallet::calculate_subscription_fees`]\n\t\tfn calculate_subscription_fees(\n\t\t\t// Number of random values to receive\n\t\t\tcredits: BlockNumber\n\t\t) -\u003e Balance;\n\n\t\t/// Retrieves a specific subscription\n\t\t///\n\t\t/// See [`crate::Pallet::get_subscription`]\n\t\tfn get_subscription(\n\t\t\t// Subscription ID\n\t\t\tsub_id: H256\n\t\t) -\u003e Option\u003cSubscription\u003c\n\t\t\t\tAccountId,\n\t\t\t\tBlockNumber,\n\t\t\t\tMetadata\n\t\t\t\u003e\u003e;\n\n\t\t/// Retrieves all subscriptions for a specific subscriber\n\t\t///\n\t\t/// See [`crate::Pallet::get_subscriptions_for_subscriber`]\n\t\tfn get_subscriptions_for_subscriber(\n\t\t\t// subscriber account ID\n\t\t\tsubscriber: AccountId\n\t\t) -\u003e Vec\u003cSubscription\u003c\n\t\t\t\tAccountId,\n\t\t\t\tBlockNumber,\n\t\t\t\tMetadata\n\t\t\t\u003e\u003e;\n\t}\n}\n","traces":[{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[4473946,4474096,4474016,4473968,4474029,4474162,4473969,4473904],"length":1,"stats":{"Line":8}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":299,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":316,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":319,"address":[],"length":0,"stats":{"Line":1}},{"line":320,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":370,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":373,"address":[],"length":0,"stats":{"Line":1}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":386,"address":[],"length":0,"stats":{"Line":1}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":388,"address":[],"length":0,"stats":{"Line":3}},{"line":389,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":394,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":1}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[4443664],"length":1,"stats":{"Line":1}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":412,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":417,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":4}},{"line":432,"address":[],"length":0,"stats":{"Line":10}},{"line":434,"address":[],"length":0,"stats":{"Line":6}},{"line":435,"address":[],"length":0,"stats":{"Line":6}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":4}},{"line":440,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":3}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":445,"address":[],"length":0,"stats":{"Line":2}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[4446528,4446773,4446798],"length":1,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":464,"address":[4446816],"length":1,"stats":{"Line":2}},{"line":468,"address":[],"length":0,"stats":{"Line":2}},{"line":469,"address":[],"length":0,"stats":{"Line":2}},{"line":470,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":5}},{"line":474,"address":[],"length":0,"stats":{"Line":1}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":482,"address":[4447296,4448685,4448842],"length":1,"stats":{"Line":1}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":4}},{"line":494,"address":[],"length":0,"stats":{"Line":4}},{"line":496,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":2}},{"line":498,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":4}},{"line":519,"address":[],"length":0,"stats":{"Line":2}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":527,"address":[],"length":0,"stats":{"Line":2}},{"line":530,"address":[],"length":0,"stats":{"Line":1}},{"line":531,"address":[],"length":0,"stats":{"Line":2}},{"line":532,"address":[],"length":0,"stats":{"Line":1}},{"line":535,"address":[4449392],"length":1,"stats":{"Line":1}},{"line":539,"address":[],"length":0,"stats":{"Line":1}},{"line":540,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":1}},{"line":546,"address":[],"length":0,"stats":{"Line":2}},{"line":547,"address":[],"length":0,"stats":{"Line":2}},{"line":550,"address":[],"length":0,"stats":{"Line":1}},{"line":552,"address":[],"length":0,"stats":{"Line":1}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":1}},{"line":557,"address":[],"length":0,"stats":{"Line":1}},{"line":560,"address":[4449984],"length":1,"stats":{"Line":1}},{"line":564,"address":[],"length":0,"stats":{"Line":1}},{"line":565,"address":[],"length":0,"stats":{"Line":1}},{"line":566,"address":[],"length":0,"stats":{"Line":1}},{"line":567,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":2}},{"line":574,"address":[],"length":0,"stats":{"Line":4}},{"line":578,"address":[],"length":0,"stats":{"Line":1}},{"line":579,"address":[],"length":0,"stats":{"Line":1}},{"line":583,"address":[],"length":0,"stats":{"Line":2}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":588,"address":[],"length":0,"stats":{"Line":1}},{"line":589,"address":[],"length":0,"stats":{"Line":1}},{"line":590,"address":[],"length":0,"stats":{"Line":2}},{"line":591,"address":[],"length":0,"stats":{"Line":2}},{"line":597,"address":[],"length":0,"stats":{"Line":2}},{"line":598,"address":[],"length":0,"stats":{"Line":2}}],"covered":134,"coverable":143},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","fee_examples.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Fee Calculators Examples\n//!\n//! This module contains examples of fee calculators that can be used in the IDN Manager pallet.\n\nuse crate::traits::{BalanceDirection, DiffBalance, FeesManager};\nuse sp_runtime::traits::Zero;\nuse sp_std::cmp::Ordering;\n\n/// Linear fee calculator with no discount\npub struct LinearFeeCalculator;\n\nconst BASE_FEE: u32 = 100;\n\nimpl FeesManager\u003cu32, u32, (), (), ()\u003e for LinearFeeCalculator {\n\tfn calculate_subscription_fees(credits: \u0026u32) -\u003e u32 {\n\t\tBASE_FEE.saturating_mul(credits.clone().into())\n\t}\n\tfn calculate_diff_fees(old_credits: \u0026u32, new_credits: \u0026u32) -\u003e DiffBalance\u003cu32\u003e {\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_credits.cmp(\u0026old_credits) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tSelf::calculate_subscription_fees(\n\t\t\t\t\t\u0026new_credits.clone().saturating_sub(old_credits.clone()),\n\t\t\t\t)\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\tSelf::calculate_subscription_fees(\n\t\t\t\t\t\u0026old_credits.clone().saturating_sub(new_credits.clone()),\n\t\t\t\t)\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\tfn collect_fees(fees: \u0026u32, _: \u0026()) -\u003e Result\u003cu32, crate::traits::FeesError\u003cu32, ()\u003e\u003e {\n\t\t// In this case, we don't need to do anything with the fees, so we just return them\n\t\tOk(*fees)\n\t}\n}\n\n/// Tiered fee calculator with predefined discount tiers\npub struct SteppedTieredFeeCalculator;\n\nimpl FeesManager\u003cu32, u32, (), (), ()\u003e for SteppedTieredFeeCalculator {\n\tfn calculate_subscription_fees(credits: \u0026u32) -\u003e u32 {\n\t\t// Define tier boundaries and their respective discount rates (in basis points)\n\t\tconst TIERS: [(u32, u32); 5] = [\n\t\t\t(1, 0),        // 0-10: 0% discount\n\t\t\t(11, 500),     // 11-100: 5% discount\n\t\t\t(101, 1000),   // 101-1000: 10% discount\n\t\t\t(1001, 2000),  // 1001-10000: 20% discount\n\t\t\t(10001, 3000), // 10001+: 30% discount\n\t\t];\n\n\t\tlet mut total_fee = 0u32;\n\t\tlet mut remaining_credits = *credits;\n\n\t\tfor (i, \u0026(current_tier_start, current_tier_discount)) in TIERS.iter().enumerate() {\n\t\t\t// If no remaining credits exit loop.\n\t\t\tif remaining_credits == 0 {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet next_tier_start = TIERS.get(i + 1).map(|\u0026(start, _)| start).unwrap_or(u32::MAX);\n\t\t\tlet credits_in_tier =\n\t\t\t\t(credits.min(\u0026next_tier_start.saturating_sub(1)) - current_tier_start + 1)\n\t\t\t\t\t.min(remaining_credits);\n\n\t\t\tlet tier_fee = BASE_FEE\n\t\t\t\t.saturating_mul(credits_in_tier)\n\t\t\t\t.saturating_mul((10_000 - current_tier_discount) as u32)\n\t\t\t\t.saturating_div(10_000);\n\n\t\t\ttotal_fee = total_fee.saturating_add(tier_fee);\n\t\t\tremaining_credits = remaining_credits.saturating_sub(credits_in_tier);\n\t\t}\n\n\t\ttotal_fee\n\t}\n\n\tfn calculate_diff_fees(old_credits: \u0026u32, new_credits: \u0026u32) -\u003e DiffBalance\u003cu32\u003e {\n\t\tlet old_fees = Self::calculate_subscription_fees(old_credits);\n\t\tlet new_fees = Self::calculate_subscription_fees(new_credits);\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_fees.cmp(\u0026old_fees) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tnew_fees - old_fees\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\told_fees - new_fees\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\tfn collect_fees(fees: \u0026u32, _: \u0026()) -\u003e Result\u003cu32, crate::traits::FeesError\u003cu32, ()\u003e\u003e {\n\t\t// In this case, we don't need to do anything with the fees, so we just return them\n\t\tOk(*fees)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn test_linear_fee_calculator() {\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u00261), 100);\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u002610), 1_000);\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u0026100), 10_000);\n\t}\n\n\t/// Thest when a subscription is fully used before being killed or the update does not change\n\t/// the credits.\n\t#[test]\n\tfn test_calculate_release_linear_fees_no_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 50; // no credits diff\n\t\tlet refund = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\t// there should be no refund as all credit has been used, or no difference in the update\n\t\tlet expected = 0;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::None },\n\t\t\t\"There should be no release when no diff in credits\"\n\t\t);\n\t}\n\n\t/// Test when a subscription is reduced or killed.\n\t#[test]\n\tfn test_calculate_release_linear_fees_lower_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 30; // 20 credits used\n\t\tlet refund = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 20 * BASE_FEE;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Release },\n\t\t\t\"There should be a release when new credits is lower than old credits\"\n\t\t);\n\t}\n\n\t/// Test when the subscription is extended.\n\t#[test]\n\tfn test_calculate_hold_linear_fees_greater_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 60; // all credits used\n\t\tlet hold = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 10 * BASE_FEE;\n\t\tassert_eq!(\n\t\t\thold,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Collect },\n\t\t\t\"There should be more held balance\"\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_stepped_tiered_calculator() {\n\t\t// Test first tier (no discount)\n\t\tassert_eq!(SteppedTieredFeeCalculator::calculate_subscription_fees(\u002610), 1_000); // 10 * 100 = 1,000\n\n\t\t// Test crossing into second tier\n\t\tlet fee_11 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002611);\n\t\tassert_eq!(fee_11, 1_095); // (10 * 100) + (1 * 95) = 1,000 + 95 = 1,095\n\n\t\t// Test middle of second tier\n\t\tlet fee_50 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002650);\n\t\tassert_eq!(fee_50, 4_800); // (10 * 100) + (40 * 95) = 1,000 + 3,800 = 4,800\n\n\t\t// Test edge of second tier\n\t\tlet fee_100 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026100);\n\t\tassert_eq!(fee_100, 9550); // (10 * 100) + (90 * 95) = 1,000 + 8,550 = 9,550\n\n\t\t// Test edge of second tier\n\t\tlet fee_101 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026101);\n\t\tassert_eq!(fee_101, 9_640); // (10 * 100) + (90 * 95) + (1 * 90)= 1,000 + 8,550 + 90 = 9,640\n\n\t\t// Test crossing multiple tiers\n\t\tlet fee_150 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026150);\n\t\t// First 10 at 100% = 1,000\n\t\t// Next 90 at 95% = 8,550\n\t\t// Next 50 at 90% = 4,500\n\t\t// Total should be 14,050\n\t\tassert_eq!(fee_150, 14_050);\n\t}\n\n\t#[test]\n\tfn test_no_price_inversion() {\n\t\t// Test that buying more never costs less\n\t\tlet fee_10 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002610);\n\t\tlet fee_11 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002611);\n\t\tassert!(fee_11 \u003e fee_10, \"11 credits should cost more than 10 credits\");\n\n\t\t// Test around the 100 credit boundary\n\t\tlet fee_100 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026100);\n\t\tlet fee_101 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026101);\n\t\tassert!(fee_101 \u003e fee_100, \"101 credits should cost more than 100 credits\");\n\t}\n\n\t/// Thest when a subscription is fully used before being killed or the update does not change\n\t/// the credits.\n\t#[test]\n\tfn test_calculate_release_stepped_fees_no_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 50; // no credits diff\n\t\tlet refund = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 0;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::None },\n\t\t\t\"There should be no release when no diff in credits\"\n\t\t);\n\t}\n\n\t/// Test for a partial usage scenario.\n\t#[test]\n\tfn test_calculate_release_stepped_fees_lower_diff() {\n\t\tlet old_credits: u32 = 110;\n\t\tlet new_credits: u32 = 100; // 1 value decrease\n\t\tlet refund = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 10 * BASE_FEE.saturating_mul(9_000).saturating_div(10_000); // 10% discount on the extra value\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Release },\n\t\t\t\"There should be a release when new credits is lower than old credits\"\n\t\t);\n\t}\n\n\t/// Test when the subscription is fully used.\n\t#[test]\n\tfn test_calculate_hold_stepped_fees_greater_diff() {\n\t\tlet old_credits: u32 = 100;\n\t\tlet new_credits: u32 = 101; // 1 value increase\n\t\tlet hold = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 1 * BASE_FEE.saturating_mul(9_000).saturating_div(10_000); // 10% discount on the extra value\n\t\tassert_eq!(\n\t\t\thold,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Collect },\n\t\t\t\"There should be more held balance\"\n\t\t);\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","mock.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Mock runtime\n//!\n//! This file is a mock runtime for the pallet. It is used to test the pallet in a test environment.\n//! It does not contain any tests.\n\nuse crate::{\n\tself as pallet_idn_manager,\n\timpls::{DepositCalculatorImpl, FeesManagerImpl},\n\tSubscriptionOf,\n};\nuse frame_support::{\n\tconstruct_runtime, derive_impl, parameter_types, sp_runtime::BuildStorage, traits::Get,\n};\nuse frame_system as system;\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::IdentityLookup, AccountId32};\n\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\nconstruct_runtime!(\n\tpub enum Test\n\t{\n\t\tSystem: frame_system,\n\t\tIdnManager: pallet_idn_manager,\n\t\tBalances: pallet_balances,\n\t}\n);\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype Block = Block;\n\ttype AccountId = AccountId32;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype AccountData = pallet_balances::AccountData\u003cu64\u003e;\n}\n\n#[derive_impl(pallet_balances::config_preludes::TestDefaultConfig)]\nimpl pallet_balances::Config for Test {\n\ttype AccountStore = System;\n}\n\nparameter_types! {\n\tpub const MaxSubscriptionDuration: u64 = 100;\n\tpub const PalletId: frame_support::PalletId = frame_support::PalletId(*b\"idn_mngr\");\n\tpub const TreasuryAccount: AccountId32 = AccountId32::new([123u8; 32]);\n\tpub const BaseFee: u64 = 10;\n\tpub const SDMultiplier: u64 = 10;\n}\n\n#[derive(TypeInfo)]\npub struct SubMetadataLen;\n\nimpl Get\u003cu32\u003e for SubMetadataLen {\n\tfn get() -\u003e u32 {\n\t\t8\n\t}\n}\n\nimpl pallet_idn_manager::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype FeesManager = FeesManagerImpl\u003cTreasuryAccount, BaseFee, SubscriptionOf\u003cTest\u003e, Balances\u003e;\n\ttype DepositCalculator = DepositCalculatorImpl\u003cSDMultiplier, u64\u003e;\n\ttype PalletId = PalletId;\n\ttype RuntimeHoldReason = RuntimeHoldReason;\n\ttype Rnd = [u8; 32];\n\ttype WeightInfo = ();\n\ttype Xcm = ();\n\ttype SubMetadataLen = SubMetadataLen;\n}\n\npub struct ExtBuilder;\n\nimpl ExtBuilder {\n\tpub fn build() -\u003e sp_io::TestExternalities {\n\t\tlet storage = system::GenesisConfig::\u003cTest\u003e::default().build_storage().unwrap();\n\t\tlet mut ext = sp_io::TestExternalities::new(storage);\n\t\text.execute_with(|| System::set_block_number(1));\n\t\text\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","pallet.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Tests for the IDN Manager pallet\n\nuse crate::{\n\ttests::mock::{Balances, ExtBuilder, Test, *},\n\ttraits::{BalanceDirection, DepositCalculator, DiffBalance, FeesManager},\n\tConfig, Error, Event, HoldReason, SubscriptionState, Subscriptions,\n};\nuse frame_support::{\n\tassert_noop, assert_ok,\n\tpallet_prelude::Zero,\n\ttraits::{\n\t\tfungible::{InspectHold, Mutate},\n\t\tOnFinalize,\n\t},\n\tBoundedVec,\n};\nuse idn_traits::rand::Dispatcher;\nuse sp_core::H256;\nuse sp_runtime::{AccountId32, DispatchError, TokenError};\nuse xcm::v5::{Junction, Location};\n\nconst ALICE: AccountId32 = AccountId32::new([1u8; 32]);\nconst BOB: AccountId32 = AccountId32::new([2u8; 32]);\n\nfn event_not_emitted(event: Event\u003cTest\u003e) -\u003e bool {\n\t!System::events().iter().any(|record| {\n\t\tif let RuntimeEvent::IdnManager(ref e) = \u0026record.event {\n\t\t\te == \u0026event\n\t\t} else {\n\t\t\tfalse\n\t\t}\n\t})\n}\n\nfn update_subscription(\n\tsubscriber: AccountId32,\n\toriginal_credits: u64,\n\toriginal_frequency: u64,\n\tnew_credits: u64,\n\tnew_frequency: u64,\n) {\n\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\tlet metadata = None;\n\tlet initial_balance = 99_990_000_000_000_000;\n\n\t\u003cTest as Config\u003e::Currency::set_balance(\u0026subscriber, initial_balance);\n\n\tassert_ok!(IdnManager::create_subscription(\n\t\tRuntimeOrigin::signed(subscriber.clone()),\n\t\toriginal_credits,\n\t\ttarget.clone(),\n\t\toriginal_frequency,\n\t\tmetadata.clone()\n\t));\n\n\t// Get the sub_id from the last emitted event\n\tlet sub_id = System::events()\n\t\t.iter()\n\t\t.rev()\n\t\t.find_map(|record| {\n\t\t\tif let RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id }) =\n\t\t\t\t\u0026record.event\n\t\t\t{\n\t\t\t\tSome(*sub_id)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.expect(\"SubscriptionCreated event should be emitted\");\n\n\tlet subscription = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\n\tassert_eq!(subscription.created_at, System::block_number());\n\tassert_eq!(subscription.updated_at, System::block_number());\n\n\tassert_eq!(subscription.details.subscriber, subscriber);\n\n\tlet original_fees =\n\t\t\u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026original_credits);\n\tlet original_deposit =\n\t\t\u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\tlet balance_after_create = initial_balance - original_fees - original_deposit;\n\n\t// assert correct balance on subscriber after creating subscription\n\tassert_eq!(Balances::free_balance(\u0026subscriber), balance_after_create);\n\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026subscriber), original_fees);\n\tassert_eq!(\n\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026subscriber),\n\t\toriginal_deposit\n\t);\n\n\t// Advance a block\n\tSystem::set_block_number(System::block_number() + 1);\n\n\tassert_ok!(IdnManager::update_subscription(\n\t\tRuntimeOrigin::signed(subscriber.clone()),\n\t\tsub_id,\n\t\tnew_credits,\n\t\tnew_frequency\n\t));\n\n\tlet new_fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026new_credits);\n\tlet new_deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\n\tlet fees_diff: i64 = new_fees as i64 - original_fees as i64;\n\n\tlet deposit_diff: i64 = new_deposit as i64 - original_deposit as i64;\n\n\t// We are using fixed-width integer types for credits and frequency, so Subscription objects\n\t// can't change in size with this mock. Unit tests are in place insted to ensure the correct\n\t// behaviour in case of other types used.\n\tassert!(deposit_diff.is_zero());\n\n\tlet balance_after_update: u64 =\n\t\t(balance_after_create as i64 - fees_diff - deposit_diff).try_into().unwrap();\n\n\t// assert fees and deposit diff is correctly handled\n\tassert_eq!(Balances::free_balance(\u0026subscriber), balance_after_update);\n\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026subscriber), new_fees);\n\tassert_eq!(\n\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026subscriber),\n\t\tnew_deposit\n\t);\n\tassert_eq!(balance_after_update + new_fees + new_deposit, initial_balance);\n\n\tlet subscription = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\n\tassert_eq!(subscription.created_at, System::block_number() - 1);\n\tassert_eq!(subscription.updated_at, System::block_number());\n\n\t// assert subscription details has been updated\n\tassert_eq!(subscription.credits, new_credits);\n\tassert_eq!(subscription.frequency, new_frequency);\n\n\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionUpdated {\n\t\tsub_id,\n\t}));\n}\n\n#[test]\nfn create_subscription_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// assert Subscriptions storage map is empty before creating a subscription\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 0);\n\n\t\t// assert that the subscription has been created\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 1);\n\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// assert that the correct fees have been held\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\n\t\t// assert that the subscription details are correct\n\t\tassert_eq!(subscription.details.subscriber, ALICE);\n\t\tassert_eq!(subscription.credits, credits);\n\t\tassert_eq!(subscription.details.target, target);\n\t\tassert_eq!(subscription.frequency, frequency);\n\t\tassert_eq!(\n\t\t\tsubscription.details.metadata,\n\t\t\tBoundedVec::\u003cu8, SubMetadataLen\u003e::try_from(vec![]).unwrap()\n\t\t);\n\n\t\t// assert that the correct event has been emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn create_subscription_fails_if_insufficient_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::create_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tcredits,\n\t\t\t\ttarget,\n\t\t\t\tfrequency,\n\t\t\t\tNone\n\t\t\t),\n\t\t\tTokenError::FundsUnavailable\n\t\t);\n\n\t\t// Assert the SubscriptionCreated event was not emitted\n\t\tassert!(!System::events().iter().any(|record| matches!(\n\t\t\trecord.event,\n\t\t\tRuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id: _ })\n\t\t)));\n\t});\n}\n\n#[test]\nfn create_subscription_fails_if_sub_already_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// erase all events\n\t\tSystem::reset_events();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::create_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tcredits,\n\t\t\t\ttarget,\n\t\t\t\tfrequency,\n\t\t\t\tNone\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyExists\n\t\t);\n\n\t\t// Assert the SubscriptionCreated event was not emitted\n\t\tassert!(!System::events().iter().any(|record| matches!(\n\t\t\trecord.event,\n\t\t\tRuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id: _ })\n\t\t)));\n\t});\n}\n\n#[test]\n// Todo: https://github.com/ideal-lab5/idn-sdk/issues/77\n// assert event RandomnessDistributed is emitted\n#[ignore]\nfn distribute_randomness_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tlet rnd = [0; 32];\n\n\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 1, \"Subscriptions count is not 1\");\n\n\t\tlet (_sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_eq!(subscription.state, SubscriptionState::Active, \"Subscription is not Active\");\n\t});\n}\n\n#[test]\nfn test_kill_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// assert that the correct fees have been held\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\t\tassert_ok!(IdnManager::kill_subscription(RuntimeOrigin::signed(ALICE), sub_id));\n\t\tassert!(Subscriptions::\u003cTest\u003e::get(sub_id).is_none());\n\n\t\t// assert remaining fees and balance refunded\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0u64);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0u64);\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn kill_subscription_fails_if_sub_does_not_exist() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::kill_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionRemoved event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionRemoved { sub_id }));\n\t});\n}\n\n#[test]\nfn on_finalize_removes_zero_credit_subscriptions() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup - Create a subscription\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get the subscription ID\n\t\tlet (sub_id, mut subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\n\t\t// Manually set credits to zero\n\t\tsubscription.credits_left = Zero::zero();\n\t\tSubscriptions::\u003cTest\u003e::insert(sub_id, subscription);\n\n\t\t// Verify subscription exists before on_finalize\n\t\tassert!(Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Call on_finalize directly\n\t\tlet current_block = System::block_number();\n\t\tcrate::Pallet::\u003cTest\u003e::on_finalize(current_block);\n\n\t\t// Verify subscription was removed\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// assert there are no remaining fees and balance refunded\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees);\n\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0u64);\n\n\t\t// Verify event was emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn test_update_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tstruct SubParams {\n\t\t\tcredits: u64,\n\t\t\tfrequency: u64,\n\t\t}\n\t\tstruct SubUpdate {\n\t\t\told: SubParams,\n\t\t\tnew: SubParams,\n\t\t}\n\n\t\tlet updates: Vec\u003cSubUpdate\u003e = vec![\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 10, frequency: 2 },\n\t\t\t\tnew: SubParams { credits: 20, frequency: 4 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 20 },\n\t\t\t\tnew: SubParams { credits: 20, frequency: 4 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 20 },\n\t\t\t\tnew: SubParams { credits: 100, frequency: 20 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 1 },\n\t\t\t\tnew: SubParams { credits: 9_999_999_999_999, frequency: 1 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 9_999_999_999_999, frequency: 1 },\n\t\t\t\tnew: SubParams { credits: 100, frequency: 1 },\n\t\t\t},\n\t\t];\n\t\tfor i in 0..updates.len() {\n\t\t\tlet update = \u0026updates[i];\n\t\t\tupdate_subscription(\n\t\t\t\tAccountId32::new([i.try_into().unwrap(); 32]),\n\t\t\t\tupdate.old.credits,\n\t\t\t\tupdate.old.frequency,\n\t\t\t\tupdate.new.credits,\n\t\t\t\tupdate.new.frequency,\n\t\t\t);\n\t\t}\n\t});\n}\n\n#[test]\nfn update_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\t\tlet new_credits = 20;\n\t\tlet new_frequency = 4;\n\n\t\tassert_noop!(\n\t\t\tIdnManager::update_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tsub_id,\n\t\t\t\tnew_credits,\n\t\t\t\tnew_frequency\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionUpdated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionUpdated { sub_id }));\n\t});\n}\n\n#[test]\n/// This test makes sure that the correct fees are collected, by consuming credits one by one.\nfn test_credits_consumption_and_cleanup() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup initial conditions\n\t\tlet credits: u64 = 1010;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 3;\n\t\tlet initial_balance = 10_000_000;\n\t\tlet mut treasury_balance = 0;\n\t\tlet rnd = [0u8; 32];\n\n\t\t// Set up account\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026TreasuryAccount::get(), treasury_balance);\n\n\t\t// Create subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get subscription details\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\t\tlet initial_fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet storage_deposit =\n\t\t\t\u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\n\t\t// Verify initial state\n\t\tassert_eq!(\n\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\tinitial_balance - initial_fees - storage_deposit\n\t\t);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), initial_fees);\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\tstorage_deposit\n\t\t);\n\t\tassert_eq!(subscription.credits_left, credits);\n\n\t\t// Consume credits one by one\n\t\tfor i in 0..credits {\n\t\t\t// Advance block and run hooks\n\t\t\tSystem::set_block_number(System::block_number() + 1);\n\n\t\t\t// Dispatch randomness\n\t\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\n\t\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(\n\t\t\t\tEvent::\u003cTest\u003e::RandomnessDistributed { sub_id },\n\t\t\t));\n\n\t\t\t// Verify credit consumption\n\t\t\tlet sub = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\t\t\tassert_eq!(sub.credits_left, credits - i - 1, \"Credit not consumed correctly\");\n\n\t\t\t// Verify fees movement to treasury\n\t\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_diff_fees(\n\t\t\t\t\u0026(credits - i),\n\t\t\t\t\u0026(credits - i - 1),\n\t\t\t)\n\t\t\t.balance;\n\n\t\t\ttreasury_balance += fees;\n\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(\u0026TreasuryAccount::get()),\n\t\t\t\ttreasury_balance,\n\t\t\t\t\"Fees not moved to treasury correctly\"\n\t\t\t);\n\n\t\t\tSystem::assert_has_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::FeesCollected {\n\t\t\t\tsub_id,\n\t\t\t\tfees,\n\t\t\t}));\n\n\t\t\t// assert balance has been collected from the hold\n\t\t\tassert_eq!(\n\t\t\t\tBalances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE),\n\t\t\t\tinitial_fees - treasury_balance\n\t\t\t);\n\n\t\t\t// assert free balance is still correct\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\t\tinitial_balance - initial_fees - storage_deposit\n\t\t\t);\n\n\t\t\t// finalize block\n\t\t\tIdnManager::on_finalize(System::block_number());\n\t\t}\n\n\t\t// Verify subscription is removed after last credit\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Verify final balances\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - initial_fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\tassert_eq!(Balances::free_balance(\u0026TreasuryAccount::get()), initial_fees);\n\n\t\t// Verify events\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn test_credits_consumption_not_enogh_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup initial conditions\n\t\tlet credits: u64 = 1010;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 3;\n\t\tlet initial_balance = 10_000_000;\n\t\tlet rnd = [0u8; 32];\n\n\t\t// Set up account\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Create subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get subscription details\n\t\tlet (_, sub) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Consume credits one by one\n\t\tfor i in 0..credits {\n\t\t\t// Advance block and run hooks\n\t\t\tSystem::set_block_number(System::block_number() + 1);\n\n\t\t\tif i == 505 {\n\t\t\t\t// let's fake an incorrect fees collection at some arbitrary point\n\t\t\t\tlet _ = \u003cTest as Config\u003e::FeesManager::collect_fees(\n\t\t\t\t\t\u0026Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE),\n\t\t\t\t\t\u0026sub,\n\t\t\t\t);\n\t\t\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0);\n\t\t\t\tassert_noop!(\n\t\t\t\t\tIdnManager::dispatch(rnd.into()),\n\t\t\t\t\tDispatchError::Other(\"NotEnoughBalance\")\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Dispatch randomness\n\t\t\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\t\t\t}\n\n\t\t\t// finalize block\n\t\t\tIdnManager::on_finalize(System::block_number());\n\t\t}\n\t});\n}\n\n#[test]\nfn test_pause_reactivate_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet free_balance = Balances::free_balance(\u0026ALICE);\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Test pause and reactivate subscription\n\t\tassert_ok!(IdnManager::pause_subscription(RuntimeOrigin::signed(ALICE.clone()), sub_id));\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionPaused {\n\t\t\tsub_id,\n\t\t}));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::get(sub_id).unwrap().state, SubscriptionState::Paused);\n\t\tassert_ok!(IdnManager::reactivate_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tsub_id\n\t\t));\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::get(sub_id).unwrap().state, SubscriptionState::Active);\n\n\t\t// Assert current free balance is the same as the free balance before pausing and\n\t\t// reactivating\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), free_balance);\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(\n\t\t\tEvent::\u003cTest\u003e::SubscriptionReactivated { sub_id },\n\t\t));\n\t});\n}\n\n#[test]\nfn pause_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\t});\n}\n\n#[test]\nfn pause_subscription_fails_if_sub_already_paused() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_ok!(IdnManager::pause_subscription(RuntimeOrigin::signed(ALICE.clone()), sub_id));\n\n\t\t// erase all events\n\t\tSystem::reset_events();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyPaused\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\t});\n}\n\n#[test]\nfn reactivate_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn reactivate_subscriptio_fails_if_sub_already_active() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyActive\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn operations_fail_if_origin_is_not_the_subscriber() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet metadata = None;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t// Set balance for Alice and Bob\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026BOB, initial_balance);\n\n\t\t// Create subscription for Alice\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\t// Retrieve the subscription ID created\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Attempt to kill the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::kill_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// assert subscription still exists\n\t\tassert!(Subscriptions::\u003cTest\u003e::get(sub_id).is_some());\n\n\t\t// Assert the SubscriptionRemoved event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionRemoved { sub_id }));\n\n\t\t// Attempt to pause the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\n\t\t// Attempt to update the subscription using Bob's origin (should fail)\n\t\tlet new_credits = credits + 10;\n\t\tlet new_frequency = frequency + 1;\n\t\tassert_noop!(\n\t\t\tIdnManager::update_subscription(\n\t\t\t\tRuntimeOrigin::signed(BOB.clone()),\n\t\t\t\tsub_id,\n\t\t\t\tnew_credits,\n\t\t\t\tnew_frequency\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Attempt to reactivate the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn test_on_finalize_removes_finished_subscriptions() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t// Create subscription\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tlet (sub_id, mut subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Manually set credits to zero to simulate a finished subscription\n\t\tsubscription.credits_left = Zero::zero();\n\t\tSubscriptions::\u003cTest\u003e::insert(sub_id, subscription);\n\n\t\t// Before on_finalize, subscription should exist\n\t\tassert!(Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Call on_finalize\n\t\tcrate::Pallet::\u003cTest\u003e::on_finalize(System::block_number());\n\n\t\t// After on_finalize:\n\t\t// 1. Subscription should be removed\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// 2. SubscriptionRemoved event should be emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn hold_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account with initial balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Hold deposit\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Verify deposit is held\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\tdeposit_credits\n\t\t);\n\t\t// Verify free balance is reduced\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - deposit_credits);\n\t});\n}\n\n#[test]\nfn release_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account and hold deposit\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Release deposit\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::release_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Verify deposit is released\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\t// Verify free balance is restored\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t});\n}\n\n#[test]\nfn manage_diff_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet original_deposit = 1_000;\n\t\tlet additional_deposit = 1_500;\n\t\tlet excess_deposit = 500;\n\n\t\t// Setup account with initial balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Test holding deposit\n\t\tlet hold_diff =\n\t\t\tDiffBalance { balance: original_deposit, direction: BalanceDirection::Collect };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026hold_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit\n\t\t);\n\t\t// Test holding additional deposit\n\t\tlet hold_diff =\n\t\t\tDiffBalance { balance: additional_deposit, direction: BalanceDirection::Collect };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026hold_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit + additional_deposit\n\t\t);\n\n\t\t// Test releasing excess deposit\n\t\tlet release_diff =\n\t\t\tDiffBalance { balance: excess_deposit, direction: BalanceDirection::Release };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026release_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit + additional_deposit - excess_deposit\n\t\t);\n\n\t\t// Test no change in deposit\n\t\tlet no_change_diff = DiffBalance { balance: 0, direction: BalanceDirection::None };\n\t\tlet held_before = Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE);\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026no_change_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\theld_before\n\t\t);\n\n\t\t// assert free balance\n\t\tassert_eq!(\n\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\tinitial_balance - original_deposit - additional_deposit + excess_deposit\n\t\t);\n\t});\n}\n\n#[test]\nfn hold_deposit_fails_with_insufficient_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 500;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account with insufficient balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Attempt to hold deposit should fail\n\t\tassert_noop!(\n\t\t\tcrate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits),\n\t\t\tTokenError::FundsUnavailable\n\t\t);\n\n\t\t// Verify no deposit is held\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\t// Verify balance remains unchanged\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t});\n}\n\n#[test]\nfn test_calculate_subscription_fees() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Test with different credit amounts\n\t\tlet test_cases = vec![\n\t\t\t(0, 0),     // Zero credits\n\t\t\t(1, 100),   // One credit (base fee)\n\t\t\t(10, 1000), // Ten credits\n\t\t\t(50, 4800), // Fifty credits, 5% discount over 10\n\t\t\t(1000, 90550),\n\t\t\t(1001, 90630),\n\t\t];\n\n\t\tfor (credits, expected_fee) in test_cases {\n\t\t\tlet fee = IdnManager::calculate_subscription_fees(\u0026credits);\n\t\t\tassert_eq!(\n\t\t\t\tfee, expected_fee,\n\t\t\t\t\"Fee calculation incorrect for {} credits, expected {}, got {}\",\n\t\t\t\tcredits, expected_fee, fee\n\t\t\t);\n\t\t}\n\t});\n}\n\n#[test]\nfn test_get_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\t// Create a subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Retrieve the subscription ID created\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Test get_subscription with valid ID\n\t\tlet subscription = IdnManager::get_subscription(\u0026sub_id);\n\t\tassert!(subscription.is_some(), \"Subscription should exist\");\n\n\t\tlet sub = subscription.unwrap();\n\t\tassert_eq!(sub.details.subscriber, ALICE);\n\t\tassert_eq!(sub.credits, credits);\n\t\tassert_eq!(sub.frequency, frequency);\n\t\tassert_eq!(sub.details.target, target);\n\n\t\t// Test get_subscription with invalid ID\n\t\tlet invalid_sub_id = H256::from_slice(\u0026[0xff; 32]);\n\t\tlet invalid_subscription = IdnManager::get_subscription(\u0026invalid_sub_id);\n\t\tassert!(invalid_subscription.is_none(), \"Invalid subscription ID should return None\");\n\t});\n}\n\n#[test]\nfn test_get_subscriptions_for_subscriber() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Set up accounts\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026BOB, 10_000_000);\n\n\t\t// Create subscriptions for ALICE\n\t\tlet target1 = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet target2 = Location::new(1, [Junction::PalletInstance(2)]);\n\t\tlet target3 = Location::new(1, [Junction::PalletInstance(3)]);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\t50,\n\t\t\ttarget1.clone(),\n\t\t\t10,\n\t\t\tNone\n\t\t));\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\t100,\n\t\t\ttarget2.clone(),\n\t\t\t20,\n\t\t\tNone\n\t\t));\n\n\t\t// Create a subscription for BOB\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(BOB.clone()),\n\t\t\t75,\n\t\t\ttarget3.clone(),\n\t\t\t15,\n\t\t\tNone\n\t\t));\n\n\t\t// Test get_subscriptions_for_subscriber with ALICE\n\t\tlet alice_subs = IdnManager::get_subscriptions_for_subscriber(\u0026ALICE);\n\t\tassert_eq!(alice_subs.len(), 2, \"ALICE should have 2 subscriptions\");\n\n\t\t// Verify subscription details\n\t\tlet has_sub1 = alice_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == ALICE \u0026\u0026\n\t\t\t\tsub.credits == 50 \u0026\u0026\n\t\t\t\tsub.frequency == 10 \u0026\u0026\n\t\t\t\tsub.details.target == target1\n\t\t});\n\n\t\tlet has_sub2 = alice_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == ALICE \u0026\u0026\n\t\t\t\tsub.credits == 100 \u0026\u0026\n\t\t\t\tsub.frequency == 20 \u0026\u0026\n\t\t\t\tsub.details.target == target2\n\t\t});\n\n\t\tassert!(has_sub1, \"ALICE's first subscription not found\");\n\t\tassert!(has_sub2, \"ALICE's second subscription not found\");\n\n\t\t// Test get_subscriptions_for_subscriber with BOB\n\t\tlet bob_subs = IdnManager::get_subscriptions_for_subscriber(\u0026BOB);\n\t\tassert_eq!(bob_subs.len(), 1, \"BOB should have 1 subscription\");\n\n\t\t// Verify subscription details\n\t\tlet has_sub3 = bob_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == BOB \u0026\u0026\n\t\t\t\tsub.credits == 75 \u0026\u0026\n\t\t\t\tsub.frequency == 15 \u0026\u0026\n\t\t\t\tsub.details.target == target3\n\t\t});\n\n\t\tassert!(has_sub3, \"BOB's subscription not found\");\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Tests parent module\n//!\n//! Find tests in the submodules.\n\nmod fee_examples;\nmod mock;\nmod pallet;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","traits.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Traits\n\n/// Error type for fees management\n///\n/// Context is used to provide more information about uncategorized errors.\npub enum FeesError\u003cFees, Context\u003e {\n\tNotEnoughBalance { needed: Fees, balance: Fees },\n\tOther(Context),\n}\n\n/// Enum to represent the direction of balance movement.\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub enum BalanceDirection {\n\tCollect,\n\tRelease,\n\t// Balance isn't going anywhere. This is usually the case when diff is zero.\n\tNone,\n}\n\n/// This struct represent movement of balance.\n///\n/// * `balance` - how much balance being moved.\n/// * `direction` - if the balance are being collected or released.\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub struct DiffBalance\u003cBalance\u003e {\n\tpub balance: Balance,\n\tpub direction: BalanceDirection,\n}\n\n/// Trait for fees managing\npub trait FeesManager\u003cFees, Credits, Sub: Subscription\u003cS\u003e, Err, S\u003e {\n\t/// Calculate the fees for a subscription based on the credits of random values required.\n\tfn calculate_subscription_fees(credits: \u0026Credits) -\u003e Fees;\n\t/// Calculate how much fees should be held or release when a subscription changes.\n\t///\n\t/// * `old_credits` - the credits of random values required before the change.\n\t/// * `new_credits` - the credits of random values required after the change, this will\n\t///   represent the updated credits in an update operation. Or the credits actually consumed in\n\t///   a kill operation.\n\tfn calculate_diff_fees(old_credits: \u0026Credits, new_credits: \u0026Credits) -\u003e DiffBalance\u003cFees\u003e;\n\t/// Distributes collected fees. Returns the fees that were effectively collected.\n\tfn collect_fees(fees: \u0026Fees, sub: \u0026Sub) -\u003e Result\u003cFees, FeesError\u003cFees, Err\u003e\u003e;\n}\n\npub trait Subscription\u003cSubscriber\u003e {\n\tfn subscriber(\u0026self) -\u003e \u0026Subscriber;\n}\n\n/// Trait for storage deposit calculation\n///\n/// This trait is used to calculate the storage deposit required for a subscription based it.\npub trait DepositCalculator\u003cDeposit, Sub\u003e {\n\t/// Calculate the storage deposit required for a subscription.\n\tfn calculate_storage_deposit(sub: \u0026Sub) -\u003e Deposit;\n\t/// Calculate the difference in storage deposit between two subscriptions.\n\t///\n\t/// * `old_sub` - the old subscription.\n\t/// * `new_sub` - the new subscription.\n\tfn calculate_diff_deposit(old_sub: \u0026Sub, new_sub: \u0026Sub) -\u003e DiffBalance\u003cDeposit\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","weights.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse frame_support::weights::Weight;\n\npub trait WeightInfo {\n\tfn create_subscription() -\u003e Weight;\n\tfn pause_subscription() -\u003e Weight;\n\tfn reactivate_subscription() -\u003e Weight;\n\tfn kill_subscription() -\u003e Weight;\n\tfn update_subscription() -\u003e Weight;\n}\n\nimpl WeightInfo for () {\n\tfn create_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn pause_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn reactivate_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn kill_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn update_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n}\n","traces":[{"line":28,"address":[4221312],"length":1,"stats":{"Line":0}},{"line":29,"address":[4221313],"length":1,"stats":{"Line":0}},{"line":31,"address":[4221344],"length":1,"stats":{"Line":0}},{"line":32,"address":[4221345],"length":1,"stats":{"Line":0}},{"line":34,"address":[4221376],"length":1,"stats":{"Line":0}},{"line":35,"address":[4221377],"length":1,"stats":{"Line":0}},{"line":37,"address":[4221408],"length":1,"stats":{"Line":0}},{"line":38,"address":[4221409],"length":1,"stats":{"Line":0}},{"line":40,"address":[4221440],"length":1,"stats":{"Line":0}},{"line":41,"address":[4221441],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","aggregator.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! A collection of verifiers for randomness beacon pulses\nuse crate::{\n\tbls12_381,\n\ttypes::{Aggregate, OpaquePublicKey, OpaqueSignature, RoundNumber},\n};\nuse alloc::vec::Vec;\nuse ark_ec::{hashing::HashToCurve, AffineRepr};\nuse ark_serialize::{CanonicalDeserialize, CanonicalSerialize};\nuse sha2::{Digest, Sha256};\nuse timelock::{curves::drand::TinyBLS381, tlock::EngineBLS};\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n\n/// Something that can verify beacon pulses\npub trait SignatureAggregator {\n\t/// Aggregate the new signature to an old one and then verify it\n\t///\n\t/// * `beacon_pk_bytes`:\n\tfn aggregate_and_verify(\n\t\tbeacon_pk_bytes: OpaquePublicKey,\n\t\tnext_sig_bytes: OpaqueSignature,\n\t\tstart: RoundNumber,\n\t\theight: RoundNumber,\n\t\tprev_sig_and_msg: Option\u003cAggregate\u003e,\n\t) -\u003e Result\u003cAggregate, Error\u003e;\n}\n\n#[derive(Debug, PartialEq)]\npub enum Error {\n\t/// The input could not be deserialized to a point on G1\n\tDeserializeG1Failure,\n\t/// The input could not be deserialized to a point on G2\n\tDeserializeG2Failure,\n\t/// Verification for the siganture failed.\n\tInvalidSignature,\n\t/// The input buffer could not be hashed.\n\tInvalidBuffer,\n}\n\n/// A verifier to check values received from Drand quicknet. It outputs true if valid, false\n/// otherwise\n///\n/// [Quicknet](https://drand.love/blog/quicknet-is-live-on-the-league-of-entropy-mainnet) operates in an unchained mode,\n/// so messages contain only the round number. in addition, public keys are in G2 and signatures are\n/// in G1.\n///\n/// Values are valid if the pairing equality holds: $e(sig, g_2) == e(msg_on_curve, pk)$\n/// where $sig \\in \\mathbb{G}_1$ is the signature\n///       $g_2 \\in \\mathbb{G}_2$ is a generator\n///       $msg_on_curve \\in \\mathbb{G}_1$ is a hash of the message that drand signed,\n/// (hash(round_number))        $pk \\in \\mathbb{G}_2$ is the public key, read from the input public\n/// parameters\n///\n/// The implementation is responsible for construcing the public key that is required to verify the\n/// signature. In order to avoid long-running aggregations, the function allows an optional\n/// 'checkpoint' aggregated sig and public key that can be used to 'start' from. The function is\n/// intended to efficiently verify that:\n/// 1) New signatures are correct\n/// 2) The new signatures follow a monotonically increasing sequence and are an extension of\n///    previous a monotonically increasing sequences that I have observed.\n///\n/// More explicitly, it is intended to allow for the runtime to 'follow' a long-running,\n/// aggregated signature and public key that allows it to efficiently prove it has observed all\n/// pulses from the randomness beacon within some given range of round numbers.\npub struct QuicknetAggregator;\n\nimpl SignatureAggregator for QuicknetAggregator {\n\tfn aggregate_and_verify(\n\t\tbeacon_pk_bytes: OpaquePublicKey,\n\t\tnext_sig_bytes: OpaqueSignature,\n\t\tstart: RoundNumber,\n\t\theight: RoundNumber,\n\t\tprev_sig_and_msg: Option\u003cAggregate\u003e,\n\t) -\u003e Result\u003cAggregate, Error\u003e {\n\t\tlet beacon_pk = decode_g2(\u0026beacon_pk_bytes)?;\n\t\t// apk = 0, asig = new_sig\n\t\tlet mut apk = zero_on_g1();\n\t\tlet mut asig = decode_g1(\u0026next_sig_bytes)?;\n\n\t\t// if a previous signature and pubkey were provided\n\t\t// then we start there\n\t\tif let Some(aggr) = prev_sig_and_msg {\n\t\t\tlet prev_asig = decode_g1(\u0026aggr.signature)?;\n\t\t\tlet prev_apk = decode_g1(\u0026aggr.message_hash)?;\n\t\t\tasig = (asig + prev_asig).into();\n\t\t\tapk = (apk + prev_apk).into();\n\t\t}\n\n\t\t// compute new rounds\n\t\tlet latest = start + height;\n\t\tlet rounds = (start..latest).collect::\u003cVec\u003c_\u003e\u003e();\n\n\t\t// TODO: Investigate lookup table for round numbers\n\t\t// https://github.com/ideal-lab5/idn-sdk/issues/119\n\t\tfor r in rounds {\n\t\t\tlet q = compute_round_on_g1(r)?;\n\t\t\tapk = (apk + q).into()\n\t\t}\n\n\t\tlet g2 = G2AffineOpt::generator();\n\t\tlet validity = bls12_381::fast_pairing_opt(asig, g2, apk, beacon_pk);\n\n\t\tif !validity {\n\t\t\treturn Err(Error::InvalidSignature);\n\t\t}\n\n\t\t// convert to bytes\n\t\tlet mut sig_bytes = Vec::new();\n\t\t// note: this line is untestable\n\t\t// Message for SRLABS: can we use an .expect here instead?\n\t\tasig.serialize_compressed(\u0026mut sig_bytes)\n\t\t\t.map_err(|_| Error::DeserializeG1Failure)?;\n\t\tlet new_asig = OpaqueSignature::truncate_from(sig_bytes.clone());\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\t// note: this line is untestable\n\t\tapk.serialize_compressed(\u0026mut apk_bytes)\n\t\t\t.map_err(|_| Error::DeserializeG2Failure)?;\n\t\tlet new_apk = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\tOk(Aggregate { signature: new_asig, message_hash: new_apk })\n\t}\n}\n\n/// Constructs a message (e.g. signed by drand)\nfn message(current_round: RoundNumber, prev_sig: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n\tlet mut hasher = Sha256::default();\n\thasher.update(prev_sig);\n\thasher.update(current_round.to_be_bytes());\n\thasher.finalize().to_vec()\n}\n\n/// This computes the point on G1 given a round number (for message construction).\n/// TODO: do we save anything by pulling out the hasher instead of constructing it each time?\n/// https://github.com/ideal-lab5/idn-sdk/issues/119\npub(crate) fn compute_round_on_g1(round: u64) -\u003e Result\u003cG1AffineOpt, Error\u003e {\n\tlet message = message(round, \u0026[]);\n\tlet hasher = \u003cTinyBLS381 as EngineBLS\u003e::hash_to_curve_map();\n\t// H(m) \\in G1\n\tlet message_hash = hasher.hash(\u0026message).map_err(|_| Error::InvalidBuffer)?;\n\n\tlet mut bytes = Vec::new();\n\tmessage_hash\n\t\t.serialize_compressed(\u0026mut bytes)\n\t\t.map_err(|_| Error::DeserializeG1Failure)?;\n\n\tdecode_g1(\u0026bytes)\n}\n\n/// Computes the 0 point in the G1 group\npub(crate) fn zero_on_g1() -\u003e G1AffineOpt {\n\tG1AffineOpt::zero()\n}\n\n/// Attempts to decode the byte array to a point on G1\nfn decode_g1(mut bytes: \u0026[u8]) -\u003e Result\u003cG1AffineOpt, Error\u003e {\n\tG1AffineOpt::deserialize_compressed(\u0026mut bytes).map_err(|_| Error::DeserializeG1Failure)\n}\n\n/// Attempts to decode the byte array to a point on G2\nfn decode_g2(mut bytes: \u0026[u8]) -\u003e Result\u003cG2AffineOpt, Error\u003e {\n\tG2AffineOpt::deserialize_compressed(\u0026mut bytes).map_err(|_| Error::DeserializeG2Failure)\n}\n\n#[cfg(test)]\npub mod test {\n\tuse super::*;\n\tuse ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n\n\tpub(crate) type RawPulse = (u64, [u8; 96]);\n\tpub(crate) const PULSE1000: RawPulse = (1000u64, *b\"b44679b9a59af2ec876b1a6b1ad52ea9b1615fc3982b19576350f93447cb1125e342b73a8dd2bacbe47e4b6b63ed5e39\");\n\tpub(crate) const PULSE1001: RawPulse = (1001u64, *b\"b33bf3667cbd5a82de3a24b4e0e9fe5513cc1a0e840368c6e31f5fcfa79bea03f73896b25883abf2853d10337fb8fa41\");\n\tpub(crate) const PULSE1002: RawPulse = (1002u64, *b\"ab066f9c12dd6de1336fca0f925192fb0c72a771c3e4c82ede1fd362c1a770f9eb05843c6308ce2530b53a99c0281a6e\");\n\tpub(crate) const PULSE1003: RawPulse = (1003u64, *b\"b104c82771698f45fd8dcfead083d482694c31ab519bcef077f126f3736fe98c8392fd5d45d88aeb76b56ccfcb0296d7\");\n\n\t// output the asig + apk\n\tpub(crate) fn get(pulse_data: Vec\u003cRawPulse\u003e) -\u003e (OpaqueSignature, OpaqueSignature) {\n\t\tlet mut apk = zero_on_g1();\n\t\tlet mut asig = zero_on_g1();\n\n\t\tfor pulse in pulse_data {\n\t\t\tlet sig_bytes = hex::decode(\u0026pulse.1).unwrap();\n\t\t\tlet sig = G1AffineOpt::deserialize_compressed(\u0026mut sig_bytes.as_slice()).unwrap();\n\t\t\tasig = (asig + sig).into();\n\n\t\t\tlet pk = compute_round_on_g1(pulse.0).unwrap();\n\t\t\tapk = (apk + pk).into();\n\t\t}\n\n\t\tlet mut asig_bytes = Vec::new();\n\t\tasig.serialize_compressed(\u0026mut asig_bytes).unwrap();\n\t\tlet asig_out = OpaqueSignature::truncate_from(asig_bytes);\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\tapk.serialize_compressed(\u0026mut apk_bytes).unwrap();\n\t\tlet apk_out = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\t(asig_out, apk_out)\n\t}\n\n\t// sk * G \\in G2\n\tfn get_beacon_pk() -\u003e Vec\u003cu8\u003e {\n\t\tlet pk_bytes = b\"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a\";\n\t\thex::decode(pk_bytes).unwrap()\n\t}\n\n\t// d = sk * Q(1000)\n\t// in the case of no aggregation, it outputs the input if valid\n\t#[test]\n\tfn can_verify_single_pulse_with_quicknet_style_verifier_no_prev() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1000u64,\n\t\t\t1,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(sig, aggr.signature);\n\t\tassert_eq!(pk, aggr.message_hash);\n\t}\n\n\t// d1 = sk * Q(1000), d2 = sk * Q(1001) =\u003e verify d = d1 + d2\n\t#[test]\n\tfn can_verify_aggregated_sigs_no_prev() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000, PULSE1001, PULSE1002]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1000u64,\n\t\t\t3,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(sig, aggr.signature);\n\t\tassert_eq!(pk, aggr.message_hash);\n\t}\n\n\t// d1 = sk * Q(1000), d2 = sk * Q(1001) =\u003e verify d = d1 + d2\n\t#[test]\n\tfn can_verify_sigs_with_aggregation() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000]);\n\t\tlet (next_sig, _next_pk) = get(vec![PULSE1001, PULSE1002]);\n\n\t\tlet (expected_asig, expected_apk) = get(vec![PULSE1000, PULSE1001, PULSE1002]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tnext_sig.clone(),\n\t\t\t1001u64,\n\t\t\t2,\n\t\t\tSome(Aggregate { signature: sig, message_hash: pk }),\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(aggr.signature, expected_asig);\n\t\tassert_eq!(aggr.message_hash, expected_apk);\n\t}\n\n\t#[test]\n\tfn can_verify_invalid_with_mismatched_sig_and_round() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, _pk) = get(vec![PULSE1000]);\n\n\t\tlet res = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1002u64,\n\t\t\t1,\n\t\t\tNone,\n\t\t);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(Err(Error::InvalidSignature), res);\n\t}\n\n\t/// Test that `message` is deterministic and returns a 32-byte SHA256 digest.\n\t#[test]\n\tfn test_message_deterministic() {\n\t\tlet round: RoundNumber = 42;\n\t\tlet prev_sig = b\"previous_signature\";\n\t\tlet msg1 = message(round, prev_sig);\n\t\tlet msg2 = message(round, prev_sig);\n\t\tassert_eq!(msg1, msg2, \"Message function should be deterministic for the same inputs\");\n\t\tassert_eq!(msg1.len(), 32, \"SHA256 digest must be 32 bytes long\");\n\t}\n\n\t/// Test that different round numbers result in different message outputs.\n\t#[test]\n\tfn test_message_different_rounds() {\n\t\tlet prev_sig = b\"prev\";\n\t\tlet msg1 = message(1, prev_sig);\n\t\tlet msg2 = message(2, prev_sig);\n\t\tassert_ne!(msg1, msg2, \"Different rounds should produce different messages\");\n\t}\n\n\t/// Test that `zero_on_g1` returns the identity element on G1.\n\t#[test]\n\tfn test_zero_on_g1() {\n\t\tlet zero_point = zero_on_g1();\n\t\tassert!(zero_point.is_zero(), \"zero_on_g1 should return the identity element (zero)\");\n\t}\n\n\t/// Test that a G1 point can be serialized and then correctly deserialized.\n\t#[test]\n\tfn test_decode_g1_roundtrip() {\n\t\t// Use the identity element as a test case.\n\t\tlet point = zero_on_g1();\n\t\tlet mut serialized = Vec::new();\n\t\tpoint.serialize_compressed(\u0026mut serialized).unwrap();\n\t\tlet decoded_point = decode_g1(\u0026serialized).expect(\"Decoding should succeed\");\n\t\tassert_eq!(point, decoded_point, \"Decoded G1 point should equal the original point\");\n\t}\n\n\t/// Test that `decode_g1` returns an error for invalid input.\n\t#[test]\n\tfn test_decode_g1_invalid() {\n\t\tlet invalid_bytes = b\"invalid bytes\";\n\t\tlet result = decode_g1(invalid_bytes);\n\t\tassert!(result.is_err(), \"Decoding invalid G1 bytes should return an error\");\n\t}\n\n\t/// Test that a G2 point (e.g. the generator) can be serialized and then correctly deserialized.\n\t#[test]\n\tfn test_decode_g2_roundtrip() {\n\t\tlet point = G2AffineOpt::generator();\n\t\tlet mut serialized = Vec::new();\n\t\tpoint.serialize_compressed(\u0026mut serialized).unwrap();\n\t\tlet decoded_point = decode_g2(\u0026serialized).expect(\"Decoding should succeed\");\n\t\tassert_eq!(\n\t\t\tpoint, decoded_point,\n\t\t\t\"Decoded G2 point should equal the original generator point\"\n\t\t);\n\t}\n\n\t/// Test that `decode_g2` returns an error for invalid input.\n\t#[test]\n\tfn test_decode_g2_invalid() {\n\t\tlet invalid_bytes = b\"invalid bytes\";\n\t\tlet result = decode_g2(invalid_bytes);\n\t\tassert!(result.is_err(), \"Decoding invalid G2 bytes should return an error\");\n\t\tassert_eq!(result, Err(Error::DeserializeG2Failure));\n\t}\n\n\t/// Test that `compute_round_on_g1` produces a valid point for a given round.\n\t#[test]\n\tfn test_compute_round_on_g1() {\n\t\tlet round = 1;\n\t\tlet result = compute_round_on_g1(round);\n\t\tassert!(result.is_ok(), \"compute_round_on_g1 should succeed for a valid round\");\n\t\tlet point = result.unwrap();\n\t\t// While it is possible (though unlikely) for a hash-to-curve result to be the identity,\n\t\t// in practice this should not happen.\n\t\tassert!(!point.is_zero(), \"The computed round point should not be the identity element\");\n\t}\n}\n","traces":[{"line":87,"address":[5299392,5301667,5304080],"length":1,"stats":{"Line":2}},{"line":94,"address":[5299772,5299613,5299497,5303985],"length":1,"stats":{"Line":2}},{"line":96,"address":[5299757],"length":1,"stats":{"Line":1}},{"line":97,"address":[5303980,5300043,5299814],"length":1,"stats":{"Line":1}},{"line":101,"address":[5300085,5300003],"length":1,"stats":{"Line":2}},{"line":102,"address":[5300136,5300490,5300240,5301618],"length":1,"stats":{"Line":2}},{"line":103,"address":[5301601,5301002,5300462,5300529],"length":1,"stats":{"Line":2}},{"line":104,"address":[5300739,5301036],"length":1,"stats":{"Line":2}},{"line":105,"address":[5301182],"length":1,"stats":{"Line":1}},{"line":109,"address":[5300167,5301692,5301715],"length":1,"stats":{"Line":2}},{"line":110,"address":[5301708],"length":1,"stats":{"Line":1}},{"line":114,"address":[5301955,5301735,5303953,5301909],"length":1,"stats":{"Line":5}},{"line":115,"address":[5303451,5301979,5303862],"length":1,"stats":{"Line":2}},{"line":116,"address":[5303599,5303893],"length":1,"stats":{"Line":2}},{"line":119,"address":[5301997],"length":1,"stats":{"Line":2}},{"line":120,"address":[5302004],"length":1,"stats":{"Line":2}},{"line":122,"address":[5302359],"length":1,"stats":{"Line":2}},{"line":123,"address":[5302371],"length":1,"stats":{"Line":1}},{"line":127,"address":[5302407],"length":1,"stats":{"Line":1}},{"line":130,"address":[5303433,5302442,5302513,5302620,5302638],"length":1,"stats":{"Line":2}},{"line":131,"address":[5302628],"length":1,"stats":{"Line":0}},{"line":132,"address":[5302578,5302671],"length":1,"stats":{"Line":2}},{"line":134,"address":[5302678],"length":1,"stats":{"Line":1}},{"line":136,"address":[5302737,5302980,5302826,5302962],"length":1,"stats":{"Line":2}},{"line":137,"address":[5378272,5378285],"length":1,"stats":{"Line":0}},{"line":138,"address":[5302891],"length":1,"stats":{"Line":1}},{"line":140,"address":[5303005],"length":1,"stats":{"Line":1}},{"line":145,"address":[5304096],"length":1,"stats":{"Line":4}},{"line":146,"address":[5304152],"length":1,"stats":{"Line":1}},{"line":147,"address":[5304173],"length":1,"stats":{"Line":4}},{"line":148,"address":[5304189],"length":1,"stats":{"Line":1}},{"line":149,"address":[5304340,5304252],"length":1,"stats":{"Line":5}},{"line":155,"address":[5305262,5304368,5305238],"length":1,"stats":{"Line":1}},{"line":156,"address":[5304407],"length":1,"stats":{"Line":1}},{"line":157,"address":[5304417],"length":1,"stats":{"Line":4}},{"line":159,"address":[5304465,5304548,5304878,5305247],"length":1,"stats":{"Line":5}},{"line":161,"address":[5304854],"length":1,"stats":{"Line":1}},{"line":162,"address":[5304928,5305098,5304999,5305116],"length":1,"stats":{"Line":5}},{"line":164,"address":[5305106],"length":1,"stats":{"Line":0}},{"line":166,"address":[5305064,5305145],"length":1,"stats":{"Line":4}},{"line":170,"address":[5305280],"length":1,"stats":{"Line":1}},{"line":171,"address":[5305288],"length":1,"stats":{"Line":4}},{"line":175,"address":[5305312],"length":1,"stats":{"Line":1}},{"line":176,"address":[5305338],"length":1,"stats":{"Line":4}},{"line":180,"address":[5305392],"length":1,"stats":{"Line":1}},{"line":181,"address":[5305418],"length":1,"stats":{"Line":3}}],"covered":43,"coverable":46},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","benchmarking.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! Benchmarking setup for pallet-drand\nuse super::*;\n\n#[allow(unused)]\nuse crate::{pallet as pallet_drand, mock::*, Pallet as Drand, types::*};\nuse ark_ec::Group;\nuse ark_std::{ops::Mul, UniformRand};\nuse frame_benchmarking::v2::*;\nuse frame_support::BoundedVec;\nuse frame_system::RawOrigin;\nuse timelock::{curves::drand::TinyBLS381, tlock::EngineBLS};\n\n#[benchmarks]\nmod benchmarks {\n\tuse super::*;\n\tuse ark_std::test_rng;\n\n\t#[benchmark]\n\tfn try_submit_asig() {\n\t\t// we mock drand here\n\t\tlet sk = \u003cTinyBLS381 as EngineBLS\u003e::Scalar::from(1);\n\t\t// let pk = \u003cTinyBLS381 as EngineBLS\u003e::PublicKeyGroup::generator().mul(sk);\n\t\t// let mut pk_bytes = Vec::new();\n\t\t// pk.serialize_compressed(\u0026mut pk_bytes).unwrap();\n\n\t\t// let mut config = drand_quicknet_config();\n\t\t// config.public_key = BoundedVec::truncate_from(pk_bytes);\n\n\t\t// pallet_drand::BeaconConfig::\u003cT\u003e::set(Some(config));\n\n\t\tlet start = 1;\n\t\tlet num_rounds = 2;\n\n\t\tlet mut asig = crate::aggregator::zero_on_g1();\n\t\tlet mut apk = crate::verifier::zero_on_g1();\n\n\t\tfor round in start..start + num_rounds {\n\t\t\tlet q_id = crate::verifier::compute_round_on_g1(round).unwrap();\n\t\t\tapk = (apk + q_id).into();\n\t\t\tasig = (asig + (q_id.mul(sk))).into();\n\t\t}\n\n\t\tlet mut asig_bytes = Vec::new();\n\t\tasig.serialize_compressed(\u0026mut asig_bytes).unwrap();\n\t\tlet bounded_asig = OpaqueSignature::truncate_from(asig_bytes);\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\tapk.serialize_compressed(\u0026mut apk_bytes).unwrap();\n\t\tlet bounded_message_hash = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\t#[extrinsic_call]\n\t\t_(RawOrigin::None, bounded_asig.clone(), num_rounds.clone(), Some(start));\n\n\t\tassert_eq!(\n\t\t\tAggregatedSignature::\u003cT\u003e::get(),\n\t\t\tSome(Aggregate {\n\t\t\t\tsignature: bounded_asig, \n\t\t\t\tmessage_hash:  bounded_message_hash,\n\t\t\t})\n\t\t);\n\t}\n\n\timpl_benchmark_test_suite!(Drand, crate::mock::new_test_ext(), crate::mock::Test);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","bls12_381.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::{Bls12_381 as Bls12_381Opt, G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\nuse ark_ec::pairing::Pairing;\nuse ark_std::{ops::Neg, Zero};\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::{\n\tBls12_381 as Bls12_381Opt, G1Affine as G1AffineOpt, G2Affine as G2AffineOpt,\n};\n\n/// An optimized way to verify Drand pulses from quicket\n/// Instead of computing two pairings and comparing them, we instead compute a multi miller loop,\n/// and then take the final exponentiation, saving a lot of computational cost.\n///\n/// This function is also inlined as a way to optimize performance.\n///\n/// * `signature`: The signature to verify\n/// * `q`: The beacon public key\n/// * `r`: The message signed by Drand, hashed to G1\n/// * `s`: A generator\n#[inline]\npub fn fast_pairing_opt(\n\tsignature: G1AffineOpt,\n\tq: G2AffineOpt,\n\tr: G1AffineOpt,\n\ts: G2AffineOpt,\n) -\u003e bool {\n\tlet looped = Bls12_381Opt::multi_miller_loop([signature.neg(), r], [q, s]);\n\tlet exp = Bls12_381Opt::final_exponentiation(looped);\n\texp.unwrap().is_zero()\n}\n","traces":[{"line":37,"address":[5643120],"length":1,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Randomness Beacon Aggregation and Verification Pallet\n//!\n//! This pallet facilitates the aggregation and verification of randomness pulses from an external\n//! verifiable randomness beacon, such as [drand](https://drand.love)'s Quicknet. It enables\n//! runtime access to externally sourced, cryptographically secure randomness while ensuring that\n//! only properly signed pulses are accepted.\n//!\n//! ## Overview\n//!\n//! - Provides a mechanism to ingest randomness pulses from an external randomness beacon.\n//! - Aggregates and verifies pulses using the [`SignatureAggregator`] trait.\n//! - Ensures that the runtime only uses verified randomness for security-critical applications.\n//! - Stores the latest aggregated signature to enable efficient verification within the runtime.\n//!\n//! This pallet is particularly useful for use cases that require externally verifiable randomness,\n//! such as fair lotteries, gaming applications, and leader election mechanisms.\n//!\n//! ## Terminology\n//!\n//! - **Randomness Pulse**: A cryptographically signed value representing a random output from an\n//!   external randomness beacon.\n//! - **Round Number**: A sequential identifier corresponding to each randomness pulse.\n//! - **Aggregated Signature**: A combined (aggregated) cryptographic signature that ensures all\n//!   observed pulses originate from the trusted randomness beacon.\n//!\n//! ## Implementation Details\n//!\n//! The pallet relies on a [`SignatureAggregator`] implementation to aggregate and verify randomness\n//! pulses. It maintains the latest observed rounds, validates incoming pulses, and aggregates valid\n//! signatures before storing them in runtime storage. It expects a monotonically increasing\n//! sequence of beacon pulses delivered in packets of size `T::SignatureToBlockRatio`, beginning at\n//! the genesis round.\n//!\n//! To be more specific, if the randomness beacon incrementally outputs pulses A -\u003e B -\u003e C -\u003e D,\n//! the genesis round expects pulse A first, and the SignatureToBlockRatio is 2, then this pallet\n//! would first expect the 'aggregated' pulse AB = A + B, which produces both an aggregated\n//! *signature* (asig) and an aggregated *public key* (apk). Subsequently, it would expected the\n//! next value to be CD = C + D. On-chain, this results in the aggregated signature, ABCD = AB + CD,\n//! which we can use to prove we have observed all pulses between A and D.\n//!\n//! ### Storage Items\n//!\n//! - `BeaconConfig`: Stores the beacon configuration details.\n//! - `GenesisRound`: The first round number from which randomness pulses are considered valid.\n//! - `LatestRound`: Tracks the latest verified round number.\n//! - `AggregatedSignature`: Stores the latest aggregated signature for verification purposes.\n//!\n//! ## Usage\n//!\n//! This pallet is designed to securely ingest verifiable randomness into the runtime.\n//! It exposes an inherent provider that automatically processes randomness pulses included\n//! in block production.\n//!\n//! ## Interface\n//!\n//! - **Extrinsics**\n//!   - `try_submit_asig`: Submit an aggregated signature for verification. This is an unsigned\n//!     extrinsic, intended to be called from the inherent.\n//!\n//! - **Inherent Implementation**\n//!   - This pallet provides an inherent that automatically submits aggregated randomness pulses\n//!     during block execution.\n//!\n//! Run `cargo doc --package pallet-randomness-beacon --open` to view this pallet's documentation.\n\n// We make sure this pallet uses `no_std` for compiling to Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n// Re-export pallet items so that they can be accessed from the crate namespace.\npub use pallet::*;\n\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\nuse ark_serialize::CanonicalSerialize;\nuse frame_support::pallet_prelude::*;\nuse sc_consensus_randomness_beacon::types::OpaquePulse;\n\npub mod aggregator;\npub mod bls12_381;\npub mod types;\npub mod weights;\npub use weights::*;\n\nuse aggregator::{zero_on_g1, SignatureAggregator};\nuse types::*;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\n/// The buffer size required to represent an element of the signature group\nconst SERIALIZED_SIG_SIZE: usize = 48;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::ensure;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching runtime event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\t/// A type representing the weights required by the dispatchables of this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\t\t/// The beacon configuration for which this pallet is defined.\n\t\ttype BeaconConfig: Get\u003cBeaconConfiguration\u003e;\n\t\t/// something that knows how to aggregate and verify beacon pulses.\n\t\ttype SignatureAggregator: SignatureAggregator;\n\t\t/// The number of signatures per block.\n\t\ttype MaxSigsPerBlock: Get\u003cu8\u003e;\n\t}\n\n\t/// A first round number for which a pulse was observed\n\t#[pallet::storage]\n\tpub type GenesisRound\u003cT: Config\u003e = StorageValue\u003c_, RoundNumber, ValueQuery\u003e;\n\n\t/// The latest observed round\n\t#[pallet::storage]\n\tpub type LatestRound\u003cT: Config\u003e = StorageValue\u003c_, RoundNumber, ValueQuery\u003e;\n\n\t/// The aggregated signature and aggregated public key (identifier) of all observed pulses of\n\t/// randomness\n\t#[pallet::storage]\n\tpub type AggregatedSignature\u003cT: Config\u003e = StorageValue\u003c_, Aggregate, OptionQuery\u003e;\n\n\t/// Whether the asig has been updated in this block.\n\t///\n\t/// This value is updated to `true` upon successful submission of an asig by a node.\n\t/// It is then checked at the end of each block execution in the `on_finalize` hook.\n\t#[pallet::storage]\n\tpub(super) type DidUpdate\u003cT: Config\u003e = StorageValue\u003c_, bool, ValueQuery\u003e;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// The genesis round has been changed by a root address\n\t\tGenesisRoundChanged,\n\t\t/// Siganture verification succeeded for signatures associated with the given rounds.\n\t\tSignatureVerificationSuccess,\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// The input data could not be decoded or was empty\n\t\tInvalidInput,\n\t\t/// The pulse could not be verified\n\t\tVerificationFailed,\n\t\t/// The next round number is invalid (either too high or too low)\n\t\tInvalidNextRound,\n\t\t/// The network is at block 0.\n\t\tNetworkTooEarly,\n\t\t/// There must be at least one pulse provided.\n\t\tNonPositiveHeight,\n\t\t/// The genesis round is zero.\n\t\tGenesisRoundNotSet,\n\t\t/// The genesis is already set.\n\t\tGenesisRoundAlreadySet,\n\t\t/// There must be at least one signature to construct an asig\n\t\tZeroHeightProvided,\n\t\t/// There number of aggregated signatures exceeds the maximum rounds we can verify per block.\n\t\tExcessiveHeightProvided,\n\t\t/// Only one aggregated signature can be provided per block\n\t\tSignatureAlreadyVerified,\n\t}\n\n\t#[pallet::inherent]\n\timpl\u003cT: Config\u003e ProvideInherent for Pallet\u003cT\u003e {\n\t\ttype Call = Call\u003cT\u003e;\n\t\ttype Error = MakeFatalError\u003c()\u003e;\n\n\t\tconst INHERENT_IDENTIFIER: [u8; 8] =\n\t\t\tsp_consensus_randomness_beacon::inherents::INHERENT_IDENTIFIER;\n\n\t\tfn create_inherent(data: \u0026InherentData) -\u003e Option\u003cSelf::Call\u003e {\n\t\t\t// if we do not find any pulse data, then do nothing\n\t\t\tif let Ok(Some(raw_pulses)) = data.get_data::\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e(\u0026Self::INHERENT_IDENTIFIER)\n\t\t\t{\n\t\t\t\t// ignores non-deserializable messages\n\t\t\t\t// if all messages are invalid, it outputs 0 on the G1 curve (so serialization of asig always works)\n\t\t\t\tlet asig = raw_pulses\n\t\t\t\t\t.iter()\n\t\t\t\t\t.filter_map(|rp| OpaquePulse::deserialize_from_vec(rp).ok())\n\t\t\t\t\t.filter_map(|pulse| pulse.signature_point().ok())\n\t\t\t\t\t.fold(zero_on_g1(), |acc, sig| (acc + sig).into());\n\n\t\t\t\tlet mut asig_bytes = Vec::with_capacity(SERIALIZED_SIG_SIZE);\n\t\t\t\t// [SRLABS]: This error is untestable since we know the signature is correct here.\n\t\t\t\t//  Is it reasonable to use an expect?\n\t\t\t\tasig.serialize_compressed(\u0026mut asig_bytes)\n\t\t\t\t\t.expect(\"The signature is well formatted.\");\n\n\t\t\t\t// if the genesis round is not configured, then the first call sets it\n\t\t\t\tlet round = (GenesisRound::\u003cT\u003e::get() == 0)\n\t\t\t\t\t.then(|| {\n\t\t\t\t\t\t// get the round from the first pulse observed\n\t\t\t\t\t\traw_pulses.iter().find_map(|rp| {\n\t\t\t\t\t\t\tOpaquePulse::deserialize_from_vec(rp).ok().map(|p| p.round)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or(None);\n\n\t\t\t\treturn Some(Call::try_submit_asig {\n\t\t\t\t\tasig: OpaqueSignature::truncate_from(asig_bytes),\n\t\t\t\t\theight: raw_pulses.len() as RoundNumber,\n\t\t\t\t\tround,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlog::info!(\"The node provided empty pulse data to the inherent!\");\n\t\t\t}\n\n\t\t\tNone\n\t\t}\n\n\t\tfn check_inherent(call: \u0026Self::Call, _data: \u0026InherentData) -\u003e Result\u003c(), Self::Error\u003e {\n\t\t\tmatch call {\n\t\t\t\tCall::try_submit_asig { .. } =\u003e Ok(()),\n\t\t\t\t_ =\u003e unreachable!(\"other calls are not inherents\"),\n\t\t\t}\n\t\t}\n\n\t\tfn is_inherent(call: \u0026Self::Call) -\u003e bool {\n\t\t\tmatches!(call, Call::try_submit_asig { .. })\n\t\t}\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\t/// A dummy `on_initialize` to return the amount of weight that `on_finalize` requires to\n\t\t/// execute.\n\t\tfn on_initialize(_n: BlockNumberFor\u003cT\u003e) -\u003e Weight {\n\t\t\t// weight of `on_finalize`\n\t\t\tT::WeightInfo::on_finalize()\n\t\t}\n\n\t\t/// At the end of block execution, the `on_finalize` hook checks that the timestamp was\n\t\t/// updated. Upon success, it removes the boolean value from storage. If the value resolves\n\t\t/// to `false`, the pallet will panic.\n\t\t///\n\t\t/// ## Complexity\n\t\t/// - `O(1)`\n\t\tfn on_finalize(_n: BlockNumberFor\u003cT\u003e) {\n\t\t\tassert!(DidUpdate::\u003cT\u003e::take(), \"The aggregated siganture must be updated once in the block\");\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Write a set of pulses to the runtime\n\t\t///\n\t\t/// * `origin`: A None origin\n\t\t/// * `asig`: An aggregated signature\n\t\t/// * `height`: The number of sigs aggregated to construct asig\n\t\t/// * `round`: An optional genesis round number. It can only be set if the existing genesis\n\t\t///   round is 0.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(T::WeightInfo::try_submit_asig())]\n\t\tpub fn try_submit_asig(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tasig: OpaqueSignature,\n\t\t\theight: RoundNumber,\n\t\t\tround: Option\u003cRoundNumber\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_none(origin)?;\n\t\t\tensure!(\n\t\t\t\t!DidUpdate::\u003cT\u003e::exists(), \n\t\t\t\tError::\u003cT\u003e::SignatureAlreadyVerified,\n\t\t\t);\n\n\t\t\tlet config = T::BeaconConfig::get();\n\t\t\tlet mut genesis_round = GenesisRound::\u003cT\u003e::get();\n\t\t\tlet mut latest_round = LatestRound::\u003cT\u003e::get();\n\n\t\t\tensure!(height \u003e 0, Error::\u003cT\u003e::ZeroHeightProvided);\n\t\t\tensure!(\n\t\t\t\theight \u003c= T::MaxSigsPerBlock::get() as u64,\n\t\t\t\tError::\u003cT\u003e::ExcessiveHeightProvided\n\t\t\t);\n\n\t\t\tif let Some(r) = round {\n\t\t\t\t// if a round is provided and the genesis round is not set\n\t\t\t\tensure!(genesis_round == 0, Error::\u003cT\u003e::GenesisRoundAlreadySet);\n\t\t\t\tGenesisRound::\u003cT\u003e::set(r);\n\t\t\t\tgenesis_round = r;\n\t\t\t\tlatest_round = genesis_round;\n\t\t\t} else {\n\t\t\t\t//  if the genesis round is not set and a round is not provided\n\t\t\t\tensure!(\n\t\t\t\t\tGenesisRound::\u003cT\u003e::get() \u003e 0,\n\t\t\t\t\tError::\u003cT\u003e::GenesisRoundNotSet\n\t\t\t\t);\n\t\t\t}\n\t\t\t// aggregate old asig/apk with the new one and verify the aggregation\n\t\t\t// Q: do we care about the entire linear history of message hashes?\n\t\t\t// https://github.com/ideal-lab5/idn-sdk/issues/119\n\t\t\tlet aggr = T::SignatureAggregator::aggregate_and_verify(\n\t\t\t\tconfig.public_key,\n\t\t\t\tasig,\n\t\t\t\tlatest_round,\n\t\t\t\theight,\n\t\t\t\tAggregatedSignature::\u003cT\u003e::get(),\n\t\t\t)\n\t\t\t.map_err(|_| Error::\u003cT\u003e::VerificationFailed)?;\n\n\t\t\tLatestRound::\u003cT\u003e::set(latest_round.saturating_add(height));\n\t\t\tAggregatedSignature::\u003cT\u003e::set(Some(aggr));\n\t\t\tDidUpdate::\u003cT\u003e::put(true);\n\n\t\t\tSelf::deposit_event(Event::\u003cT\u003e::SignatureVerificationSuccess);\n\n\t\t\tOk(())\n\t\t}\n\t}\n}\n","traces":[{"line":140,"address":[5273749,5273648,5274365,5274352,5274498,5274432],"length":1,"stats":{"Line":4}},{"line":144,"address":[5274592,5274512,5273808,5273909,5274658,5274525],"length":1,"stats":{"Line":4}},{"line":149,"address":[5273968,5274685,5274752,5274672,5274818,5274088],"length":1,"stats":{"Line":4}},{"line":156,"address":[5274832,5274300,5274144,5274845,5274912,5274978],"length":1,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":324,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}}],"covered":51,"coverable":62},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","mock.rs"],"content":"use crate as pallet_drand_bridge;\nuse crate::{aggregator::QuicknetAggregator, *};\nuse frame_support::{\n\tderive_impl, parameter_types,\n\ttraits::{ConstU16, ConstU64, ConstU8},\n};\nuse sp_core::{sr25519::Signature, H256};\nuse sp_keystore::{testing::MemoryKeystore, KeystoreExt};\nuse sp_runtime::{\n\ttraits::{BlakeTwo256, IdentityLookup, Verify},\n\tBuildStorage,\n};\n\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n\tpub enum Test\n\t{\n\t\tSystem: frame_system,\n\t\tDrand: pallet_drand_bridge,\n\t}\n);\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Nonce = u64;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = sp_core::sr25519::Public;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Block = Block;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockHashCount = ConstU64\u003c250\u003e;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = ();\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = ConstU16\u003c42\u003e;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Test {\n\ttype Public = \u003cSignature as Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nparameter_types! {\n\tpub QuicknetBeaconConfig: BeaconConfiguration = drand_quicknet_config();\n}\n\nimpl pallet_drand_bridge::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = ();\n\ttype BeaconConfig = QuicknetBeaconConfig;\n\ttype SignatureAggregator = QuicknetAggregator;\n\ttype MaxSigsPerBlock = ConstU8\u003c2\u003e;\n}\n\n// Build genesis storage according to the mock runtime.\npub fn new_test_ext() -\u003e sp_io::TestExternalities {\n\tlet t = frame_system::GenesisConfig::\u003cTest\u003e::default().build_storage().unwrap();\n\tlet mut ext = sp_io::TestExternalities::new(t);\n\tlet keystore = MemoryKeystore::new();\n\text.register_extension(KeystoreExt::new(keystore.clone()));\n\n\text\n}\n\npub(crate) fn drand_quicknet_config() -\u003e BeaconConfiguration {\n\tbuild_beacon_configuration(\n\t\t\"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a\",\n\t\t3,\n\t\t1692803367,\n\t\t\"52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971\",\n\t\t\"f477d5c89f21a17c863a7f937c6a6d15859414d2be09cd448d4279af331c5d3e\",\n\t\t\"bls-unchained-g1-rfc9380\",\n\t\t\"quicknet\"\n\t)\n}\n\n/// build a beacon configuration struct\nfn build_beacon_configuration(\n\tpk_hex: \u0026str,\n\tperiod: u32,\n\tgenesis_time: u32,\n\thash_hex: \u0026str,\n\tgroup_hash_hex: \u0026str,\n\tscheme_id: \u0026str,\n\tbeacon_id: \u0026str,\n) -\u003e BeaconConfiguration {\n\tlet pk = hex::decode(pk_hex).expect(\"Valid hex\");\n\tlet hash = hex::decode(hash_hex).expect(\"Valid hex\");\n\tlet group_hash = hex::decode(group_hash_hex).expect(\"Valid hex\");\n\n\tlet public_key: OpaquePublicKey = BoundedVec::try_from(pk).expect(\"Public key within bounds\");\n\tlet hash: OpaqueHash = BoundedVec::try_from(hash).expect(\"Hash within bounds\");\n\tlet group_hash: OpaqueHash =\n\t\tBoundedVec::try_from(group_hash).expect(\"Group hash within bounds\");\n\tlet scheme_id: OpaqueHash =\n\t\tBoundedVec::try_from(scheme_id.as_bytes().to_vec()).expect(\"Scheme ID within bounds\");\n\tlet beacon_id: OpaqueHash =\n\t\tBoundedVec::try_from(beacon_id.as_bytes().to_vec()).expect(\"Scheme ID within bounds\");\n\n\tlet metadata = Metadata { beacon_id };\n\n\tBeaconConfiguration { public_key, period, genesis_time, hash, group_hash, scheme_id, metadata }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","tests.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \nuse crate::{\n\taggregator::test::*, mock::*, AggregatedSignature, Call, Error, GenesisRound, LatestRound,\n\tweights::*,\n};\nuse frame_support::{assert_noop, assert_ok, inherent::ProvideInherent, traits::OnFinalize};\n\n#[test]\nfn can_construct_pallet_and_set_genesis_params() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet actual_genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(0, actual_genesis_round);\n\t});\n}\n\n#[test]\nfn can_fail_write_pulse_when_genesis_round_zero_and_none_provided() {\n\tlet (sig, _pk) = get(vec![PULSE1000]);\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), sig, 1, None),\n\t\t\tError::\u003cTest\u003e::GenesisRoundNotSet,\n\t\t);\n\t});\n}\n\n#[test]\nfn can_submit_min_required_valid_pulses_on_genesis() {\n\tlet round = 1000u64;\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 2, Some(round)));\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig, aggr.signature);\n\t\tassert_eq!(apk, aggr.message_hash);\n\t});\n}\n\n#[test]\nfn can_fail_when_sig_height_is_0() {\n\tlet round = 1000u64;\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 0, Some(round)),\n\t\t\tError::\u003cTest\u003e::ZeroHeightProvided\n\t\t);\n\t});\n}\n\n#[test]\nfn can_fail_when_sig_height_is_exceeds_max() {\n\tlet round = 1000u64;\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 10, Some(round)),\n\t\t\tError::\u003cTest\u003e::ExcessiveHeightProvided\n\t\t);\n\t});\n}\n\n#[test]\nfn can_submit_valid_sigs_in_sequence() {\n\tlet round1 = 1000u64;\n\tlet round2 = 1004u64;\n\n\tlet (asig1, _apk1) = get(vec![PULSE1000, PULSE1001]);\n\tlet (asig2, _apk2) = get(vec![PULSE1002, PULSE1003]);\n\t// the aggregated values\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001, PULSE1002, PULSE1003]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\n\t\tDrand::on_finalize(1);\n\t\tSystem::set_block_number(2);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig2.clone(), 2, None));\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round1, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig, aggr.signature);\n\t\tassert_eq!(apk, aggr.message_hash);\n\n\t\tlet actual_latest = LatestRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round2, actual_latest);\n\t});\n}\n\n#[test]\nfn can_fail_to_calls_to_try_submit_asig_per_block() {\n\tlet round1 = 1000u64;\n\tlet round2 = 1004u64;\n\n\tlet (asig1, _apk1) = get(vec![PULSE1000, PULSE1001]);\n\tlet (asig2, _apk2) = get(vec![PULSE1002, PULSE1003]);\n\t// the aggregated values\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001, PULSE1002, PULSE1003]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, None),\n\t\t\tError::\u003cTest\u003e::SignatureAlreadyVerified,\n\t\t);\n\t});\n}\n\n#[test]\nfn can_fail_to_submit_invalid_sigs_in_sequence() {\n\tlet round1 = 1000u64;\n\n\tlet (asig1, apk1) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\n\t\tDrand::on_finalize(1);\n\t\tSystem::set_block_number(2);\n\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, None),\n\t\t\tError::\u003cTest\u003e::VerificationFailed,\n\t\t);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)),\n\t\t\tError::\u003cTest\u003e::GenesisRoundAlreadySet,\n\t\t);\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round1, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig1, aggr.signature);\n\t\tassert_eq!(apk1, aggr.message_hash);\n\n\t\tlet actual_latest = LatestRound::\u003cTest\u003e::get();\n\t\tassert_eq!(1002, actual_latest);\n\t});\n}\n\n/*\n\tInherents Tests\n*/\nuse sc_consensus_randomness_beacon::types::OpaquePulse;\nuse sp_consensus_randomness_beacon::inherents::INHERENT_IDENTIFIER;\nuse sp_inherents::InherentData;\n\n#[test]\nfn can_create_inherent_and_set_genesis_round() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(Call::try_submit_asig { asig: actual_asig, height, round: Some(1000) }) = result\n\t\t{\n\t\t\tassert_eq!(height, 2, \"The asig height should equal the number of pulses.\");\n\t\t\tassert_eq!(actual_asig, asig, \"The output should match the aggregated input.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n\n#[test]\nfn can_create_inherent_when_genesis_round_is_set() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tGenesisRound::\u003cTest\u003e::set(999);\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(Call::try_submit_asig { asig: actual_asig, height, round: None }) = result {\n\t\t\tassert_eq!(height, 2, \"The asig height should equal the number of pulses.\");\n\t\t\tassert_eq!(actual_asig, asig, \"The output should match the aggregated input.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n\n#[test]\nfn can_not_create_inherent_when_data_is_unavailable() {\n\tlet inherent_data = InherentData::new();\n\tnew_test_ext().execute_with(|| {\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tassert!(result.is_none());\n\t});\n}\n\n#[test]\nfn can_check_inherent() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tGenesisRound::\u003cTest\u003e::set(999);\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(call) = result {\n\t\t\tassert!(Drand::is_inherent(\u0026call), \"The inherent should be allowed.\");\n\t\t\tlet res = Drand::check_inherent(\u0026call, \u0026inherent_data);\n\t\t\tassert!(res.is_ok(), \"The inherent should be allowed.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","types.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse codec::{Decode, Encode};\nuse frame_support::pallet_prelude::*;\nuse serde::{Deserialize, Serialize};\n\n/// Represents an opaque public key used in drand's quicknet\npub type OpaquePublicKey = BoundedVec\u003cu8, ConstU32\u003c96\u003e\u003e;\n/// Represents an element of the signature group\npub type OpaqueSignature = BoundedVec\u003cu8, ConstU32\u003c48\u003e\u003e;\n/// an opaque bounded storage type for 64 bit hashes\npub type OpaqueHash = BoundedVec\u003cu8, ConstU32\u003c64\u003e\u003e;\n/// the round number to track rounds of the beacon\npub type RoundNumber = u64;\n\n/// Represents an aggregated signature and aggregated public key pair\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\t// Serialize,\n\t// Deserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct Aggregate {\n\t/// A signature (e.g. output from the randomness beacon) in G1\n\tpub signature: OpaqueSignature,\n\t/// The message signed by the signature, hashed to G1\n\tpub message_hash: OpaqueSignature,\n}\n\n/// A drand chain configuration\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\tSerialize,\n\tDeserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct BeaconConfiguration {\n\tpub public_key: OpaquePublicKey,\n\tpub period: u32,\n\tpub genesis_time: u32,\n\tpub hash: OpaqueHash,\n\tpub group_hash: OpaqueHash,\n\tpub scheme_id: OpaqueHash,\n\tpub metadata: Metadata,\n}\n\n/// metadata for the drand beacon configuration\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\tSerialize,\n\tDeserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct Metadata {\n\tpub beacon_id: OpaqueHash,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","weights.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO: weights generation and benchmarking: https://github.com/ideal-lab5/idn-sdk/issues/56\nuse frame_support::weights::Weight;\n\npub trait WeightInfo {\n\tfn on_finalize() -\u003e Weight;\n\tfn try_submit_asig() -\u003e Weight;\n}\n\nimpl WeightInfo for () {\n\tfn on_finalize() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn try_submit_asig() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n}\n","traces":[{"line":26,"address":[5384016],"length":1,"stats":{"Line":0}},{"line":27,"address":[5384017],"length":1,"stats":{"Line":0}},{"line":29,"address":[5384048],"length":1,"stats":{"Line":0}},{"line":30,"address":[5384049],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","driemworks","ideal","idn-sdk","primitives","consensus","randomness-beacon","src","inherents.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse alloc::vec::Vec;\nuse sp_inherents::{Error, InherentData, InherentIdentifier};\n\npub const INHERENT_IDENTIFIER: InherentIdentifier = *b\"rngpulse\";\n\npub type InherentType = Vec\u003cVec\u003cu8\u003e\u003e;\n\n#[cfg(feature = \"std\")]\npub struct InherentDataProvider {\n\tdata: InherentType,\n}\n\n#[cfg(feature = \"std\")]\nimpl InherentDataProvider {\n\tpub fn new(data: InherentType) -\u003e Self {\n\t\tSelf { data }\n\t}\n}\n\n#[cfg(feature = \"std\")]\nimpl core::ops::Deref for InherentDataProvider {\n\ttype Target = InherentType;\n\n\tfn deref(\u0026self) -\u003e \u0026Self::Target {\n\t\t\u0026self.data\n\t}\n}\n\n#[cfg(feature = \"std\")]\n#[async_trait::async_trait]\nimpl sp_inherents::InherentDataProvider for InherentDataProvider {\n\tasync fn provide_inherent_data(\u0026self, inherent_data: \u0026mut InherentData) -\u003e Result\u003c(), Error\u003e {\n\t\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026self.data)\n\t}\n\n\tasync fn try_handle_error(\n\t\t\u0026self,\n\t\t_: \u0026InherentIdentifier,\n\t\t_: \u0026[u8],\n\t) -\u003e Option\u003cResult\u003c(), Error\u003e\u003e {\n\t\tNone\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\n\tuse super::{InherentDataProvider as RandInherentDataProvider, *};\n\tuse core::ops::Deref;\n\tuse sp_inherents::InherentDataProvider;\n\n\t#[test]\n\tpub fn can_construct_inherent_data_provider() {\n\t\tlet data: InherentType = vec![vec![1]];\n\t\tlet provider = RandInherentDataProvider::new(data.clone());\n\t\tassert_eq!(\u0026data, provider.deref())\n\t}\n\n\t#[tokio::test]\n\tpub async fn can_provide_inherent_data() {\n\t\tlet extra_data = vec![vec![1]];\n\t\tlet mut inherent_data = InherentData::new();\n\t\tlet provider = RandInherentDataProvider::new(extra_data.clone());\n\n\t\tlet res = provider.provide_inherent_data(\u0026mut inherent_data).await;\n\t\tassert!(res.is_ok());\n\n\t\tlet data = inherent_data.get_data::\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e(\u0026INHERENT_IDENTIFIER).unwrap().unwrap();\n\t\tassert_eq!(extra_data, data)\n\t}\n\n\t#[tokio::test]\n\tpub async fn try_handle_error_returns_none() {\n\t\tlet extra_data = vec![vec![1]];\n\t\tlet mut inherent_data = InherentData::new();\n\t\tlet provider = RandInherentDataProvider::new(extra_data.clone());\n\t\tlet res = provider.try_handle_error(\u0026[1u8; 8], \u0026vec![1]).await;\n\t\tassert!(res.is_none());\n\t}\n}\n","traces":[{"line":31,"address":[2211552],"length":1,"stats":{"Line":3}},{"line":40,"address":[2211584],"length":1,"stats":{"Line":1}},{"line":48,"address":[2179294,2179264,2179505,2179656,2179377],"length":1,"stats":{"Line":3}},{"line":49,"address":[2179565],"length":1,"stats":{"Line":1}},{"line":57,"address":[2179997],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","driemworks","ideal","idn-sdk","primitives","consensus","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate alloc;\n\npub mod inherents;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","support","traits","src","lib.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # IDN Traits\n\npub mod rand {\n\n\t/// A trait for dispatching random data.\n\tpub trait Dispatcher\u003cR, O\u003e {\n\t\t/// Dispatch the given random data.\n\t\tfn dispatch(rnd: R) -\u003e O;\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","support","traits","src","rand_consumer.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Randomness consumer trait\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","gossipsub.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Gossipsub Network Subscription Client\n//!\n//! The `GossipsubNetwork` is a libp2p node designed to ingest well-formatted messages\n//! from a gossipsub topic. The implemention is intended to be used with\n//! the Drand beacon gossipsub topic, to which `Pulse` messages are published as protobuf messages.\n//!\n//! ## Overview\n//!\n//! - runs a libp2p node and handles peer connections\n//! - subscribes to a gossipsub topic and writes well-formed messages to a [`SharedState`]\n//!\n//! ## Examples\n//!\n//! ``` no_run\n//! use sc_consensus_randomness_beacon::gossipsub::GossipsubNetwork;\n//! use sc_consensus_randomness_beacon::types::*;\n//! use futures::StreamExt;\n//! use libp2p::{\n//! \t\tgossipsub,\n//! \t\tgossipsub::{\n//! \t\t\tBehaviour as GossipsubBehaviour, Config as GossipsubConfig, IdentTopic, MessageAuthenticity,\n//! \t\t},\n//! \t\tidentity::Keypair,\n//! \t\tswarm::{Swarm, SwarmEvent},\n//! \t\tMultiaddr, SwarmBuilder,\n//! };\n//! use sc_utils::mpsc::tracing_unbounded;\n//! use prost::Message;\n//! use std::sync::{Arc, Mutex};\n//!\n//! let topic_str: \u0026str =\n//! \t\"/drand/pubsub/v0.0.0/52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971\";\n//! let maddr1: Multiaddr =\n//! \t\"/ip4/184.72.27.233/tcp/44544/p2p/12D3KooWBhAkxEn3XE7QanogjGrhyKBMC5GeM3JUTqz54HqS6VHG\"\n//! \t\t.parse()\n//! \t\t.expect(\"The string is a well-formatted multiaddress. qed.\");\n//! let maddr2: Multiaddr =\n//! \t\"/ip4/54.193.191.250/tcp/44544/p2p/12D3KooWQqDi3D3KLfDjWATQUUE4o5aSshwBFi9JM36wqEPMPD5y\"\n//! \t\t.parse()\n//! \t\t.expect(\"The string is a well-formatted multiaddress. qed.\");\n//! let local_identity: Keypair = Keypair::generate_ed25519();\n//! let (tx, rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n//! let gossipsub_config = GossipsubConfig::default();\n//! let mut gossipsub = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None).unwrap();\n//! tokio::spawn(async move {\n//! \tif let Err(e) = gossipsub.run(topic_str, vec![maddr1, maddr2]).await {\n//! \t\tlog::error!(\"Failed to run gossipsub network: {:?}\", e);\n//! \t}\n//! });\n//! ```\nuse crate::types::*;\nuse futures::StreamExt;\nuse libp2p::{\n\tgossipsub,\n\tgossipsub::{\n\t\tBehaviour as GossipsubBehaviour, Config as GossipsubConfig, IdentTopic, MessageAuthenticity,\n\t},\n\tidentity::Keypair,\n\tswarm::{Swarm, SwarmEvent},\n\tMultiaddr, SwarmBuilder,\n};\nuse prost::Message;\nuse sc_utils::mpsc::TracingUnboundedSender;\n\n/// The default address instructing libp2p to choose a random open port on the local machine\nconst RAND_LISTEN_ADDR: \u0026str = \"/ip4/0.0.0.0/tcp/0\";\n\n/// Various errors that can be encountered\n#[derive(Debug, Clone, PartialEq)]\npub enum Error {\n\t/// The signature buffer expects 48 bytes, but more were provided\n\tSignatureBufferCapacityExceeded,\n\t/// The message did not follow the expected format\n\tUnexpectedMessageFormat,\n\t/// The provided gossipsub behaviour is invalid\n\tInvalidGossipsubNetworkBehaviour,\n\t/// The multiaddress is invalid (likely the protocol is not supported)\n\tInvalidMultiaddress { who: Multiaddr },\n\t/// The swarm could not listen on the given port\n\tSwarmListenFailure,\n}\n\n/// A gossipsub network with any behaviour and shared state\npub struct GossipsubNetwork {\n\t/// The behaviour config for the swam\n\tswarm: Swarm\u003cGossipsubBehaviour\u003e,\n\t/// The mpsc channel sender\n\tsender: TracingUnboundedSender\u003cOpaquePulse\u003e,\n\t/// The number of peers the node is connected to\n\tpub(crate) connected_peers: u8,\n}\n\nimpl GossipsubNetwork {\n\t/// Build a new gossipsub network.\n\t/// It constructs a libp2p [swarm](https://docs.rs/libp2p/latest/libp2p/struct.Swarm.html)\n\t/// where message authenticity requires signatures from the provided key and with a tcp-based\n\t/// transport layer.\n\t///\n\t/// * `key`: A libp2p keypair\n\t/// * `gossipsub_config`: A gossipsub config\n\t/// * `sender`: A `TracingUnboundedSender` that can send an `OpaquePulse`\n\t/// * `listen_addr`: An optional address to listen on. If None, a random local port is assigned.\n\tpub fn new(\n\t\tkey: \u0026Keypair,\n\t\tgossipsub_config: GossipsubConfig,\n\t\tsender: TracingUnboundedSender\u003cOpaquePulse\u003e,\n\t\tlisten_addr: Option\u003c\u0026Multiaddr\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet message_authenticity = MessageAuthenticity::Signed(key.clone());\n\t\tlet gossipsub = GossipsubBehaviour::new(message_authenticity, gossipsub_config)\n\t\t\t.map_err(|_| Error::InvalidGossipsubNetworkBehaviour)?;\n\t\t// setup a libp2p swarm with tcp transport, using noise protocol for encryption\n\t\t// and yamux for multiplexing\n\t\tlet mut swarm = SwarmBuilder::with_existing_identity(key.clone())\n\t\t\t.with_tokio()\n\t\t\t.with_tcp(\n\t\t\t\tlibp2p::tcp::Config::default(),\n\t\t\t\tlibp2p::noise::Config::new,\n\t\t\t\tlibp2p::yamux::Config::default,\n\t\t\t)\n\t\t\t.expect(\"The TCP config is correct.\")\n\t\t\t.with_behaviour(|_| gossipsub)\n\t\t\t.expect(\"The behaviour is well defined.\")\n\t\t\t.build();\n\n\t\t// fallback to a randomly assigned open port if one was not provided\n\t\tlet fallback = \u0026RAND_LISTEN_ADDR.parse().expect(\"The multiaddress is well-formatted;QED.\");\n\t\tlet listen_addr = listen_addr.unwrap_or(fallback);\n\n\t\tswarm.listen_on(listen_addr.clone()).map_err(|_| Error::SwarmListenFailure)?;\n\n\t\tOk(Self { swarm, sender, connected_peers: 0 })\n\t}\n\n\t/// Start the gossipsub network.\n\t/// It waits for peers to establish a connection, then writes well-formed messages received\n\t/// from the gossipsub topic to the shared state.\n\t///\n\t/// * `topic_str`: The gossipsub topic to subscribe to.\n\t/// * `peers`: A list of peers to dial.\n\tpub async fn run(\u0026mut self, topic_str: \u0026str, peers: Vec\u003cMultiaddr\u003e) -\u003e Result\u003c(), Error\u003e {\n\t\tif !peers.is_empty() {\n\t\t\tfor peer in \u0026peers {\n\t\t\t\tself.swarm.dial((*peer).clone()).map_err(|_| {\n\t\t\t\t\treturn Error::InvalidMultiaddress { who: (*peer).clone() };\n\t\t\t\t})?;\n\t\t\t}\n\t\t\tself.wait_for_peers(peers.len()).await;\n\t\t}\n\n\t\tself.subscribe(topic_str).await\n\t}\n\n\t/// Executes until at least `target_count` ConnectionEstablished events\n\t/// have been observed.\n\t/// * `target_count`: The number of connection established events to observe until it terminates\n\tasync fn wait_for_peers(\u0026mut self, target_count: usize) {\n\t\tlet mut connected_peers = 0;\n\t\twhile connected_peers \u003c target_count {\n\t\t\tif let Some(SwarmEvent::ConnectionEstablished { .. }) = self.swarm.next().await {\n\t\t\t\tconnected_peers += 1;\n\t\t\t}\n\t\t}\n\t\tself.connected_peers = connected_peers as u8;\n\t}\n\n\t/// Create a subscription to a gossipsub topic.\n\t/// It writes new messages to the SharedState whenever they are decodable as Pulses\n\t/// and ignores and messages it cannot understand.\n\t///\n\t/// * `topic_str`: The gossipsub topic to subscribe to.\n\tasync fn subscribe(\u0026mut self, topic_str: \u0026str) -\u003e Result\u003c(), Error\u003e {\n\t\tlet topic = IdentTopic::new(topic_str);\n\t\t// *SRLabs: The error can never be encountered\n\t\t// Q: Can we use an expect, or is this unsafe?\n\t\t// Ref: https://docs.rs/libpp-gossipsub/0.48.0/src/libp2p_gossipsub/behaviour.rs.html#532\n\t\t// The error can only occur if the subscription filter rejects it, but we specify no filter.\n\t\tself.swarm\n\t\t\t.behaviour_mut()\n\t\t\t.subscribe(\u0026topic)\n\t\t\t.expect(\"The libp2p gossipsub behavior has no subscription filter.\");\n\n\t\tloop {\n\t\t\tmatch self.swarm.next().await {\n\t\t\t\tSome(SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. })) =\u003e {\n\t\t\t\t\tmatch try_handle_pulse(\u0026message.data) {\n\t\t\t\t\t\tOk(pulse) =\u003e {\n\t\t\t\t\t\t\tself.sender.unbounded_send(pulse.clone()).unwrap();\n\t\t\t\t\t\t},\n\t\t\t\t\t\tErr(_) =\u003e {\n\t\t\t\t\t\t\t// handle non-decodable messages: https://github.com/ideal-lab5/idn-sdk/issues/60\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t_ =\u003e {\n\t\t\t\t\t// ignore all other events\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n}\n\npub(crate) fn try_handle_pulse(data: \u0026[u8]) -\u003e Result\u003cOpaquePulse, Error\u003e {\n\tlet pulse = Pulse::decode(data).map_err(|_| Error::UnexpectedMessageFormat)?;\n\tlet pulse: OpaquePulse =\n\t\tpulse.try_into().map_err(|_| Error::SignatureBufferCapacityExceeded)?;\n\n\tOk(pulse)\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\tuse sc_utils::mpsc::{tracing_unbounded, TracingUnboundedReceiver};\n\tuse tokio::time::{sleep, Duration};\n\n\t#[test]\n\tfn can_convert_valid_data_to_opaque_pulse() {\n\t\tlet pulse = Pulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: [\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230, 117,\n\t\t\t]\n\t\t\t.to_vec(),\n\t\t};\n\t\tlet opaque: OpaquePulse = pulse.clone().try_into().unwrap();\n\t\tlet mut data = Vec::new();\n\t\tpulse.encode(\u0026mut data).unwrap();\n\n\t\tlet actual_opaque = try_handle_pulse(\u0026data).unwrap();\n\t\tassert_eq!(opaque, actual_opaque, \"The output should match the input\");\n\t}\n\n\t#[test]\n\tfn can_fail_when_data_not_decodable_to_pulse() {\n\t\tlet res = try_handle_pulse(\u0026[1; 32]);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(\n\t\t\tres,\n\t\t\tErr(Error::UnexpectedMessageFormat),\n\t\t\t\"There should be an `UnexpectedMessageFormat` error.\"\n\t\t);\n\t}\n\n\t#[test]\n\tfn can_fail_when_pulse_signature_exceeds_buffer() {\n\t\tlet pulse = Pulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: [\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t]\n\t\t\t.to_vec(),\n\t\t};\n\n\t\tlet expected_error = Error::SignatureBufferCapacityExceeded;\n\n\t\tlet mut data = Vec::new();\n\t\tpulse.encode(\u0026mut data).unwrap();\n\n\t\tlet res = try_handle_pulse(\u0026data);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(\n\t\t\tres,\n\t\t\tErr(expected_error),\n\t\t\t\"There should be an `SignatureBufferCapacityExceeded` error.\"\n\t\t);\n\t}\n\n\tfn build_node() -\u003e (GossipsubNetwork, TracingUnboundedReceiver\u003cOpaquePulse\u003e) {\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\t(GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None).unwrap(), rx)\n\t}\n\n\t#[tokio::test]\n\tasync fn can_not_build_node_with_invalid_gossipsub_behavior() {\n\t\t// supply a signing key but set anon validation, an invalid config\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = libp2p::gossipsub::ConfigBuilder::default()\n\t\t\t.validation_mode(libp2p::gossipsub::ValidationMode::Anonymous)\n\t\t\t.build()\n\t\t\t.unwrap();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet res = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, None);\n\t\tassert!(res.is_err());\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_new_node() {\n\t\tlet (node, _rx) = build_node();\n\t\tassert!(node.connected_peers == 0, \"There should be no connected peers.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_new_node_with_listen_addr() {\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet listen_addr: Multiaddr = \"/ip4/0.0.0.0/tcp/4001\".parse().unwrap();\n\t\tlet node = GossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, Some(\u0026listen_addr))\n\t\t\t.unwrap();\n\t\tassert!(node.connected_peers == 0, \"There should be no connected peers.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_node_and_run_without_peers() {\n\t\tlet topic_str = \"test\";\n\t\tlet (mut node, _rx) = build_node();\n\n\t\tlet mut is_err: bool = false;\n\n\t\ttokio::spawn(async move {\n\t\t\tif let Err(_e) = node.run(topic_str, vec![]).await {\n\t\t\t\tis_err = true;\n\t\t\t}\n\t\t});\n\n\t\tsleep(Duration::from_secs(1)).await;\n\n\t\tassert!(!is_err, \"There should be no errors.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_build_node_and_fail_with_random_peers() {\n\t\tlet topic_str = \"test\";\n\t\tlet (mut node, _rx) = build_node();\n\n\t\tlet fake_peer: Multiaddr = Multiaddr::empty().with_p2p(libp2p::PeerId::random()).unwrap();\n\n\t\tlet mut is_err: bool = false;\n\n\t\ttokio::spawn(async move {\n\t\t\tif let Err(_e) = node.run(topic_str, vec![fake_peer]).await {\n\t\t\t\tis_err = true;\n\t\t\t}\n\t\t});\n\n\t\tsleep(Duration::from_secs(2)).await;\n\n\t\tassert!(!is_err, \"There should not be an error.\");\n\t}\n\n\t#[tokio::test]\n\tasync fn can_fail_when_bad_listen_addr_provided() {\n\t\tlet fake_listen_addr: Multiaddr =\n\t\t\t\"/ip4/127.0.0.2/tcp/1010/p2p/12D3KooWBhAkxEn3XE7QanogjGrhyKBMC5GeM3JUTqz54HqS6VHG\"\n\t\t\t\t.parse()\n\t\t\t\t.unwrap();\n\n\t\tlet local_identity: Keypair = Keypair::generate_ed25519();\n\t\tlet gossipsub_config = GossipsubConfig::default();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet res =\n\t\t\tGossipsubNetwork::new(\u0026local_identity, gossipsub_config, tx, Some(\u0026fake_listen_addr));\n\t\tassert!(res.is_err());\n\t\tassert!(matches!(res, Err(Error::SwarmListenFailure)), \"Expected SwarmListenFailure error\");\n\t}\n\n\t#[tokio::test]\n\tasync fn test_gossipsub_network_listen_failure() {\n\t\tlet key = Keypair::generate_ed25519();\n\t\tlet (tx, _rx) = tracing_unbounded(\"drand-notification-channel\", 100000);\n\t\tlet config = GossipsubConfig::default();\n\t\tlet invalid_addr: Multiaddr = Multiaddr::empty();\n\n\t\tlet result = GossipsubNetwork::new(\u0026key, config, tx, Some(\u0026invalid_addr));\n\t\tassert!(result.is_err(), \"Expected failure due to invalid listen address\");\n\t}\n}\n","traces":[{"line":119,"address":[9105198,9105325,9103456],"length":1,"stats":{"Line":3}},{"line":125,"address":[5190591,5190479],"length":1,"stats":{"Line":5}},{"line":126,"address":[5192121,5190651,5190920],"length":1,"stats":{"Line":4}},{"line":127,"address":[5190888],"length":1,"stats":{"Line":3}},{"line":130,"address":[5190978,5190873,5191147,5191253,5191100],"length":1,"stats":{"Line":7}},{"line":133,"address":[5191040],"length":1,"stats":{"Line":2}},{"line":138,"address":[5191189],"length":1,"stats":{"Line":3}},{"line":143,"address":[5191405,5191333],"length":1,"stats":{"Line":3}},{"line":144,"address":[5191539,5191478],"length":1,"stats":{"Line":3}},{"line":146,"address":[5191918,5191547],"length":1,"stats":{"Line":5}},{"line":148,"address":[5191679],"length":1,"stats":{"Line":2}},{"line":157,"address":[3153089,3153204,3153485,3152191,3152342,3152160],"length":1,"stats":{"Line":4}},{"line":158,"address":[3152461,3152316],"length":1,"stats":{"Line":2}},{"line":159,"address":[3152979,3152556,3152684,3152467],"length":1,"stats":{"Line":4}},{"line":160,"address":[3152863,3153016,3153776,3153884,3152705],"length":1,"stats":{"Line":2}},{"line":161,"address":[3153846,3153789],"length":1,"stats":{"Line":0}},{"line":164,"address":[3153236,3152372,3152755,3152644],"length":1,"stats":{"Line":4}},{"line":167,"address":[3152502,3153494,3152393,3153421],"length":1,"stats":{"Line":4}},{"line":173,"address":[5192285,5192272],"length":1,"stats":{"Line":4}},{"line":174,"address":[3154014],"length":1,"stats":{"Line":1}},{"line":175,"address":[3154060,3154027],"length":1,"stats":{"Line":2}},{"line":176,"address":[3154551,3154121,3154194,3154050,3154431],"length":1,"stats":{"Line":4}},{"line":177,"address":[3154392,3154433],"length":1,"stats":{"Line":0}},{"line":180,"address":[3154499],"length":1,"stats":{"Line":0}},{"line":188,"address":[5192304,5192322],"length":1,"stats":{"Line":4}},{"line":189,"address":[3154729],"length":1,"stats":{"Line":1}},{"line":194,"address":[3154818,3154896],"length":1,"stats":{"Line":2}},{"line":196,"address":[3154882],"length":1,"stats":{"Line":1}},{"line":199,"address":[3156145],"length":1,"stats":{"Line":1}},{"line":200,"address":[3154761,3155040,3154976,3155283,3154936,3156340],"length":1,"stats":{"Line":5}},{"line":201,"address":[3155318],"length":1,"stats":{"Line":0}},{"line":202,"address":[3155447,3155356],"length":1,"stats":{"Line":0}},{"line":203,"address":[3155465],"length":1,"stats":{"Line":0}},{"line":204,"address":[3155862,3155673,3155529],"length":1,"stats":{"Line":0}},{"line":219,"address":[5192352,5192878,5192903],"length":1,"stats":{"Line":2}},{"line":220,"address":[3156393,3156384],"length":1,"stats":{"Line":5}},{"line":221,"address":[3156436,3156432],"length":1,"stats":{"Line":6}},{"line":224,"address":[5192760],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":38},{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nextern crate alloc;\n\npub mod gossipsub;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","client","consensus","randomness-beacon","src","types.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse alloc::{\n\tformat,\n\tstring::{String, ToString},\n\tvec::Vec,\n};\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::G1Affine as G1AffineOpt;\n\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::G1Affine as G1AffineOpt;\n\nuse ark_serialize::CanonicalDeserialize;\n\n/// A `pulse` represents the output from a verifiable randomness beacon, specifically an 'unchained'\n/// one\n#[derive(Clone, PartialEq, ::prost::Message, Serialize, Deserialize)]\npub struct Pulse {\n\t/// The round of the protocol when the signature was computed\n\t#[prost(uint64, tag = \"1\")]\n\tpub round: u64,\n\t/// The interpolated threshold BLS sigs\n\t#[prost(bytes = \"vec\", tag = \"2\")]\n\tpub signature: ::prost::alloc::vec::Vec\u003cu8\u003e,\n}\n\n/// This struct is used to encode pulses in the runtime, where we obtain an OpaquePulse by\n/// converting a Pulse\n#[derive(Clone, Debug, PartialEq, codec::MaxEncodedLen, scale_info::TypeInfo, Encode, Decode)]\npub struct OpaquePulse {\n\t/// The round of the beacon protocol\n\tpub round: u64,\n\t/// A compressed BLS signature\n\tpub signature: [u8; 48],\n}\n\nimpl TryInto\u003cOpaquePulse\u003e for Pulse {\n\ttype Error = String;\n\t/// Converts a Pulse into an OpaquePulse\n\tfn try_into(self) -\u003e Result\u003cOpaquePulse, Self::Error\u003e {\n\t\tlet signature: [u8; 48] = self\n\t\t\t.signature\n\t\t\t.clone()\n\t\t\t.try_into()\n\t\t\t.map_err(|e| format!(\"The signature must be 48 bytes: {:?}\", e))?;\n\n\t\tOk(OpaquePulse { round: self.round, signature })\n\t}\n}\n\nimpl OpaquePulse {\n\t/// Serialize the opaque pulse as a vector\n\tpub fn serialize_to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n\t\tlet mut vec = Vec::new();\n\t\tvec.extend_from_slice(\u0026self.round.to_le_bytes());\n\t\tvec.extend_from_slice(\u0026self.signature);\n\t\tvec\n\t}\n\n\t/// Deserialize from a slice\n\t///\n\t/// * `data`: The data to attempt to deserialize\n\tpub fn deserialize_from_vec(data: \u0026[u8]) -\u003e Result\u003cSelf, String\u003e {\n\t\tif data.len() != 56 {\n\t\t\treturn Err(format!(\n\t\t\t\t\"Invalid buffer size, expected 56 bytes but received {}\",\n\t\t\t\tdata.len()\n\t\t\t));\n\t\t}\n\n\t\tlet bytes = data[0..8].try_into().map_err(|_| \"Failed to parse round\".to_string())?;\n\t\tlet round = u64::from_le_bytes(bytes);\n\n\t\tlet signature: [u8; 48] =\n\t\t\tdata[8..56].try_into().map_err(|_| \"Failed to parse signature\".to_string())?;\n\n\t\tOk(OpaquePulse { round, signature })\n\t}\n\n\t/// Compute the signature as a group element\n\tpub fn signature_point(\u0026self) -\u003e Result\u003cG1AffineOpt, String\u003e {\n\t\tG1AffineOpt::deserialize_compressed(\u0026mut self.signature.as_slice()).map_err(|e| {\n\t\t\tformat!(\"Failed to deserialize the signature bytes to a point on the G1 curve: {:?}\", e)\n\t\t})\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\tfn valid_pulse() -\u003e Pulse {\n\t\tPulse { round: 14475418, signature: VALID_SIG.to_vec() }\n\t}\n\n\tfn invalid_pulse() -\u003e Pulse {\n\t\tPulse {\n\t\t\tround: 14475418,\n\t\t\tsignature: vec![\n\t\t\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37,\n\t\t\t\t95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49,\n\t\t\t\t223, 95, 22, 186, 113, 163, 202, 195, 230,\n\t\t\t],\n\t\t}\n\t}\n\n\tpub const SERIALIZED_VALID: \u0026[u8] = \u0026[\n\t\t154, 224, 220, 0, 0, 0, 0, 0, 146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242,\n\t\t43, 61, 28, 75, 93, 37, 95, 131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104,\n\t\t76, 235, 84, 49, 223, 95, 22, 186, 113, 163, 202, 195, 230, 117,\n\t];\n\n\tpub const VALID_SIG: \u0026[u8] = \u0026[\n\t\t146, 37, 87, 193, 37, 144, 182, 61, 73, 122, 248, 242, 242, 43, 61, 28, 75, 93, 37, 95,\n\t\t131, 38, 3, 203, 216, 6, 213, 241, 244, 90, 162, 208, 90, 104, 76, 235, 84, 49, 223, 95,\n\t\t22, 186, 113, 163, 202, 195, 230, 117,\n\t];\n\n\t#[test]\n\tfn test_pulse_to_opaque_pulse_conversion() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet result: Result\u003cOpaquePulse, _\u003e = valid_pulse.clone().try_into();\n\t\tassert!(result.is_ok(), \"Valid pulse should convert to OpaquePulse\");\n\t\tlet opaque_pulse = result.unwrap();\n\t\tassert_eq!(opaque_pulse.round, valid_pulse.round);\n\t\tassert_eq!(opaque_pulse.signature, valid_pulse.signature[..]);\n\t}\n\n\t#[test]\n\tfn test_pulse_with_invalid_signature_fails() {\n\t\tlet result: Result\u003cOpaquePulse, _\u003e = invalid_pulse().try_into();\n\t\tassert!(result.is_err(), \"Pulse with invalid signature should not convert\");\n\t}\n\n\t#[test]\n\tfn test_serialize_to_vec() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet opaque_pulse: OpaquePulse = valid_pulse.clone().try_into().unwrap();\n\t\tlet serialized = opaque_pulse.serialize_to_vec();\n\t\tassert_eq!(serialized, SERIALIZED_VALID, \"Serialization should match expected byte output\");\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_valid_vec() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet result = OpaquePulse::deserialize_from_vec(SERIALIZED_VALID);\n\t\tassert!(result.is_ok(), \"Deserialization should succeed for valid input\");\n\t\tlet opaque_pulse = result.unwrap();\n\t\tassert_eq!(opaque_pulse.round, valid_pulse.round);\n\t\tassert_eq!(opaque_pulse.signature, valid_pulse.signature[..]);\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_invalid_length() {\n\t\tlet invalid_data = \u0026[0; 50]; // Less than 56 bytes\n\t\tlet result = OpaquePulse::deserialize_from_vec(invalid_data);\n\t\tassert!(result.is_err(), \"Deserialization should fail for short input\");\n\t}\n\n\t#[test]\n\tfn test_deserialize_from_excess_length() {\n\t\tlet invalid_data = \u0026[0; 60]; // More than 56 bytes\n\t\tlet result = OpaquePulse::deserialize_from_vec(invalid_data);\n\t\tassert!(result.is_err(), \"Deserialization should fail for long input\");\n\t}\n\n\t#[test]\n\tfn test_signature_point_invalid() {\n\t\tlet valid_pulse = valid_pulse();\n\t\tlet mut opaque_pulse: OpaquePulse = valid_pulse.clone().try_into().unwrap();\n\t\t// corrupt the signature\n\t\topaque_pulse.signature = [1; 48];\n\t\tlet result = opaque_pulse.signature_point();\n\t\tassert!(\n\t\t\tresult.is_err(),\n\t\t\t\"Signature should not deserialize to a valid G1 point with random bytes\"\n\t\t);\n\t}\n}\n","traces":[{"line":58,"address":[4559712,4560071],"length":1,"stats":{"Line":1}},{"line":59,"address":[8671129,8671369,8671062],"length":1,"stats":{"Line":3}},{"line":63,"address":[9076080,9076101,9076247],"length":1,"stats":{"Line":4}},{"line":65,"address":[8671248],"length":1,"stats":{"Line":1}},{"line":71,"address":[8671456,8671677],"length":1,"stats":{"Line":2}},{"line":72,"address":[8671480],"length":1,"stats":{"Line":2}},{"line":73,"address":[8671555,8671499],"length":1,"stats":{"Line":4}},{"line":74,"address":[4560248],"length":1,"stats":{"Line":2}},{"line":75,"address":[4560286],"length":1,"stats":{"Line":2}},{"line":81,"address":[4560336],"length":1,"stats":{"Line":4}},{"line":82,"address":[4560379],"length":1,"stats":{"Line":4}},{"line":83,"address":[4560837,4560707],"length":1,"stats":{"Line":4}},{"line":85,"address":[4560699],"length":1,"stats":{"Line":2}},{"line":89,"address":[4561245,4560594,4560876],"length":1,"stats":{"Line":4}},{"line":90,"address":[8672254],"length":1,"stats":{"Line":2}},{"line":92,"address":[4808636,4808624],"length":1,"stats":{"Line":4}},{"line":95,"address":[4561353],"length":1,"stats":{"Line":2}},{"line":99,"address":[4561520],"length":1,"stats":{"Line":2}},{"line":100,"address":[4561556],"length":1,"stats":{"Line":3}},{"line":101,"address":[4808712,4808760],"length":1,"stats":{"Line":2}}],"covered":20,"coverable":20},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","impls.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Implementations of public traits\n\nuse crate::{\n\tself as pallet_idn_manager,\n\ttraits::{BalanceDirection, DiffBalance, FeesError},\n\tHoldReason, Subscription, SubscriptionTrait,\n};\nuse codec::Encode;\nuse frame_support::{\n\tpallet_prelude::DispatchError,\n\ttraits::{\n\t\ttokens::{fungible::hold::Mutate, Fortitude, Precision, Restriction},\n\t\tGet,\n\t},\n};\nuse sp_arithmetic::traits::Unsigned;\nuse sp_runtime::{traits::Zero, AccountId32, Saturating};\nuse sp_std::{cmp::Ordering, marker::PhantomData};\n\nimpl\u003cAccountId, BlockNumber: Unsigned, Metadata\u003e SubscriptionTrait\u003cAccountId\u003e\n\tfor Subscription\u003cAccountId, BlockNumber, Metadata\u003e\n{\n\tfn subscriber(\u0026self) -\u003e \u0026AccountId {\n\t\t\u0026self.details.subscriber\n\t}\n}\n\nimpl SubscriptionTrait\u003c()\u003e for () {\n\tfn subscriber(\u0026self) -\u003e \u0026() {\n\t\t\u0026()\n\t}\n}\n\n/// A FeesManager implementation that holds a dynamic treasury account.\npub struct FeesManagerImpl\u003cTreasury, BaseFee, Sub, Balances\u003e {\n\tpub _phantom: FeesManagerPhantom\u003cTreasury, BaseFee, Sub, Balances\u003e,\n}\ntype FeesManagerPhantom\u003cTreasury, BaseFee, Sub, Balances\u003e =\n\t(PhantomData\u003cTreasury\u003e, PhantomData\u003cBaseFee\u003e, PhantomData\u003cSub\u003e, PhantomData\u003cBalances\u003e);\n\nimpl\u003c\n\t\tT: Get\u003cAccountId32\u003e,\n\t\tB: Get\u003cBalances::Balance\u003e,\n\t\tS: SubscriptionTrait\u003cAccountId32\u003e,\n\t\tBalances: Mutate\u003cAccountId32\u003e,\n\t\u003e pallet_idn_manager::FeesManager\u003cBalances::Balance, u64, S, DispatchError, AccountId32\u003e\n\tfor FeesManagerImpl\u003cT, B, S, Balances\u003e\nwhere\n\tBalances::Reason: From\u003cHoldReason\u003e,\n\tBalances::Balance: From\u003cu64\u003e,\n{\n\t/// Calculate the subscription fees based on the number of requested credits.\n\t///\n\t/// This function implements a tiered pricing model with volume discounts:\n\t/// - Tier 1 (1-10 credits): 100% of base fee per credit (no discount)\n\t/// - Tier 2 (11-100 credits): 95% of base fee per credit (5% discount)\n\t/// - Tier 3 (101-1000 credits): 90% of base fee per credit (10% discount)\n\t/// - Tier 4 (1001-10000 credits): 80% of base fee per credit (20% discount)\n\t/// - Tier 5 (10001+ credits): 70% of base fee per credit (30% discount)\n\t///\n\t/// The fee calculation processes each tier sequentially:\n\t/// 1. For each tier, calculate how many credits fall within that tier\n\t/// 2. Apply the corresponding discount rate to those credits\n\t/// 3. Sum up the fees across all tiers\n\t///\n\t/// # Parameters\n\t/// * `credits` - The total number of credits requested for the subscription\n\t///\n\t/// # Returns\n\t/// The total fee required for the requested number of credits, converted to the\n\t/// appropriate balance type\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// // 100 credits would incur a fee of:\n\t/// // - 10 credits at full price: 10 * 100 = 1000\n\t/// // - 90 credits at 5% discount: 90 * 95 = 8550\n\t/// // Total: 9550\n\t/// let fees = calculate_subscription_fees(\u0026100u64);\n\t/// assert_eq!(fees, 9550u64.into());\n\t/// ```\n\tfn calculate_subscription_fees(credits: \u0026u64) -\u003e Balances::Balance {\n\t\t// Define tier boundaries and their respective discount rates (in basis points)\n\t\tconst TIERS: [(u64, u64); 5] = [\n\t\t\t(1, 0),        // 0-10: 0% discount\n\t\t\t(11, 500),     // 11-100: 5% discount\n\t\t\t(101, 1000),   // 101-1000: 10% discount\n\t\t\t(1001, 2000),  // 1001-10000: 20% discount\n\t\t\t(10001, 3000), // 10001+: 30% discount\n\t\t];\n\n\t\tconst BASE_FEE: u64 = 100;\n\n\t\tlet mut total_fee = 0u64;\n\t\tlet mut remaining_credits = *credits;\n\n\t\tfor (i, \u0026(current_tier_start, current_tier_discount)) in TIERS.iter().enumerate() {\n\t\t\t// If no remaining credits exit loop.\n\t\t\tif remaining_credits == 0 {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet next_tier_start = TIERS.get(i + 1).map(|\u0026(start, _)| start).unwrap_or(u64::MAX);\n\n\t\t\tlet credits_in_tier =\n\t\t\t\t(credits.min(\u0026next_tier_start.saturating_sub(1)) - current_tier_start + 1)\n\t\t\t\t\t.min(remaining_credits);\n\n\t\t\tlet tier_fee = BASE_FEE\n\t\t\t\t.saturating_mul(credits_in_tier)\n\t\t\t\t.saturating_mul(10_000 - current_tier_discount)\n\t\t\t\t.saturating_div(10_000);\n\n\t\t\ttotal_fee = total_fee.saturating_add(tier_fee);\n\t\t\tremaining_credits = remaining_credits.saturating_sub(credits_in_tier);\n\t\t}\n\n\t\ttotal_fee.into()\n\t}\n\n\t/// Calculate the difference in fees when a subscription changes, determining whether\n\t/// additional fees should be collected or excess fees should be released. This is useful for\n\t/// subscription updates and kills for holding or releasing fees. Or when collecting fees from a\n\t/// subscriber.\n\t///\n\t/// This function compares the fees required before and after a subscription change,\n\t/// then returns:\n\t/// - The fee difference amount\n\t/// - The direction of the balance transfer (collect from user, release to user, or no change)\n\t///\n\t/// # Parameters\n\t/// * `old_credits`\n\t///   - For an update operation, this represents the original requested credits\n\t///   - For a kill and collect operation, this is the number of credits left in the subscription\n\t/// * `new_credits`\n\t///   - For an update operation, this represents the new requested credits\n\t///   - For a kill operation, this is 0\n\t///   - For a collect operation, this is the actual number of credits consumed\n\t///\n\t/// # Returns\n\t/// A `DiffBalance` struct containing:\n\t/// - `balance`: The amount of fees to collect or release\n\t/// - `direction`: Whether to collect additional fees, release excess fees, or do nothing\n\t///\n\t/// # Examples\n\t/// ```no_compile\n\t/// // When increasing credits, additional fees are collected:\n\t/// // Old: 10 credits (1000 fee), New: 50 credits (5000 fee)\n\t/// let diff = calculate_diff_fees(\u002610, \u002650);\n\t/// assert_eq!(diff.balance, 4000);\n\t/// assert_eq!(diff.direction, BalanceDirection::Collect);\n\t///\n\t/// // When decreasing credits, excess fees are released:\n\t/// // Old: 100 credits (9550 fee), New: 10 credits (1000 fee)\n\t/// let diff = calculate_diff_fees(\u0026100, \u002610);\n\t/// assert_eq!(diff.balance, 8550);\n\t/// assert_eq!(diff.direction, BalanceDirection::Release);\n\t///\n\t/// // When credits remain the same, no fee changes occur:\n\t/// // Old: 50 credits (5000 fee), New: 50 credits (5000 fee)\n\t/// let diff = calculate_diff_fees(\u002650, \u002650);\n\t/// assert_eq!(diff.balance, 0);\n\t/// assert_eq!(diff.direction, BalanceDirection::None);\n\t/// ```\n\tfn calculate_diff_fees(old_credits: \u0026u64, new_credits: \u0026u64) -\u003e DiffBalance\u003cBalances::Balance\u003e {\n\t\tlet old_fees = Self::calculate_subscription_fees(old_credits);\n\t\tlet new_fees = Self::calculate_subscription_fees(new_credits);\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_fees.cmp(\u0026old_fees) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tnew_fees - old_fees\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\told_fees - new_fees\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\n\t/// Attempts to collect subscription fees from a subscriber and transfer them to the treasury\n\t/// account.\n\t///\n\t/// This function:\n\t/// 1. Transfers the specified fees from the subscriber's held balance to the treasury account\n\t/// 2. Verifies that the full fee amount was successfully collected\n\t/// 3. Returns the actual amount collected or an appropriate error\n\t///\n\t/// # Parameters\n\t/// * `fees` - The amount of fees to collect\n\t/// * `sub` - The subscription object containing the subscriber account information\n\t///\n\t/// # Returns\n\t/// - `Ok(collected)` - The amount of fees successfully collected and transferred\n\t/// - `Err(FeesError)` - If the transfer operation fails\n\t///\n\t/// # Notes\n\t/// - This function uses `transfer_on_hold` which transfers from the subscriber's held balance\n\t/// - The fees are held under the `HoldReason::Fees` reason code\n\t/// - The transfer uses `Precision::BestEffort` which allows partial transfers if full amount\n\t///   isn't available\n\t/// - Despite using best effort, this function will return an error if less than the requested\n\t///   amount is collected\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// let fees = 1000u64.into();\n\t/// let result = FeesManagerImpl::\u003cTreasury, BaseFee, Subscription, Balances\u003e::collect_fees(\n\t///     \u0026fees,\n\t///     \u0026subscription\n\t/// );\n\t///\n\t/// match result {\n\t///     Ok(collected) =\u003e println!(\"Successfully collected {} in fees\", collected),\n\t///     Err(FeesError::NotEnoughBalance { needed, balance }) =\u003e {\n\t///         println!(\"Insufficient balance: needed {}, had {}\", needed, balance);\n\t///     },\n\t///     Err(FeesError::Other(err)) =\u003e println!(\"Transfer error: {:?}\", err),\n\t/// }\n\t/// ```\n\tfn collect_fees(\n\t\tfees: \u0026Balances::Balance,\n\t\tsub: \u0026S,\n\t) -\u003e Result\u003cBalances::Balance, FeesError\u003cBalances::Balance, DispatchError\u003e\u003e {\n\t\t// Collect the held fees from the subscriber\n\t\tlet collected = Balances::transfer_on_hold(\n\t\t\t\u0026HoldReason::Fees.into(),\n\t\t\tsub.subscriber(),\n\t\t\t\u0026T::get(),\n\t\t\t*fees,\n\t\t\tPrecision::BestEffort,\n\t\t\tRestriction::Free,\n\t\t\tFortitude::Polite,\n\t\t)\n\t\t.map_err(FeesError::Other)?;\n\n\t\t// Ensure the correct credits was collected.\n\t\t// TODO: error to bubble up and be handled by caller https://github.com/ideal-lab5/idn-sdk/issues/107\n\t\tif collected \u003c *fees {\n\t\t\treturn Err(FeesError::NotEnoughBalance { needed: *fees, balance: collected });\n\t\t}\n\n\t\tOk(collected)\n\t}\n}\n\npub struct DepositCalculatorImpl\u003cSDMultiplier: Get\u003cDeposit\u003e, Deposit\u003e {\n\tpub _phantom: (PhantomData\u003cSDMultiplier\u003e, PhantomData\u003cDeposit\u003e),\n}\n\nimpl\u003c\n\t\tS: SubscriptionTrait\u003cAccountId32\u003e + Encode,\n\t\tSDMultiplier: Get\u003cDeposit\u003e,\n\t\tDeposit: Saturating + From\u003cu64\u003e + Ord,\n\t\u003e pallet_idn_manager::DepositCalculator\u003cDeposit, S\u003e\n\tfor DepositCalculatorImpl\u003cSDMultiplier, Deposit\u003e\n{\n\t/// Calculate the storage deposit required for a subscription.\n\t///\n\t/// This function computes the storage deposit amount based on the encoded size of the\n\t/// subscription object multiplied by a configurable deposit multiplier.\n\t///\n\t/// # Parameters\n\t/// * `sub` - The subscription object for which to calculate the storage deposit\n\t///\n\t/// # Returns\n\t/// The amount of deposit required for the subscription's storage\n\t///\n\t/// # Security Considerations\n\t/// This function handles potential overflow scenarios by:\n\t/// 1. Converting the encoded size from `usize` to `u64` with fallback to `u64::MAX` if the\n\t///    conversion fails\n\t/// 2. Using saturating multiplication to prevent arithmetic overflow\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// let subscription = Subscription {\n\t///     // subscription details...\n\t/// };\n\t///\n\t/// // If SDMultiplier is 2 and the subscription encodes to 100 bytes:\n\t/// let deposit = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_storage_deposit(\u0026subscription);\n\t/// assert_eq!(deposit, 200);\n\t/// ```\n\tfn calculate_storage_deposit(sub: \u0026S) -\u003e Deposit {\n\t\t// [SRLabs] Note: There is a theoretical edge case where if the `Deposit` type (e.g., u64)\n\t\t// is larger than the machine architecture size (e.g., 32-bit platforms), an attacker\n\t\t// could create a subscription object larger than u32::MAX bits and only pay a deposit for\n\t\t// u32::MAX bits, not the full size. This risk is mitigated in practice by platform\n\t\t// constraints and cost barriers.\n\t\tlet storage_deposit_multiplier = SDMultiplier::get();\n\t\tlet encoded_size = u64::try_from(sub.encoded_size()).unwrap_or(u64::MAX);\n\t\tstorage_deposit_multiplier.saturating_mul(encoded_size.into())\n\t}\n\n\t/// Calculate the difference in storage deposit between two subscriptions.\n\t///\n\t/// This function compares the storage deposit requirements of two subscription states\n\t/// and returns the difference along with the direction of the balance adjustment.\n\t///\n\t/// # Parameters\n\t/// * `old_sub` - The original subscription before changes\n\t/// * `new_sub` - The updated subscription after changes\n\t///\n\t/// # Returns\n\t/// A `DiffBalance` struct containing:\n\t/// - `balance`: The absolute difference between the old and new deposit amounts\n\t/// - `direction`: Whether to collect additional deposit, release excess deposit, or make no\n\t///   change\n\t///\n\t/// # How It Works\n\t/// 1. Calculates the storage deposit for both the old and new subscription states\n\t/// 2. Compares the two deposits to determine if more deposit is needed, some can be released,\n\t///    or no change is required\n\t/// 3. Returns both the amount and direction of the required deposit adjustment\n\t///\n\t/// # Example\n\t/// ```no_compile\n\t/// // When subscription size increases (e.g., metadata added):\n\t/// let old_sub = /* subscription with 100 bytes encoded size */;\n\t/// let new_sub = /* same subscription with 150 bytes encoded size */;\n\t///\n\t/// // If SDMultiplier is 2:\n\t/// // Old deposit = 2 * 100 = 200\n\t/// // New deposit = 2 * 150 = 300\n\t/// let diff = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_diff_deposit(\u0026old_sub, \u0026new_sub);\n\t/// assert_eq!(diff.balance, 100); // 300 - 200 = 100 more needed\n\t/// assert_eq!(diff.direction, BalanceDirection::Collect);\n\t///\n\t/// // When subscription size decreases (e.g., metadata removed):\n\t/// let old_sub = /* subscription with 150 bytes encoded size */;\n\t/// let new_sub = /* same subscription with 100 bytes encoded size */;\n\t///\n\t/// // Old deposit = 2 * 150 = 300\n\t/// // New deposit = 2 * 100 = 200\n\t/// let diff = DepositCalculatorImpl::\u003cSDMultiplier, u64\u003e::calculate_diff_deposit(\u0026old_sub, \u0026new_sub);\n\t/// assert_eq!(diff.balance, 100); // 300 - 200 = 100 to release\n\t/// assert_eq!(diff.direction, BalanceDirection::Release);\n\t/// ```\n\tfn calculate_diff_deposit(old_sub: \u0026S, new_sub: \u0026S) -\u003e DiffBalance\u003cDeposit\u003e {\n\t\tlet old_deposit = Self::calculate_storage_deposit(old_sub);\n\t\tlet new_deposit = Self::calculate_storage_deposit(new_sub);\n\t\tlet direction = match new_deposit.cmp(\u0026old_deposit) {\n\t\t\tOrdering::Greater =\u003e BalanceDirection::Collect,\n\t\t\tOrdering::Less =\u003e BalanceDirection::Release,\n\t\t\tOrdering::Equal =\u003e BalanceDirection::None,\n\t\t};\n\t\tDiffBalance { balance: new_deposit.saturating_sub(old_deposit), direction }\n\t}\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[3787952],"length":1,"stats":{"Line":0}},{"line":72,"address":[3372560,3372694],"length":1,"stats":{"Line":3}},{"line":73,"address":[3372574,3372631],"length":1,"stats":{"Line":6}},{"line":74,"address":[3372636],"length":1,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":2}}],"covered":7,"coverable":22},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # IDN Manager Pallet\n//!\n//! This pallet manages subscriptions for random value distribution.\n//!\n//! ## Subscription State Lifecycle\n//! ```mermaid\n//! stateDiagram-v2\n//!     [*] --\u003e Active\n//!     Active --\u003e Paused\n//!     Paused --\u003e Active\n//!     Paused --\u003e [*]\n//!     Active --\u003e [*]\n//! ```\n//! ### States\n//!\n//! 1. Active (Default)\n//!    - Randomness is actively distributed\n//!    - IDN delivers random values according to subscription parameters\n//!\n//! 2. Paused\n//!    - Randomness distribution temporarily suspended\n//!    - Subscription remains in storage\n//!    - Can be reactivated\n//!\n//! ### Termination\n//! Subscription ends when:\n//! - All allocated random values are consumed\n//! - Manually killed by the original caller\n//!\n//! Upon termination:\n//! - Removed from storage\n//! - Storage deposit returned\n//! - Unused credits refunded to the origin\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n#[cfg(test)]\nmod tests;\n\npub mod impls;\npub mod traits;\npub mod weights;\n\nuse crate::traits::FeesError;\nuse codec::{Codec, Decode, Encode, MaxEncodedLen};\nuse frame_support::{\n\tpallet_prelude::{\n\t\tensure, Blake2_128Concat, DispatchError, DispatchResult, Hooks, IsType, OptionQuery,\n\t\tStorageMap, Zero,\n\t},\n\tsp_runtime::traits::AccountIdConversion,\n\ttraits::{\n\t\tfungible::{hold::Mutate as HoldMutate, Inspect},\n\t\ttokens::Precision,\n\t\tGet,\n\t},\n\tBoundedVec,\n};\nuse frame_system::{\n\tensure_signed,\n\tpallet_prelude::{BlockNumberFor, OriginFor},\n};\nuse scale_info::TypeInfo;\nuse sp_arithmetic::traits::Unsigned;\nuse sp_core::H256;\nuse sp_io::hashing::blake2_256;\nuse sp_runtime::{traits::One, Saturating};\nuse sp_std::fmt::Debug;\nuse traits::{\n\tBalanceDirection, DepositCalculator, DiffBalance, FeesManager,\n\tSubscription as SubscriptionTrait,\n};\nuse xcm::{\n\tv5::{prelude::*, Location},\n\tVersionedLocation, VersionedXcm,\n};\nuse xcm_builder::SendController;\n\npub use pallet::*;\npub use weights::WeightInfo;\n\npub type BalanceOf\u003cT\u003e =\n\t\u003c\u003cT as Config\u003e::Currency as Inspect\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e\u003e::Balance;\n\npub type MetadataOf\u003cT\u003e = BoundedVec\u003cu8, \u003cT as Config\u003e::SubMetadataLen\u003e;\n\npub type SubscriptionOf\u003cT\u003e =\n\tSubscription\u003c\u003cT as frame_system::Config\u003e::AccountId, BlockNumberFor\u003cT\u003e, MetadataOf\u003cT\u003e\u003e;\n\n#[derive(Encode, Decode, Clone, TypeInfo, MaxEncodedLen, Debug)]\npub struct Subscription\u003cAccountId, BlockNumber: Unsigned, Metadata\u003e {\n\tdetails: SubscriptionDetails\u003cAccountId, Metadata\u003e,\n\t// Number of random values left to distribute\n\tcredits_left: BlockNumber,\n\tstate: SubscriptionState,\n\tcreated_at: BlockNumber,\n\tupdated_at: BlockNumber,\n\tcredits: BlockNumber,\n\tfrequency: BlockNumber,\n}\n\n// TODO: details should be immutable, they are what make the subscription unique\n// https://github.com/ideal-lab5/idn-sdk/issues/114\n#[derive(Encode, Decode, Clone, TypeInfo, MaxEncodedLen, Debug)]\npub struct SubscriptionDetails\u003cAccountId, Metadata\u003e {\n\tsubscriber: AccountId,\n\ttarget: Location,\n\tmetadata: Metadata,\n}\n\nimpl\u003cAccountId, BlockNumber, Metadata\u003e Subscription\u003cAccountId, BlockNumber, Metadata\u003e\nwhere\n\tAccountId: Encode,\n\tBlockNumber: Encode + Copy + Unsigned,\n\tMetadata: Encode + Clone,\n{\n\tpub fn id(\u0026self) -\u003e SubscriptionId {\n\t\tlet id_tuple = (\n\t\t\tself.created_at,\n\t\t\t\u0026self.details.subscriber,\n\t\t\tself.details.target.clone(),\n\t\t\tself.details.metadata.clone(),\n\t\t);\n\t\t// Encode the tuple using SCALE codec.\n\t\tlet encoded = id_tuple.encode();\n\t\t// Hash the encoded bytes using blake2_256.\n\t\tH256::from_slice(\u0026blake2_256(\u0026encoded))\n\t}\n}\n\ntype SubscriptionId = H256;\n\n#[derive(Encode, Decode, Clone, PartialEq, TypeInfo, MaxEncodedLen, Debug)]\npub enum SubscriptionState {\n\tActive,\n\tPaused,\n}\n\n#[derive(Encode, Decode, Debug, PartialEq, Eq, Clone, TypeInfo)]\npub enum Call {\n\t#[codec(index = 1)]\n\tDistributeRnd,\n}\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\n\t\t/// The currency type for handling subscription payments\n\t\ttype Currency: Inspect\u003c\u003cSelf as frame_system::pallet::Config\u003e::AccountId\u003e\n\t\t\t+ HoldMutate\u003c\n\t\t\t\t\u003cSelf as frame_system::pallet::Config\u003e::AccountId,\n\t\t\t\tReason = Self::RuntimeHoldReason,\n\t\t\t\u003e;\n\n\t\t/// Overarching hold reason.\n\t\ttype RuntimeHoldReason: From\u003cHoldReason\u003e;\n\n\t\t/// Fees calculator implementation\n\t\ttype FeesManager: FeesManager\u003c\n\t\t\tBalanceOf\u003cSelf\u003e,\n\t\t\tBlockNumberFor\u003cSelf\u003e,\n\t\t\tSubscriptionOf\u003cSelf\u003e,\n\t\t\tDispatchError,\n\t\t\t\u003cSelf as frame_system::pallet::Config\u003e::AccountId,\n\t\t\u003e;\n\n\t\t/// Storage deposit calculator implementation\n\t\ttype DepositCalculator: DepositCalculator\u003cBalanceOf\u003cSelf\u003e, SubscriptionOf\u003cSelf\u003e\u003e;\n\n\t\t/// The type for the randomness\n\t\ttype Rnd;\n\n\t\t// The weight information for this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// A type that exposes XCM APIs, allowing contracts to interact with other parachains, and\n\t\t/// execute XCM programs.\n\t\ttype Xcm: xcm_builder::Controller\u003c\n\t\t\tOriginFor\u003cSelf\u003e,\n\t\t\t\u003cSelf as frame_system::Config\u003e::RuntimeCall,\n\t\t\tBlockNumberFor\u003cSelf\u003e,\n\t\t\u003e;\n\n\t\t/// The IDN Manager pallet id.\n\t\t#[pallet::constant]\n\t\ttype PalletId: Get\u003cframe_support::PalletId\u003e;\n\n\t\t/// Maximum metadata size\n\t\ttype SubMetadataLen: Get\u003cu32\u003e + TypeInfo;\n\t}\n\n\t#[pallet::storage]\n\tpub type Subscriptions\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tBlake2_128Concat,\n\t\tSubscriptionId,\n\t\tSubscription\u003cT::AccountId, BlockNumberFor\u003cT\u003e, MetadataOf\u003cT\u003e\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// A new subscription was created (includes single-block subscriptions)\n\t\tSubscriptionCreated { sub_id: SubscriptionId },\n\t\t/// A subscription has finished\n\t\tSubscriptionRemoved { sub_id: SubscriptionId },\n\t\t/// A subscription was paused\n\t\tSubscriptionPaused { sub_id: SubscriptionId },\n\t\t/// A subscription was updated\n\t\tSubscriptionUpdated { sub_id: SubscriptionId },\n\t\t/// A subscription was reactivated\n\t\tSubscriptionReactivated { sub_id: SubscriptionId },\n\t\t/// Randomness was successfully distributed\n\t\tRandomnessDistributed { sub_id: SubscriptionId },\n\t\t/// Fees collected\n\t\tFeesCollected { sub_id: SubscriptionId, fees: BalanceOf\u003cT\u003e },\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// A Subscription already exists\n\t\tSubscriptionAlreadyExists,\n\t\t/// A Subscription does not exist\n\t\tSubscriptionDoesNotExist,\n\t\t/// Subscription is already active\n\t\tSubscriptionAlreadyActive,\n\t\t/// Subscription is already paused\n\t\tSubscriptionAlreadyPaused,\n\t\t/// The origin isn't the subscriber\n\t\tNotSubscriber,\n\t}\n\n\t/// A reason for the IDN Manager Pallet placing a hold on funds.\n\t#[pallet::composite_enum]\n\tpub enum HoldReason {\n\t\t/// The IDN Manager Pallet holds balance for future charges.\n\t\t#[codec(index = 0)]\n\t\tFees,\n\t\t/// Storage deposit\n\t\t#[codec(index = 1)]\n\t\tStorageDeposit,\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\tfn on_finalize(_n: BlockNumberFor\u003cT\u003e) {\n\t\t\t// Look for subscriptions that should be finished\n\t\t\tfor (sub_id, sub) in\n\t\t\t\tSubscriptions::\u003cT\u003e::iter().filter(|(_, sub)| sub.credits_left == Zero::zero())\n\t\t\t{\n\t\t\t\t// finish the subscription\n\t\t\t\tlet _ = Self::finish_subscription(\u0026sub, sub_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Creates a subscription for one or multiple blocks\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(T::WeightInfo::create_subscription())]\n\t\tpub fn create_subscription(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\t// Number of random values to receive\n\t\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\t\t// XCM multilocation for random value delivery\n\t\t\ttarget: Location,\n\t\t\t// Distribution interval for random values\n\t\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\t\t// Bounded vector for additional data\n\t\t\tmetadata: Option\u003cMetadataOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSelf::create_subscription_internal(subscriber, credits, target, frequency, metadata)\n\t\t}\n\n\t\t/// Temporarily halts randomness distribution\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(T::WeightInfo::pause_subscription())]\n\t\tpub fn pause_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\t\t\t\tensure!(\n\t\t\t\t\tsub.state != SubscriptionState::Paused,\n\t\t\t\t\tError::\u003cT\u003e::SubscriptionAlreadyPaused\n\t\t\t\t);\n\t\t\t\tsub.state = SubscriptionState::Paused;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionPaused { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Ends the subscription before its natural conclusion\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(T::WeightInfo::kill_subscription())]\n\t\tpub fn kill_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\n\t\t\tlet sub =\n\t\t\t\tSelf::get_subscription(\u0026sub_id).ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\n\t\t\tSelf::finish_subscription(\u0026sub, sub_id)\n\t\t}\n\n\t\t/// Updates a subscription\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(T::WeightInfo::update_subscription())]\n\t\tpub fn update_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t\t// New number of random values\n\t\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\t\t// New distribution interval\n\t\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\n\t\t\t\tlet fees_diff = T::FeesManager::calculate_diff_fees(\u0026sub.credits, \u0026credits);\n\t\t\t\tlet deposit_diff = T::DepositCalculator::calculate_diff_deposit(\n\t\t\t\t\tsub,\n\t\t\t\t\t\u0026Subscription { credits, frequency, ..sub.clone() },\n\t\t\t\t);\n\n\t\t\t\tsub.credits = credits;\n\t\t\t\tsub.frequency = frequency;\n\t\t\t\tsub.updated_at = frame_system::Pallet::\u003cT\u003e::block_number();\n\n\t\t\t\t// Hold or refund diff fees\n\t\t\t\tSelf::manage_diff_fees(\u0026subscriber, \u0026fees_diff)?;\n\t\t\t\t// Hold or refund diff deposit\n\t\t\t\tSelf::manage_diff_deposit(\u0026subscriber, \u0026deposit_diff)?;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionUpdated { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Reactivates a paused subscription\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(T::WeightInfo::reactivate_subscription())]\n\t\tpub fn reactivate_subscription(\n\t\t\t// Must match the subscription's original caller\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tsub_id: SubscriptionId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet subscriber = ensure_signed(origin)?;\n\t\t\tSubscriptions::\u003cT\u003e::try_mutate(sub_id, |maybe_sub| {\n\t\t\t\tlet sub = maybe_sub.as_mut().ok_or(Error::\u003cT\u003e::SubscriptionDoesNotExist)?;\n\t\t\t\tensure!(sub.details.subscriber == subscriber, Error::\u003cT\u003e::NotSubscriber);\n\t\t\t\tensure!(\n\t\t\t\t\tsub.state != SubscriptionState::Active,\n\t\t\t\t\tError::\u003cT\u003e::SubscriptionAlreadyActive\n\t\t\t\t);\n\t\t\t\tsub.state = SubscriptionState::Active;\n\t\t\t\tSelf::deposit_event(Event::SubscriptionReactivated { sub_id });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\t}\n}\n\nimpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t/// Finishes a subscription by removing it from storage and emitting a finish event.\n\tpub(crate) fn finish_subscription(\n\t\tsub: \u0026SubscriptionOf\u003cT\u003e,\n\t\tsub_id: SubscriptionId,\n\t) -\u003e DispatchResult {\n\t\t// fees left and deposit to refund\n\t\tlet fees_diff = T::FeesManager::calculate_diff_fees(\u0026sub.credits_left, \u0026Zero::zero());\n\t\tlet sd = T::DepositCalculator::calculate_storage_deposit(sub);\n\n\t\tSelf::manage_diff_fees(\u0026sub.details.subscriber, \u0026fees_diff)?;\n\t\tSelf::release_deposit(\u0026sub.details.subscriber, sd)?;\n\n\t\tSelf::deposit_event(Event::SubscriptionRemoved { sub_id });\n\n\t\tSubscriptions::\u003cT\u003e::remove(sub_id);\n\t\tSelf::deposit_event(Event::SubscriptionRemoved { sub_id });\n\t\tOk(())\n\t}\n\n\tfn pallet_account_id() -\u003e T::AccountId {\n\t\tT::PalletId::get().into_account_truncating()\n\t}\n\n\t/// Distribute randomness to subscribers\n\t/// Returns a weight based on the number of storage reads and writes performed\n\t// TODO: finish off this as part of https://github.com/ideal-lab5/idn-sdk/issues/77\n\tfn distribute(rnd: T::Rnd) -\u003e DispatchResult {\n\t\t// Filter for active subscriptions only\n\t\tfor (sub_id, sub) in\n\t\t\tSubscriptions::\u003cT\u003e::iter().filter(|(_, sub)| sub.state == SubscriptionState::Active)\n\t\t{\n\t\t\tif let Ok(msg) = Self::construct_randomness_xcm(sub.details.target.clone(), \u0026rnd) {\n\t\t\t\tlet versioned_target: Box\u003cVersionedLocation\u003e =\n\t\t\t\t\tBox::new(sub.details.target.clone().into());\n\t\t\t\tlet versioned_msg: Box\u003cVersionedXcm\u003c()\u003e\u003e =\n\t\t\t\t\tBox::new(xcm::VersionedXcm::V5(msg.into()));\n\t\t\t\tlet origin = frame_system::RawOrigin::Signed(Self::pallet_account_id());\n\t\t\t\tif T::Xcm::send(origin.into(), versioned_target, versioned_msg).is_ok() {\n\t\t\t\t\t// We consume a fixed one credit per distribution\n\t\t\t\t\tlet credits_consumed = One::one();\n\t\t\t\t\tSelf::collect_fees(\u0026sub, credits_consumed)?;\n\t\t\t\t\tSelf::consume_credits(\u0026sub_id, sub.clone(), credits_consumed);\n\t\t\t\t\tSelf::deposit_event(Event::RandomnessDistributed { sub_id });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOk(())\n\t}\n\n\tfn consume_credits(\n\t\tsub_id: \u0026SubscriptionId,\n\t\tmut sub: SubscriptionOf\u003cT\u003e,\n\t\tcredits_consumed: BlockNumberFor\u003cT\u003e,\n\t) {\n\t\t// Decrease credits_left by `credits_consumed` using saturating_sub\n\t\tsub.credits_left = sub.credits_left.saturating_sub(credits_consumed);\n\t\t// Update the subscription in storage\n\t\tSubscriptions::\u003cT\u003e::insert(sub_id, sub)\n\t}\n\n\tfn collect_fees(\n\t\tsub: \u0026SubscriptionOf\u003cT\u003e,\n\t\tcredits_consumed: BlockNumberFor\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tlet fees_to_collect = T::FeesManager::calculate_diff_fees(\n\t\t\t\u0026sub.credits_left,\n\t\t\t\u0026sub.credits_left.saturating_sub(credits_consumed),\n\t\t)\n\t\t.balance;\n\t\tlet fees = T::FeesManager::collect_fees(\u0026fees_to_collect, sub).map_err(|e| match e {\n\t\t\tFeesError::NotEnoughBalance { .. } =\u003e DispatchError::Other(\"NotEnoughBalance\"),\n\t\t\tFeesError::Other(de) =\u003e de,\n\t\t})?;\n\t\tSelf::deposit_event(Event::FeesCollected { sub_id: sub.id(), fees });\n\t\tOk(())\n\t}\n\n\t/// Internal function to handle subscription creation\n\tfn create_subscription_internal(\n\t\tsubscriber: T::AccountId,\n\t\tcredits: BlockNumberFor\u003cT\u003e,\n\t\ttarget: Location,\n\t\tfrequency: BlockNumberFor\u003cT\u003e,\n\t\tmetadata: Option\u003cMetadataOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\t// Calculate and hold the subscription fees\n\t\tlet fees = Self::calculate_subscription_fees(\u0026credits);\n\n\t\tSelf::hold_fees(\u0026subscriber, fees)?;\n\n\t\tlet current_block = frame_system::Pallet::\u003cT\u003e::block_number();\n\t\tlet details = SubscriptionDetails {\n\t\t\tsubscriber: subscriber.clone(),\n\t\t\ttarget: target.clone(),\n\t\t\tmetadata: metadata.unwrap_or_default(),\n\t\t};\n\t\tlet subscription = Subscription {\n\t\t\tstate: SubscriptionState::Active,\n\t\t\tcredits_left: credits,\n\t\t\tdetails,\n\t\t\tcreated_at: current_block,\n\t\t\tupdated_at: current_block,\n\t\t\tcredits,\n\t\t\tfrequency,\n\t\t};\n\n\t\tSelf::hold_deposit(\n\t\t\t\u0026subscriber,\n\t\t\tT::DepositCalculator::calculate_storage_deposit(\u0026subscription),\n\t\t)?;\n\n\t\tlet sub_id = subscription.id();\n\n\t\tensure!(!Subscriptions::\u003cT\u003e::contains_key(sub_id), Error::\u003cT\u003e::SubscriptionAlreadyExists);\n\n\t\tSubscriptions::\u003cT\u003e::insert(sub_id, subscription);\n\n\t\tSelf::deposit_event(Event::SubscriptionCreated { sub_id });\n\n\t\tOk(())\n\t}\n\n\tfn hold_fees(subscriber: \u0026T::AccountId, fees: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tT::Currency::hold(\u0026HoldReason::Fees.into(), subscriber, fees)\n\t}\n\n\tfn release_fees(subscriber: \u0026T::AccountId, fees: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tlet _ = T::Currency::release(\u0026HoldReason::Fees.into(), subscriber, fees, Precision::Exact)?;\n\t\tOk(())\n\t}\n\n\tfn manage_diff_fees(\n\t\tsubscriber: \u0026T::AccountId,\n\t\tdiff: \u0026DiffBalance\u003cBalanceOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\tmatch diff.direction {\n\t\t\tBalanceDirection::Collect =\u003e Self::hold_fees(subscriber, diff.balance),\n\t\t\tBalanceDirection::Release =\u003e Self::release_fees(subscriber, diff.balance),\n\t\t\tBalanceDirection::None =\u003e Ok(()),\n\t\t}\n\t}\n\n\tfn hold_deposit(subscriber: \u0026T::AccountId, deposit: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tT::Currency::hold(\u0026HoldReason::StorageDeposit.into(), subscriber, deposit)\n\t}\n\n\tfn release_deposit(subscriber: \u0026T::AccountId, deposit: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\tlet _ = T::Currency::release(\n\t\t\t\u0026HoldReason::StorageDeposit.into(),\n\t\t\tsubscriber,\n\t\t\tdeposit,\n\t\t\tPrecision::BestEffort,\n\t\t)?;\n\t\tOk(())\n\t}\n\n\tfn manage_diff_deposit(\n\t\tsubscriber: \u0026T::AccountId,\n\t\tdiff: \u0026DiffBalance\u003cBalanceOf\u003cT\u003e\u003e,\n\t) -\u003e DispatchResult {\n\t\tmatch diff.direction {\n\t\t\tBalanceDirection::Collect =\u003e Self::hold_deposit(subscriber, diff.balance),\n\t\t\tBalanceDirection::Release =\u003e Self::release_deposit(subscriber, diff.balance),\n\t\t\tBalanceDirection::None =\u003e Ok(()),\n\t\t}\n\t}\n\n\t/// Helper function to construct XCM message for randomness distribution\n\t// TODO: finish this off as part of https://github.com/ideal-lab5/idn-sdk/issues/77\n\tfn construct_randomness_xcm(_target: Location, _rnd: \u0026T::Rnd) -\u003e Result\u003cXcm\u003c()\u003e, Error\u003cT\u003e\u003e {\n\t\tOk(Xcm(vec![]))\n\t}\n\n\t/// Computes the fee for a given credits\n\tpub fn calculate_subscription_fees(credits: \u0026BlockNumberFor\u003cT\u003e) -\u003e BalanceOf\u003cT\u003e {\n\t\tT::FeesManager::calculate_subscription_fees(credits)\n\t}\n\n\t/// Retrieves a specific subscription\n\tpub fn get_subscription(sub_id: \u0026SubscriptionId) -\u003e Option\u003cSubscriptionOf\u003cT\u003e\u003e {\n\t\tSubscriptions::\u003cT\u003e::get(sub_id)\n\t}\n\n\t/// Retrieves all subscriptions for a specific subscriber\n\tpub fn get_subscriptions_for_subscriber(subscriber: \u0026T::AccountId) -\u003e Vec\u003cSubscriptionOf\u003cT\u003e\u003e {\n\t\tSubscriptions::\u003cT\u003e::iter()\n\t\t\t.filter(|(_, sub)| \u0026sub.details.subscriber == subscriber)\n\t\t\t.map(|(_, sub)| sub)\n\t\t\t.collect()\n\t}\n}\n\nimpl\u003cT: Config\u003e idn_traits::rand::Dispatcher\u003cT::Rnd, DispatchResult\u003e for Pallet\u003cT\u003e {\n\tfn dispatch(rnd: T::Rnd) -\u003e DispatchResult {\n\t\tPallet::\u003cT\u003e::distribute(rnd)\n\t}\n}\n\nsp_api::decl_runtime_apis! {\n\t#[api_version(1)]\n\tpub trait IdnManagerApi\u003cBalance, BlockNumber, Metadata, AccountId\u003e where\n\t\tBalance: Codec,\n\t\tBlockNumber: Codec + Unsigned,\n\t\tMetadata: Codec,\n\t\tAccountId: Codec,\n\t{\n\t\t/// Computes the fee for a given credits\n\t\t///\n\t\t/// See [`crate::Pallet::calculate_subscription_fees`]\n\t\tfn calculate_subscription_fees(\n\t\t\t// Number of random values to receive\n\t\t\tcredits: BlockNumber\n\t\t) -\u003e Balance;\n\n\t\t/// Retrieves a specific subscription\n\t\t///\n\t\t/// See [`crate::Pallet::get_subscription`]\n\t\tfn get_subscription(\n\t\t\t// Subscription ID\n\t\t\tsub_id: H256\n\t\t) -\u003e Option\u003cSubscription\u003c\n\t\t\t\tAccountId,\n\t\t\t\tBlockNumber,\n\t\t\t\tMetadata\n\t\t\t\u003e\u003e;\n\n\t\t/// Retrieves all subscriptions for a specific subscriber\n\t\t///\n\t\t/// See [`crate::Pallet::get_subscriptions_for_subscriber`]\n\t\tfn get_subscriptions_for_subscriber(\n\t\t\t// subscriber account ID\n\t\t\tsubscriber: AccountId\n\t\t) -\u003e Vec\u003cSubscription\u003c\n\t\t\t\tAccountId,\n\t\t\t\tBlockNumber,\n\t\t\t\tMetadata\n\t\t\t\u003e\u003e;\n\t}\n}\n","traces":[{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[4410640,4410512,4410490,4410448,4410560,4410513,4410573,4410706],"length":1,"stats":{"Line":6}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":2}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":2}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":376,"address":[],"length":0,"stats":{"Line":1}},{"line":377,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":1}},{"line":382,"address":[],"length":0,"stats":{"Line":1}},{"line":390,"address":[],"length":0,"stats":{"Line":1}},{"line":391,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[4385783,4385940,4384240],"length":1,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":434,"address":[],"length":0,"stats":{"Line":8}},{"line":435,"address":[],"length":0,"stats":{"Line":5}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":443,"address":[],"length":0,"stats":{"Line":2}},{"line":445,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":4}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":2}},{"line":455,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":465,"address":[],"length":0,"stats":{"Line":2}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[4386645,4386696],"length":1,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":97},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","fee_examples.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Fee Calculators Examples\n//!\n//! This module contains examples of fee calculators that can be used in the IDN Manager pallet.\n\nuse crate::traits::{BalanceDirection, DiffBalance, FeesManager};\nuse sp_runtime::traits::Zero;\nuse sp_std::cmp::Ordering;\n\n/// Linear fee calculator with no discount\npub struct LinearFeeCalculator;\n\nconst BASE_FEE: u32 = 100;\n\nimpl FeesManager\u003cu32, u32, (), (), ()\u003e for LinearFeeCalculator {\n\tfn calculate_subscription_fees(credits: \u0026u32) -\u003e u32 {\n\t\tBASE_FEE.saturating_mul(credits.clone().into())\n\t}\n\tfn calculate_diff_fees(old_credits: \u0026u32, new_credits: \u0026u32) -\u003e DiffBalance\u003cu32\u003e {\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_credits.cmp(\u0026old_credits) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tSelf::calculate_subscription_fees(\n\t\t\t\t\t\u0026new_credits.clone().saturating_sub(old_credits.clone()),\n\t\t\t\t)\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\tSelf::calculate_subscription_fees(\n\t\t\t\t\t\u0026old_credits.clone().saturating_sub(new_credits.clone()),\n\t\t\t\t)\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\tfn collect_fees(fees: \u0026u32, _: \u0026()) -\u003e Result\u003cu32, crate::traits::FeesError\u003cu32, ()\u003e\u003e {\n\t\t// In this case, we don't need to do anything with the fees, so we just return them\n\t\tOk(*fees)\n\t}\n}\n\n/// Tiered fee calculator with predefined discount tiers\npub struct SteppedTieredFeeCalculator;\n\nimpl FeesManager\u003cu32, u32, (), (), ()\u003e for SteppedTieredFeeCalculator {\n\tfn calculate_subscription_fees(credits: \u0026u32) -\u003e u32 {\n\t\t// Define tier boundaries and their respective discount rates (in basis points)\n\t\tconst TIERS: [(u32, u32); 5] = [\n\t\t\t(1, 0),        // 0-10: 0% discount\n\t\t\t(11, 500),     // 11-100: 5% discount\n\t\t\t(101, 1000),   // 101-1000: 10% discount\n\t\t\t(1001, 2000),  // 1001-10000: 20% discount\n\t\t\t(10001, 3000), // 10001+: 30% discount\n\t\t];\n\n\t\tlet mut total_fee = 0u32;\n\t\tlet mut remaining_credits = *credits;\n\n\t\tfor (i, \u0026(current_tier_start, current_tier_discount)) in TIERS.iter().enumerate() {\n\t\t\t// If no remaining credits exit loop.\n\t\t\tif remaining_credits == 0 {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet next_tier_start = TIERS.get(i + 1).map(|\u0026(start, _)| start).unwrap_or(u32::MAX);\n\t\t\tlet credits_in_tier =\n\t\t\t\t(credits.min(\u0026next_tier_start.saturating_sub(1)) - current_tier_start + 1)\n\t\t\t\t\t.min(remaining_credits);\n\n\t\t\tlet tier_fee = BASE_FEE\n\t\t\t\t.saturating_mul(credits_in_tier)\n\t\t\t\t.saturating_mul((10_000 - current_tier_discount) as u32)\n\t\t\t\t.saturating_div(10_000);\n\n\t\t\ttotal_fee = total_fee.saturating_add(tier_fee);\n\t\t\tremaining_credits = remaining_credits.saturating_sub(credits_in_tier);\n\t\t}\n\n\t\ttotal_fee\n\t}\n\n\tfn calculate_diff_fees(old_credits: \u0026u32, new_credits: \u0026u32) -\u003e DiffBalance\u003cu32\u003e {\n\t\tlet old_fees = Self::calculate_subscription_fees(old_credits);\n\t\tlet new_fees = Self::calculate_subscription_fees(new_credits);\n\t\tlet mut direction = BalanceDirection::None;\n\t\tlet fees = match new_fees.cmp(\u0026old_fees) {\n\t\t\tOrdering::Greater =\u003e {\n\t\t\t\tdirection = BalanceDirection::Collect;\n\t\t\t\tnew_fees - old_fees\n\t\t\t},\n\t\t\tOrdering::Less =\u003e {\n\t\t\t\tdirection = BalanceDirection::Release;\n\t\t\t\told_fees - new_fees\n\t\t\t},\n\t\t\tOrdering::Equal =\u003e Zero::zero(),\n\t\t};\n\t\tDiffBalance { balance: fees, direction }\n\t}\n\tfn collect_fees(fees: \u0026u32, _: \u0026()) -\u003e Result\u003cu32, crate::traits::FeesError\u003cu32, ()\u003e\u003e {\n\t\t// In this case, we don't need to do anything with the fees, so we just return them\n\t\tOk(*fees)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn test_linear_fee_calculator() {\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u00261), 100);\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u002610), 1_000);\n\t\tassert_eq!(LinearFeeCalculator::calculate_subscription_fees(\u0026100), 10_000);\n\t}\n\n\t/// Thest when a subscription is fully used before being killed or the update does not change\n\t/// the credits.\n\t#[test]\n\tfn test_calculate_release_linear_fees_no_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 50; // no credits diff\n\t\tlet refund = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\t// there should be no refund as all credit has been used, or no difference in the update\n\t\tlet expected = 0;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::None },\n\t\t\t\"There should be no release when no diff in credits\"\n\t\t);\n\t}\n\n\t/// Test when a subscription is reduced or killed.\n\t#[test]\n\tfn test_calculate_release_linear_fees_lower_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 30; // 20 credits used\n\t\tlet refund = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 20 * BASE_FEE;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Release },\n\t\t\t\"There should be a release when new credits is lower than old credits\"\n\t\t);\n\t}\n\n\t/// Test when the subscription is extended.\n\t#[test]\n\tfn test_calculate_hold_linear_fees_greater_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 60; // all credits used\n\t\tlet hold = LinearFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 10 * BASE_FEE;\n\t\tassert_eq!(\n\t\t\thold,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Collect },\n\t\t\t\"There should be more held balance\"\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_stepped_tiered_calculator() {\n\t\t// Test first tier (no discount)\n\t\tassert_eq!(SteppedTieredFeeCalculator::calculate_subscription_fees(\u002610), 1_000); // 10 * 100 = 1,000\n\n\t\t// Test crossing into second tier\n\t\tlet fee_11 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002611);\n\t\tassert_eq!(fee_11, 1_095); // (10 * 100) + (1 * 95) = 1,000 + 95 = 1,095\n\n\t\t// Test middle of second tier\n\t\tlet fee_50 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002650);\n\t\tassert_eq!(fee_50, 4_800); // (10 * 100) + (40 * 95) = 1,000 + 3,800 = 4,800\n\n\t\t// Test edge of second tier\n\t\tlet fee_100 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026100);\n\t\tassert_eq!(fee_100, 9550); // (10 * 100) + (90 * 95) = 1,000 + 8,550 = 9,550\n\n\t\t// Test edge of second tier\n\t\tlet fee_101 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026101);\n\t\tassert_eq!(fee_101, 9_640); // (10 * 100) + (90 * 95) + (1 * 90)= 1,000 + 8,550 + 90 = 9,640\n\n\t\t// Test crossing multiple tiers\n\t\tlet fee_150 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026150);\n\t\t// First 10 at 100% = 1,000\n\t\t// Next 90 at 95% = 8,550\n\t\t// Next 50 at 90% = 4,500\n\t\t// Total should be 14,050\n\t\tassert_eq!(fee_150, 14_050);\n\t}\n\n\t#[test]\n\tfn test_no_price_inversion() {\n\t\t// Test that buying more never costs less\n\t\tlet fee_10 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002610);\n\t\tlet fee_11 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u002611);\n\t\tassert!(fee_11 \u003e fee_10, \"11 credits should cost more than 10 credits\");\n\n\t\t// Test around the 100 credit boundary\n\t\tlet fee_100 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026100);\n\t\tlet fee_101 = SteppedTieredFeeCalculator::calculate_subscription_fees(\u0026101);\n\t\tassert!(fee_101 \u003e fee_100, \"101 credits should cost more than 100 credits\");\n\t}\n\n\t/// Thest when a subscription is fully used before being killed or the update does not change\n\t/// the credits.\n\t#[test]\n\tfn test_calculate_release_stepped_fees_no_diff() {\n\t\tlet old_credits: u32 = 50;\n\t\tlet new_credits: u32 = 50; // no credits diff\n\t\tlet refund = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 0;\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::None },\n\t\t\t\"There should be no release when no diff in credits\"\n\t\t);\n\t}\n\n\t/// Test for a partial usage scenario.\n\t#[test]\n\tfn test_calculate_release_stepped_fees_lower_diff() {\n\t\tlet old_credits: u32 = 110;\n\t\tlet new_credits: u32 = 100; // 1 value decrease\n\t\tlet refund = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 10 * BASE_FEE.saturating_mul(9_000).saturating_div(10_000); // 10% discount on the extra value\n\t\tassert_eq!(\n\t\t\trefund,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Release },\n\t\t\t\"There should be a release when new credits is lower than old credits\"\n\t\t);\n\t}\n\n\t/// Test when the subscription is fully used.\n\t#[test]\n\tfn test_calculate_hold_stepped_fees_greater_diff() {\n\t\tlet old_credits: u32 = 100;\n\t\tlet new_credits: u32 = 101; // 1 value increase\n\t\tlet hold = SteppedTieredFeeCalculator::calculate_diff_fees(\u0026old_credits, \u0026new_credits);\n\t\tlet expected = 1 * BASE_FEE.saturating_mul(9_000).saturating_div(10_000); // 10% discount on the extra value\n\t\tassert_eq!(\n\t\t\thold,\n\t\t\tDiffBalance { balance: expected, direction: BalanceDirection::Collect },\n\t\t\t\"There should be more held balance\"\n\t\t);\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","mock.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Mock runtime\n//!\n//! This file is a mock runtime for the pallet. It is used to test the pallet in a test environment.\n//! It does not contain any tests.\n\nuse crate::{\n\tself as pallet_idn_manager,\n\timpls::{DepositCalculatorImpl, FeesManagerImpl},\n\tSubscriptionOf,\n};\nuse frame_support::{\n\tconstruct_runtime, derive_impl, parameter_types, sp_runtime::BuildStorage, traits::Get,\n};\nuse frame_system as system;\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::IdentityLookup, AccountId32};\n\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\nconstruct_runtime!(\n\tpub enum Test\n\t{\n\t\tSystem: frame_system,\n\t\tIdnManager: pallet_idn_manager,\n\t\tBalances: pallet_balances,\n\t}\n);\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype Block = Block;\n\ttype AccountId = AccountId32;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype AccountData = pallet_balances::AccountData\u003cu64\u003e;\n}\n\n#[derive_impl(pallet_balances::config_preludes::TestDefaultConfig)]\nimpl pallet_balances::Config for Test {\n\ttype AccountStore = System;\n}\n\nparameter_types! {\n\tpub const MaxSubscriptionDuration: u64 = 100;\n\tpub const PalletId: frame_support::PalletId = frame_support::PalletId(*b\"idn_mngr\");\n\tpub const TreasuryAccount: AccountId32 = AccountId32::new([123u8; 32]);\n\tpub const BaseFee: u64 = 10;\n\tpub const SDMultiplier: u64 = 10;\n}\n\n#[derive(TypeInfo)]\npub struct SubMetadataLen;\n\nimpl Get\u003cu32\u003e for SubMetadataLen {\n\tfn get() -\u003e u32 {\n\t\t8\n\t}\n}\n\nimpl pallet_idn_manager::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype FeesManager = FeesManagerImpl\u003cTreasuryAccount, BaseFee, SubscriptionOf\u003cTest\u003e, Balances\u003e;\n\ttype DepositCalculator = DepositCalculatorImpl\u003cSDMultiplier, u64\u003e;\n\ttype PalletId = PalletId;\n\ttype RuntimeHoldReason = RuntimeHoldReason;\n\ttype Rnd = [u8; 32];\n\ttype WeightInfo = ();\n\ttype Xcm = ();\n\ttype SubMetadataLen = SubMetadataLen;\n}\n\npub struct ExtBuilder;\n\nimpl ExtBuilder {\n\tpub fn build() -\u003e sp_io::TestExternalities {\n\t\tlet storage = system::GenesisConfig::\u003cTest\u003e::default().build_storage().unwrap();\n\t\tlet mut ext = sp_io::TestExternalities::new(storage);\n\t\text.execute_with(|| System::set_block_number(1));\n\t\text\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests","pallet.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Tests for the IDN Manager pallet\n\nuse crate::{\n\ttests::mock::{Balances, ExtBuilder, Test, *},\n\ttraits::{BalanceDirection, DepositCalculator, DiffBalance, FeesManager},\n\tConfig, Error, Event, HoldReason, SubscriptionState, Subscriptions,\n};\nuse frame_support::{\n\tassert_noop, assert_ok,\n\tpallet_prelude::Zero,\n\ttraits::{\n\t\tfungible::{InspectHold, Mutate},\n\t\tOnFinalize,\n\t},\n\tBoundedVec,\n};\nuse idn_traits::rand::Dispatcher;\nuse sp_core::H256;\nuse sp_runtime::{AccountId32, DispatchError, TokenError};\nuse xcm::v5::{Junction, Location};\n\nconst ALICE: AccountId32 = AccountId32::new([1u8; 32]);\nconst BOB: AccountId32 = AccountId32::new([2u8; 32]);\n\nfn event_not_emitted(event: Event\u003cTest\u003e) -\u003e bool {\n\t!System::events().iter().any(|record| {\n\t\tif let RuntimeEvent::IdnManager(ref e) = \u0026record.event {\n\t\t\te == \u0026event\n\t\t} else {\n\t\t\tfalse\n\t\t}\n\t})\n}\n\nfn update_subscription(\n\tsubscriber: AccountId32,\n\toriginal_credits: u64,\n\toriginal_frequency: u64,\n\tnew_credits: u64,\n\tnew_frequency: u64,\n) {\n\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\tlet metadata = None;\n\tlet initial_balance = 99_990_000_000_000_000;\n\n\t\u003cTest as Config\u003e::Currency::set_balance(\u0026subscriber, initial_balance);\n\n\tassert_ok!(IdnManager::create_subscription(\n\t\tRuntimeOrigin::signed(subscriber.clone()),\n\t\toriginal_credits,\n\t\ttarget.clone(),\n\t\toriginal_frequency,\n\t\tmetadata.clone()\n\t));\n\n\t// Get the sub_id from the last emitted event\n\tlet sub_id = System::events()\n\t\t.iter()\n\t\t.rev()\n\t\t.find_map(|record| {\n\t\t\tif let RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id }) =\n\t\t\t\t\u0026record.event\n\t\t\t{\n\t\t\t\tSome(*sub_id)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t})\n\t\t.expect(\"SubscriptionCreated event should be emitted\");\n\n\tlet subscription = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\n\tassert_eq!(subscription.created_at, System::block_number());\n\tassert_eq!(subscription.updated_at, System::block_number());\n\n\tassert_eq!(subscription.details.subscriber, subscriber);\n\n\tlet original_fees =\n\t\t\u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026original_credits);\n\tlet original_deposit =\n\t\t\u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\tlet balance_after_create = initial_balance - original_fees - original_deposit;\n\n\t// assert correct balance on subscriber after creating subscription\n\tassert_eq!(Balances::free_balance(\u0026subscriber), balance_after_create);\n\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026subscriber), original_fees);\n\tassert_eq!(\n\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026subscriber),\n\t\toriginal_deposit\n\t);\n\n\t// Advance a block\n\tSystem::set_block_number(System::block_number() + 1);\n\n\tassert_ok!(IdnManager::update_subscription(\n\t\tRuntimeOrigin::signed(subscriber.clone()),\n\t\tsub_id,\n\t\tnew_credits,\n\t\tnew_frequency\n\t));\n\n\tlet new_fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026new_credits);\n\tlet new_deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\n\tlet fees_diff: i64 = new_fees as i64 - original_fees as i64;\n\n\tlet deposit_diff: i64 = new_deposit as i64 - original_deposit as i64;\n\n\t// We are using fixed-width integer types for credits and frequency, so Subscription objects\n\t// can't change in size with this mock. Unit tests are in place insted to ensure the correct\n\t// behaviour in case of other types used.\n\tassert!(deposit_diff.is_zero());\n\n\tlet balance_after_update: u64 =\n\t\t(balance_after_create as i64 - fees_diff - deposit_diff).try_into().unwrap();\n\n\t// assert fees and deposit diff is correctly handled\n\tassert_eq!(Balances::free_balance(\u0026subscriber), balance_after_update);\n\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026subscriber), new_fees);\n\tassert_eq!(\n\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026subscriber),\n\t\tnew_deposit\n\t);\n\tassert_eq!(balance_after_update + new_fees + new_deposit, initial_balance);\n\n\tlet subscription = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\n\tassert_eq!(subscription.created_at, System::block_number() - 1);\n\tassert_eq!(subscription.updated_at, System::block_number());\n\n\t// assert subscription details has been updated\n\tassert_eq!(subscription.credits, new_credits);\n\tassert_eq!(subscription.frequency, new_frequency);\n\n\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionUpdated {\n\t\tsub_id,\n\t}));\n}\n\n#[test]\nfn create_subscription_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// assert Subscriptions storage map is empty before creating a subscription\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 0);\n\n\t\t// assert that the subscription has been created\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 1);\n\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// assert that the correct fees have been held\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\n\t\t// assert that the subscription details are correct\n\t\tassert_eq!(subscription.details.subscriber, ALICE);\n\t\tassert_eq!(subscription.credits, credits);\n\t\tassert_eq!(subscription.details.target, target);\n\t\tassert_eq!(subscription.frequency, frequency);\n\t\tassert_eq!(\n\t\t\tsubscription.details.metadata,\n\t\t\tBoundedVec::\u003cu8, SubMetadataLen\u003e::try_from(vec![]).unwrap()\n\t\t);\n\n\t\t// assert that the correct event has been emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn create_subscription_fails_if_insufficient_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::create_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tcredits,\n\t\t\t\ttarget,\n\t\t\t\tfrequency,\n\t\t\t\tNone\n\t\t\t),\n\t\t\tTokenError::FundsUnavailable\n\t\t);\n\n\t\t// Assert the SubscriptionCreated event was not emitted\n\t\tassert!(!System::events().iter().any(|record| matches!(\n\t\t\trecord.event,\n\t\t\tRuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id: _ })\n\t\t)));\n\t});\n}\n\n#[test]\nfn create_subscription_fails_if_sub_already_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// erase all events\n\t\tSystem::reset_events();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::create_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tcredits,\n\t\t\t\ttarget,\n\t\t\t\tfrequency,\n\t\t\t\tNone\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyExists\n\t\t);\n\n\t\t// Assert the SubscriptionCreated event was not emitted\n\t\tassert!(!System::events().iter().any(|record| matches!(\n\t\t\trecord.event,\n\t\t\tRuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionCreated { sub_id: _ })\n\t\t)));\n\t});\n}\n\n#[test]\n// Todo: https://github.com/ideal-lab5/idn-sdk/issues/77\n// assert event RandomnessDistributed is emitted\n#[ignore]\nfn distribute_randomness_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tlet rnd = [0; 32];\n\n\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::iter().count(), 1, \"Subscriptions count is not 1\");\n\n\t\tlet (_sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_eq!(subscription.state, SubscriptionState::Active, \"Subscription is not Active\");\n\t});\n}\n\n#[test]\nfn test_kill_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// assert that the correct fees have been held\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\t\tassert_ok!(IdnManager::kill_subscription(RuntimeOrigin::signed(ALICE), sub_id));\n\t\tassert!(Subscriptions::\u003cTest\u003e::get(sub_id).is_none());\n\n\t\t// assert remaining fees and balance refunded\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0u64);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0u64);\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn kill_subscription_fails_if_sub_does_not_exist() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::kill_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionRemoved event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionRemoved { sub_id }));\n\t});\n}\n\n#[test]\nfn on_finalize_removes_zero_credit_subscriptions() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup - Create a subscription\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get the subscription ID\n\t\tlet (sub_id, mut subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet deposit = \u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees - deposit);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), deposit);\n\n\t\t// Manually set credits to zero\n\t\tsubscription.credits_left = Zero::zero();\n\t\tSubscriptions::\u003cTest\u003e::insert(sub_id, subscription);\n\n\t\t// Verify subscription exists before on_finalize\n\t\tassert!(Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Call on_finalize directly\n\t\tlet current_block = System::block_number();\n\t\tcrate::Pallet::\u003cTest\u003e::on_finalize(current_block);\n\n\t\t// Verify subscription was removed\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// assert there are no remaining fees and balance refunded\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - fees);\n\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0u64);\n\n\t\t// Verify event was emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn test_update_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tstruct SubParams {\n\t\t\tcredits: u64,\n\t\t\tfrequency: u64,\n\t\t}\n\t\tstruct SubUpdate {\n\t\t\told: SubParams,\n\t\t\tnew: SubParams,\n\t\t}\n\n\t\tlet updates: Vec\u003cSubUpdate\u003e = vec![\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 10, frequency: 2 },\n\t\t\t\tnew: SubParams { credits: 20, frequency: 4 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 20 },\n\t\t\t\tnew: SubParams { credits: 20, frequency: 4 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 20 },\n\t\t\t\tnew: SubParams { credits: 100, frequency: 20 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 100, frequency: 1 },\n\t\t\t\tnew: SubParams { credits: 9_999_999_999_999, frequency: 1 },\n\t\t\t},\n\t\t\tSubUpdate {\n\t\t\t\told: SubParams { credits: 9_999_999_999_999, frequency: 1 },\n\t\t\t\tnew: SubParams { credits: 100, frequency: 1 },\n\t\t\t},\n\t\t];\n\t\tfor i in 0..updates.len() {\n\t\t\tlet update = \u0026updates[i];\n\t\t\tupdate_subscription(\n\t\t\t\tAccountId32::new([i.try_into().unwrap(); 32]),\n\t\t\t\tupdate.old.credits,\n\t\t\t\tupdate.old.frequency,\n\t\t\t\tupdate.new.credits,\n\t\t\t\tupdate.new.frequency,\n\t\t\t);\n\t\t}\n\t});\n}\n\n#[test]\nfn update_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\t\tlet new_credits = 20;\n\t\tlet new_frequency = 4;\n\n\t\tassert_noop!(\n\t\t\tIdnManager::update_subscription(\n\t\t\t\tRuntimeOrigin::signed(ALICE),\n\t\t\t\tsub_id,\n\t\t\t\tnew_credits,\n\t\t\t\tnew_frequency\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionUpdated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionUpdated { sub_id }));\n\t});\n}\n\n#[test]\n/// This test makes sure that the correct fees are collected, by consuming credits one by one.\nfn test_credits_consumption_and_cleanup() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup initial conditions\n\t\tlet credits: u64 = 1010;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 3;\n\t\tlet initial_balance = 10_000_000;\n\t\tlet mut treasury_balance = 0;\n\t\tlet rnd = [0u8; 32];\n\n\t\t// Set up account\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026TreasuryAccount::get(), treasury_balance);\n\n\t\t// Create subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get subscription details\n\t\tlet (sub_id, subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\t\tlet initial_fees = \u003cTest as Config\u003e::FeesManager::calculate_subscription_fees(\u0026credits);\n\t\tlet storage_deposit =\n\t\t\t\u003cTest as Config\u003e::DepositCalculator::calculate_storage_deposit(\u0026subscription);\n\n\t\t// Verify initial state\n\t\tassert_eq!(\n\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\tinitial_balance - initial_fees - storage_deposit\n\t\t);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), initial_fees);\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\tstorage_deposit\n\t\t);\n\t\tassert_eq!(subscription.credits_left, credits);\n\n\t\t// Consume credits one by one\n\t\tfor i in 0..credits {\n\t\t\t// Advance block and run hooks\n\t\t\tSystem::set_block_number(System::block_number() + 1);\n\n\t\t\t// Dispatch randomness\n\t\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\n\t\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(\n\t\t\t\tEvent::\u003cTest\u003e::RandomnessDistributed { sub_id },\n\t\t\t));\n\n\t\t\t// Verify credit consumption\n\t\t\tlet sub = Subscriptions::\u003cTest\u003e::get(sub_id).unwrap();\n\t\t\tassert_eq!(sub.credits_left, credits - i - 1, \"Credit not consumed correctly\");\n\n\t\t\t// Verify fees movement to treasury\n\t\t\tlet fees = \u003cTest as Config\u003e::FeesManager::calculate_diff_fees(\n\t\t\t\t\u0026(credits - i),\n\t\t\t\t\u0026(credits - i - 1),\n\t\t\t)\n\t\t\t.balance;\n\n\t\t\ttreasury_balance += fees;\n\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(\u0026TreasuryAccount::get()),\n\t\t\t\ttreasury_balance,\n\t\t\t\t\"Fees not moved to treasury correctly\"\n\t\t\t);\n\n\t\t\tSystem::assert_has_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::FeesCollected {\n\t\t\t\tsub_id,\n\t\t\t\tfees,\n\t\t\t}));\n\n\t\t\t// assert balance has been collected from the hold\n\t\t\tassert_eq!(\n\t\t\t\tBalances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE),\n\t\t\t\tinitial_fees - treasury_balance\n\t\t\t);\n\n\t\t\t// assert free balance is still correct\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\t\tinitial_balance - initial_fees - storage_deposit\n\t\t\t);\n\n\t\t\t// finalize block\n\t\t\tIdnManager::on_finalize(System::block_number());\n\t\t}\n\n\t\t// Verify subscription is removed after last credit\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Verify final balances\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - initial_fees);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0);\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\tassert_eq!(Balances::free_balance(\u0026TreasuryAccount::get()), initial_fees);\n\n\t\t// Verify events\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn test_credits_consumption_not_enogh_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Setup initial conditions\n\t\tlet credits: u64 = 1010;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 3;\n\t\tlet initial_balance = 10_000_000;\n\t\tlet rnd = [0u8; 32];\n\n\t\t// Set up account\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Create subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Get subscription details\n\t\tlet (_, sub) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Consume credits one by one\n\t\tfor i in 0..credits {\n\t\t\t// Advance block and run hooks\n\t\t\tSystem::set_block_number(System::block_number() + 1);\n\n\t\t\tif i == 505 {\n\t\t\t\t// let's fake an incorrect fees collection at some arbitrary point\n\t\t\t\tlet _ = \u003cTest as Config\u003e::FeesManager::collect_fees(\n\t\t\t\t\t\u0026Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE),\n\t\t\t\t\t\u0026sub,\n\t\t\t\t);\n\t\t\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::Fees.into(), \u0026ALICE), 0);\n\t\t\t\tassert_noop!(\n\t\t\t\t\tIdnManager::dispatch(rnd.into()),\n\t\t\t\t\tDispatchError::Other(\"NotEnoughBalance\")\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Dispatch randomness\n\t\t\t\tassert_ok!(IdnManager::dispatch(rnd.into()));\n\t\t\t}\n\n\t\t\t// finalize block\n\t\t\tIdnManager::on_finalize(System::block_number());\n\t\t}\n\t});\n}\n\n#[test]\nfn test_pause_reactivate_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet free_balance = Balances::free_balance(\u0026ALICE);\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Test pause and reactivate subscription\n\t\tassert_ok!(IdnManager::pause_subscription(RuntimeOrigin::signed(ALICE.clone()), sub_id));\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionPaused {\n\t\t\tsub_id,\n\t\t}));\n\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::get(sub_id).unwrap().state, SubscriptionState::Paused);\n\t\tassert_ok!(IdnManager::reactivate_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tsub_id\n\t\t));\n\t\tassert_eq!(Subscriptions::\u003cTest\u003e::get(sub_id).unwrap().state, SubscriptionState::Active);\n\n\t\t// Assert current free balance is the same as the free balance before pausing and\n\t\t// reactivating\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), free_balance);\n\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(\n\t\t\tEvent::\u003cTest\u003e::SubscriptionReactivated { sub_id },\n\t\t));\n\t});\n}\n\n#[test]\nfn pause_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\t});\n}\n\n#[test]\nfn pause_subscription_fails_if_sub_already_paused() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_ok!(IdnManager::pause_subscription(RuntimeOrigin::signed(ALICE.clone()), sub_id));\n\n\t\t// erase all events\n\t\tSystem::reset_events();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyPaused\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\t});\n}\n\n#[test]\nfn reactivate_subscription_fails_if_sub_does_not_exists() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet sub_id = H256::from_slice(\u0026[1; 32]);\n\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionDoesNotExist\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn reactivate_subscriptio_fails_if_sub_already_active() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits = 10;\n\t\tlet frequency = 2;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet metadata = None;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(ALICE), sub_id),\n\t\t\tError::\u003cTest\u003e::SubscriptionAlreadyActive\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn operations_fail_if_origin_is_not_the_subscriber() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet metadata = None;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t// Set balance for Alice and Bob\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026BOB, initial_balance);\n\n\t\t// Create subscription for Alice\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tmetadata.clone()\n\t\t));\n\n\t\t// Retrieve the subscription ID created\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Attempt to kill the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::kill_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// assert subscription still exists\n\t\tassert!(Subscriptions::\u003cTest\u003e::get(sub_id).is_some());\n\n\t\t// Assert the SubscriptionRemoved event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionRemoved { sub_id }));\n\n\t\t// Attempt to pause the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::pause_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Assert the SubscriptionPaused event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionPaused { sub_id }));\n\n\t\t// Attempt to update the subscription using Bob's origin (should fail)\n\t\tlet new_credits = credits + 10;\n\t\tlet new_frequency = frequency + 1;\n\t\tassert_noop!(\n\t\t\tIdnManager::update_subscription(\n\t\t\t\tRuntimeOrigin::signed(BOB.clone()),\n\t\t\t\tsub_id,\n\t\t\t\tnew_credits,\n\t\t\t\tnew_frequency\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Attempt to reactivate the subscription using Bob's origin (should fail)\n\t\tassert_noop!(\n\t\t\tIdnManager::reactivate_subscription(RuntimeOrigin::signed(BOB.clone()), sub_id),\n\t\t\tError::\u003cTest\u003e::NotSubscriber\n\t\t);\n\n\t\t// Assert the SubscriptionReactivated event was not emitted\n\t\tassert!(event_not_emitted(Event::\u003cTest\u003e::SubscriptionReactivated { sub_id }));\n\t});\n}\n\n#[test]\nfn test_on_finalize_removes_finished_subscriptions() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\t\tlet initial_balance = 10_000_000;\n\n\t\t// Create subscription\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\tlet (sub_id, mut subscription) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Manually set credits to zero to simulate a finished subscription\n\t\tsubscription.credits_left = Zero::zero();\n\t\tSubscriptions::\u003cTest\u003e::insert(sub_id, subscription);\n\n\t\t// Before on_finalize, subscription should exist\n\t\tassert!(Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// Call on_finalize\n\t\tcrate::Pallet::\u003cTest\u003e::on_finalize(System::block_number());\n\n\t\t// After on_finalize:\n\t\t// 1. Subscription should be removed\n\t\tassert!(!Subscriptions::\u003cTest\u003e::contains_key(sub_id));\n\n\t\t// 2. SubscriptionRemoved event should be emitted\n\t\tSystem::assert_last_event(RuntimeEvent::IdnManager(Event::\u003cTest\u003e::SubscriptionRemoved {\n\t\t\tsub_id,\n\t\t}));\n\t});\n}\n\n#[test]\nfn hold_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account with initial balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Hold deposit\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Verify deposit is held\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\tdeposit_credits\n\t\t);\n\t\t// Verify free balance is reduced\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance - deposit_credits);\n\t});\n}\n\n#[test]\nfn release_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account and hold deposit\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Release deposit\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::release_deposit(\u0026ALICE, deposit_credits));\n\n\t\t// Verify deposit is released\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\t// Verify free balance is restored\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t});\n}\n\n#[test]\nfn manage_diff_deposit_works() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 10_000_000;\n\t\tlet original_deposit = 1_000;\n\t\tlet additional_deposit = 1_500;\n\t\tlet excess_deposit = 500;\n\n\t\t// Setup account with initial balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Test holding deposit\n\t\tlet hold_diff =\n\t\t\tDiffBalance { balance: original_deposit, direction: BalanceDirection::Collect };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026hold_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit\n\t\t);\n\t\t// Test holding additional deposit\n\t\tlet hold_diff =\n\t\t\tDiffBalance { balance: additional_deposit, direction: BalanceDirection::Collect };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026hold_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit + additional_deposit\n\t\t);\n\n\t\t// Test releasing excess deposit\n\t\tlet release_diff =\n\t\t\tDiffBalance { balance: excess_deposit, direction: BalanceDirection::Release };\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026release_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\toriginal_deposit + additional_deposit - excess_deposit\n\t\t);\n\n\t\t// Test no change in deposit\n\t\tlet no_change_diff = DiffBalance { balance: 0, direction: BalanceDirection::None };\n\t\tlet held_before = Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE);\n\t\tassert_ok!(crate::Pallet::\u003cTest\u003e::manage_diff_deposit(\u0026ALICE, \u0026no_change_diff));\n\t\tassert_eq!(\n\t\t\tBalances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE),\n\t\t\theld_before\n\t\t);\n\n\t\t// assert free balance\n\t\tassert_eq!(\n\t\t\tBalances::free_balance(\u0026ALICE),\n\t\t\tinitial_balance - original_deposit - additional_deposit + excess_deposit\n\t\t);\n\t});\n}\n\n#[test]\nfn hold_deposit_fails_with_insufficient_balance() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet initial_balance = 500;\n\t\tlet deposit_credits = 1_000;\n\n\t\t// Setup account with insufficient balance\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, initial_balance);\n\n\t\t// Attempt to hold deposit should fail\n\t\tassert_noop!(\n\t\t\tcrate::Pallet::\u003cTest\u003e::hold_deposit(\u0026ALICE, deposit_credits),\n\t\t\tTokenError::FundsUnavailable\n\t\t);\n\n\t\t// Verify no deposit is held\n\t\tassert_eq!(Balances::balance_on_hold(\u0026HoldReason::StorageDeposit.into(), \u0026ALICE), 0);\n\t\t// Verify balance remains unchanged\n\t\tassert_eq!(Balances::free_balance(\u0026ALICE), initial_balance);\n\t});\n}\n\n#[test]\nfn test_calculate_subscription_fees() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Test with different credit amounts\n\t\tlet test_cases = vec![\n\t\t\t(0, 0),     // Zero credits\n\t\t\t(1, 100),   // One credit (base fee)\n\t\t\t(10, 1000), // Ten credits\n\t\t\t(50, 4800), // Fifty credits, 5% discount over 10\n\t\t\t(1000, 90550),\n\t\t\t(1001, 90630),\n\t\t];\n\n\t\tfor (credits, expected_fee) in test_cases {\n\t\t\tlet fee = IdnManager::calculate_subscription_fees(\u0026credits);\n\t\t\tassert_eq!(\n\t\t\t\tfee, expected_fee,\n\t\t\t\t\"Fee calculation incorrect for {} credits, expected {}, got {}\",\n\t\t\t\tcredits, expected_fee, fee\n\t\t\t);\n\t\t}\n\t});\n}\n\n#[test]\nfn test_get_subscription() {\n\tExtBuilder::build().execute_with(|| {\n\t\tlet credits: u64 = 50;\n\t\tlet target = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet frequency: u64 = 10;\n\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\n\t\t// Create a subscription\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\tcredits,\n\t\t\ttarget.clone(),\n\t\t\tfrequency,\n\t\t\tNone\n\t\t));\n\n\t\t// Retrieve the subscription ID created\n\t\tlet (sub_id, _) = Subscriptions::\u003cTest\u003e::iter().next().unwrap();\n\n\t\t// Test get_subscription with valid ID\n\t\tlet subscription = IdnManager::get_subscription(\u0026sub_id);\n\t\tassert!(subscription.is_some(), \"Subscription should exist\");\n\n\t\tlet sub = subscription.unwrap();\n\t\tassert_eq!(sub.details.subscriber, ALICE);\n\t\tassert_eq!(sub.credits, credits);\n\t\tassert_eq!(sub.frequency, frequency);\n\t\tassert_eq!(sub.details.target, target);\n\n\t\t// Test get_subscription with invalid ID\n\t\tlet invalid_sub_id = H256::from_slice(\u0026[0xff; 32]);\n\t\tlet invalid_subscription = IdnManager::get_subscription(\u0026invalid_sub_id);\n\t\tassert!(invalid_subscription.is_none(), \"Invalid subscription ID should return None\");\n\t});\n}\n\n#[test]\nfn test_get_subscriptions_for_subscriber() {\n\tExtBuilder::build().execute_with(|| {\n\t\t// Set up accounts\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026ALICE, 10_000_000);\n\t\t\u003cTest as Config\u003e::Currency::set_balance(\u0026BOB, 10_000_000);\n\n\t\t// Create subscriptions for ALICE\n\t\tlet target1 = Location::new(1, [Junction::PalletInstance(1)]);\n\t\tlet target2 = Location::new(1, [Junction::PalletInstance(2)]);\n\t\tlet target3 = Location::new(1, [Junction::PalletInstance(3)]);\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\t50,\n\t\t\ttarget1.clone(),\n\t\t\t10,\n\t\t\tNone\n\t\t));\n\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(ALICE.clone()),\n\t\t\t100,\n\t\t\ttarget2.clone(),\n\t\t\t20,\n\t\t\tNone\n\t\t));\n\n\t\t// Create a subscription for BOB\n\t\tassert_ok!(IdnManager::create_subscription(\n\t\t\tRuntimeOrigin::signed(BOB.clone()),\n\t\t\t75,\n\t\t\ttarget3.clone(),\n\t\t\t15,\n\t\t\tNone\n\t\t));\n\n\t\t// Test get_subscriptions_for_subscriber with ALICE\n\t\tlet alice_subs = IdnManager::get_subscriptions_for_subscriber(\u0026ALICE);\n\t\tassert_eq!(alice_subs.len(), 2, \"ALICE should have 2 subscriptions\");\n\n\t\t// Verify subscription details\n\t\tlet has_sub1 = alice_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == ALICE \u0026\u0026\n\t\t\t\tsub.credits == 50 \u0026\u0026\n\t\t\t\tsub.frequency == 10 \u0026\u0026\n\t\t\t\tsub.details.target == target1\n\t\t});\n\n\t\tlet has_sub2 = alice_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == ALICE \u0026\u0026\n\t\t\t\tsub.credits == 100 \u0026\u0026\n\t\t\t\tsub.frequency == 20 \u0026\u0026\n\t\t\t\tsub.details.target == target2\n\t\t});\n\n\t\tassert!(has_sub1, \"ALICE's first subscription not found\");\n\t\tassert!(has_sub2, \"ALICE's second subscription not found\");\n\n\t\t// Test get_subscriptions_for_subscriber with BOB\n\t\tlet bob_subs = IdnManager::get_subscriptions_for_subscriber(\u0026BOB);\n\t\tassert_eq!(bob_subs.len(), 1, \"BOB should have 1 subscription\");\n\n\t\t// Verify subscription details\n\t\tlet has_sub3 = bob_subs.iter().any(|sub| {\n\t\t\tsub.details.subscriber == BOB \u0026\u0026\n\t\t\t\tsub.credits == 75 \u0026\u0026\n\t\t\t\tsub.frequency == 15 \u0026\u0026\n\t\t\t\tsub.details.target == target3\n\t\t});\n\n\t\tassert!(has_sub3, \"BOB's subscription not found\");\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","tests.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Tests parent module\n//!\n//! Find tests in the submodules.\n\nmod fee_examples;\nmod mock;\nmod pallet;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","traits.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Traits\n\n/// Error type for fees management\n///\n/// Context is used to provide more information about uncategorized errors.\npub enum FeesError\u003cFees, Context\u003e {\n\tNotEnoughBalance { needed: Fees, balance: Fees },\n\tOther(Context),\n}\n\n/// Enum to represent the direction of balance movement.\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub enum BalanceDirection {\n\tCollect,\n\tRelease,\n\t// Balance isn't going anywhere. This is usually the case when diff is zero.\n\tNone,\n}\n\n/// This struct represent movement of balance.\n///\n/// * `balance` - how much balance being moved.\n/// * `direction` - if the balance are being collected or released.\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub struct DiffBalance\u003cBalance\u003e {\n\tpub balance: Balance,\n\tpub direction: BalanceDirection,\n}\n\n/// Trait for fees managing\npub trait FeesManager\u003cFees, Credits, Sub: Subscription\u003cS\u003e, Err, S\u003e {\n\t/// Calculate the fees for a subscription based on the credits of random values required.\n\tfn calculate_subscription_fees(credits: \u0026Credits) -\u003e Fees;\n\t/// Calculate how much fees should be held or release when a subscription changes.\n\t///\n\t/// * `old_credits` - the credits of random values required before the change.\n\t/// * `new_credits` - the credits of random values required after the change, this will\n\t///   represent the updated credits in an update operation. Or the credits actually consumed in\n\t///   a kill operation.\n\tfn calculate_diff_fees(old_credits: \u0026Credits, new_credits: \u0026Credits) -\u003e DiffBalance\u003cFees\u003e;\n\t/// Distributes collected fees. Returns the fees that were effectively collected.\n\tfn collect_fees(fees: \u0026Fees, sub: \u0026Sub) -\u003e Result\u003cFees, FeesError\u003cFees, Err\u003e\u003e;\n}\n\npub trait Subscription\u003cSubscriber\u003e {\n\tfn subscriber(\u0026self) -\u003e \u0026Subscriber;\n}\n\n/// Trait for storage deposit calculation\n///\n/// This trait is used to calculate the storage deposit required for a subscription based it.\npub trait DepositCalculator\u003cDeposit, Sub\u003e {\n\t/// Calculate the storage deposit required for a subscription.\n\tfn calculate_storage_deposit(sub: \u0026Sub) -\u003e Deposit;\n\t/// Calculate the difference in storage deposit between two subscriptions.\n\t///\n\t/// * `old_sub` - the old subscription.\n\t/// * `new_sub` - the new subscription.\n\tfn calculate_diff_deposit(old_sub: \u0026Sub, new_sub: \u0026Sub) -\u003e DiffBalance\u003cDeposit\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","idn-manager","src","weights.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse frame_support::weights::Weight;\n\npub trait WeightInfo {\n\tfn create_subscription() -\u003e Weight;\n\tfn pause_subscription() -\u003e Weight;\n\tfn reactivate_subscription() -\u003e Weight;\n\tfn kill_subscription() -\u003e Weight;\n\tfn update_subscription() -\u003e Weight;\n}\n\nimpl WeightInfo for () {\n\tfn create_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn pause_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn reactivate_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn kill_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn update_subscription() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n}\n","traces":[{"line":28,"address":[4162896],"length":1,"stats":{"Line":0}},{"line":29,"address":[4162897],"length":1,"stats":{"Line":0}},{"line":31,"address":[4162928],"length":1,"stats":{"Line":0}},{"line":32,"address":[4162929],"length":1,"stats":{"Line":0}},{"line":34,"address":[4162960],"length":1,"stats":{"Line":0}},{"line":35,"address":[4162961],"length":1,"stats":{"Line":0}},{"line":37,"address":[4162992],"length":1,"stats":{"Line":0}},{"line":38,"address":[4162993],"length":1,"stats":{"Line":0}},{"line":40,"address":[4163024],"length":1,"stats":{"Line":0}},{"line":41,"address":[4163025],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","aggregator.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! A collection of verifiers for randomness beacon pulses\nuse crate::{\n\tbls12_381,\n\ttypes::{Aggregate, OpaquePublicKey, OpaqueSignature, RoundNumber},\n};\nuse alloc::vec::Vec;\nuse ark_ec::{hashing::HashToCurve, AffineRepr};\nuse ark_serialize::{CanonicalDeserialize, CanonicalSerialize};\nuse sha2::{Digest, Sha256};\nuse timelock::{curves::drand::TinyBLS381, tlock::EngineBLS};\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n\n/// Something that can verify beacon pulses\npub trait SignatureAggregator {\n\t/// Aggregate the new signature to an old one and then verify it\n\t///\n\t/// * `beacon_pk_bytes`:\n\tfn aggregate_and_verify(\n\t\tbeacon_pk_bytes: OpaquePublicKey,\n\t\tnext_sig_bytes: OpaqueSignature,\n\t\tstart: RoundNumber,\n\t\theight: RoundNumber,\n\t\tprev_sig_and_msg: Option\u003cAggregate\u003e,\n\t) -\u003e Result\u003cAggregate, Error\u003e;\n}\n\n#[derive(Debug, PartialEq)]\npub enum Error {\n\t/// The input could not be deserialized to a point on G1\n\tDeserializeG1Failure,\n\t/// The input could not be deserialized to a point on G2\n\tDeserializeG2Failure,\n\t/// Verification for the siganture failed.\n\tInvalidSignature,\n\t/// The input buffer could not be hashed.\n\tInvalidBuffer,\n}\n\n/// A verifier to check values received from Drand quicknet. It outputs true if valid, false\n/// otherwise\n///\n/// [Quicknet](https://drand.love/blog/quicknet-is-live-on-the-league-of-entropy-mainnet) operates in an unchained mode,\n/// so messages contain only the round number. in addition, public keys are in G2 and signatures are\n/// in G1.\n///\n/// Values are valid if the pairing equality holds: $e(sig, g_2) == e(msg_on_curve, pk)$\n/// where $sig \\in \\mathbb{G}_1$ is the signature\n///       $g_2 \\in \\mathbb{G}_2$ is a generator\n///       $msg_on_curve \\in \\mathbb{G}_1$ is a hash of the message that drand signed,\n/// (hash(round_number))        $pk \\in \\mathbb{G}_2$ is the public key, read from the input public\n/// parameters\n///\n/// The implementation is responsible for construcing the public key that is required to verify the\n/// signature. In order to avoid long-running aggregations, the function allows an optional\n/// 'checkpoint' aggregated sig and public key that can be used to 'start' from. The function is\n/// intended to efficiently verify that:\n/// 1) New signatures are correct\n/// 2) The new signatures follow a monotonically increasing sequence and are an extension of\n///    previous a monotonically increasing sequences that I have observed.\n///\n/// More explicitly, it is intended to allow for the runtime to 'follow' a long-running,\n/// aggregated signature and public key that allows it to efficiently prove it has observed all\n/// pulses from the randomness beacon within some given range of round numbers.\npub struct QuicknetAggregator;\n\nimpl SignatureAggregator for QuicknetAggregator {\n\tfn aggregate_and_verify(\n\t\tbeacon_pk_bytes: OpaquePublicKey,\n\t\tnext_sig_bytes: OpaqueSignature,\n\t\tstart: RoundNumber,\n\t\theight: RoundNumber,\n\t\tprev_sig_and_msg: Option\u003cAggregate\u003e,\n\t) -\u003e Result\u003cAggregate, Error\u003e {\n\t\tlet beacon_pk = decode_g2(\u0026beacon_pk_bytes)?;\n\t\t// apk = 0, asig = new_sig\n\t\tlet mut apk = zero_on_g1();\n\t\tlet mut asig = decode_g1(\u0026next_sig_bytes)?;\n\n\t\t// if a previous signature and pubkey were provided\n\t\t// then we start there\n\t\tif let Some(aggr) = prev_sig_and_msg {\n\t\t\tlet prev_asig = decode_g1(\u0026aggr.signature)?;\n\t\t\tlet prev_apk = decode_g1(\u0026aggr.message_hash)?;\n\t\t\tasig = (asig + prev_asig).into();\n\t\t\tapk = (apk + prev_apk).into();\n\t\t}\n\n\t\t// compute new rounds\n\t\tlet latest = start + height;\n\t\tlet rounds = (start..latest).collect::\u003cVec\u003c_\u003e\u003e();\n\n\t\t// TODO: Investigate lookup table for round numbers\n\t\t// https://github.com/ideal-lab5/idn-sdk/issues/119\n\t\tfor r in rounds {\n\t\t\tlet q = compute_round_on_g1(r)?;\n\t\t\tapk = (apk + q).into()\n\t\t}\n\n\t\tlet g2 = G2AffineOpt::generator();\n\t\tlet validity = bls12_381::fast_pairing_opt(asig, g2, apk, beacon_pk);\n\n\t\tif !validity {\n\t\t\treturn Err(Error::InvalidSignature);\n\t\t}\n\n\t\t// convert to bytes\n\t\tlet mut sig_bytes = Vec::new();\n\t\t// note: this line is untestable\n\t\t// Message for SRLABS: can we use an .expect here instead?\n\t\tasig.serialize_compressed(\u0026mut sig_bytes)\n\t\t\t.map_err(|_| Error::DeserializeG1Failure)?;\n\t\tlet new_asig = OpaqueSignature::truncate_from(sig_bytes.clone());\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\t// note: this line is untestable\n\t\tapk.serialize_compressed(\u0026mut apk_bytes)\n\t\t\t.map_err(|_| Error::DeserializeG2Failure)?;\n\t\tlet new_apk = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\tOk(Aggregate { signature: new_asig, message_hash: new_apk })\n\t}\n}\n\n/// Constructs a message (e.g. signed by drand)\nfn message(current_round: RoundNumber, prev_sig: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n\tlet mut hasher = Sha256::default();\n\thasher.update(prev_sig);\n\thasher.update(current_round.to_be_bytes());\n\thasher.finalize().to_vec()\n}\n\n/// This computes the point on G1 given a round number (for message construction).\n/// TODO: do we save anything by pulling out the hasher instead of constructing it each time?\n/// https://github.com/ideal-lab5/idn-sdk/issues/119\npub(crate) fn compute_round_on_g1(round: u64) -\u003e Result\u003cG1AffineOpt, Error\u003e {\n\tlet message = message(round, \u0026[]);\n\tlet hasher = \u003cTinyBLS381 as EngineBLS\u003e::hash_to_curve_map();\n\t// H(m) \\in G1\n\tlet message_hash = hasher.hash(\u0026message).map_err(|_| Error::InvalidBuffer)?;\n\n\tlet mut bytes = Vec::new();\n\tmessage_hash\n\t\t.serialize_compressed(\u0026mut bytes)\n\t\t.map_err(|_| Error::DeserializeG1Failure)?;\n\n\tdecode_g1(\u0026bytes)\n}\n\n/// Computes the 0 point in the G1 group\npub(crate) fn zero_on_g1() -\u003e G1AffineOpt {\n\tG1AffineOpt::zero()\n}\n\n/// Attempts to decode the byte array to a point on G1\nfn decode_g1(mut bytes: \u0026[u8]) -\u003e Result\u003cG1AffineOpt, Error\u003e {\n\tG1AffineOpt::deserialize_compressed(\u0026mut bytes).map_err(|_| Error::DeserializeG1Failure)\n}\n\n/// Attempts to decode the byte array to a point on G2\nfn decode_g2(mut bytes: \u0026[u8]) -\u003e Result\u003cG2AffineOpt, Error\u003e {\n\tG2AffineOpt::deserialize_compressed(\u0026mut bytes).map_err(|_| Error::DeserializeG2Failure)\n}\n\n#[cfg(test)]\npub mod test {\n\tuse super::*;\n\tuse ark_bls12_381::{G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\n\n\tpub(crate) type RawPulse = (u64, [u8; 96]);\n\tpub(crate) const PULSE1000: RawPulse = (1000u64, *b\"b44679b9a59af2ec876b1a6b1ad52ea9b1615fc3982b19576350f93447cb1125e342b73a8dd2bacbe47e4b6b63ed5e39\");\n\tpub(crate) const PULSE1001: RawPulse = (1001u64, *b\"b33bf3667cbd5a82de3a24b4e0e9fe5513cc1a0e840368c6e31f5fcfa79bea03f73896b25883abf2853d10337fb8fa41\");\n\tpub(crate) const PULSE1002: RawPulse = (1002u64, *b\"ab066f9c12dd6de1336fca0f925192fb0c72a771c3e4c82ede1fd362c1a770f9eb05843c6308ce2530b53a99c0281a6e\");\n\tpub(crate) const PULSE1003: RawPulse = (1003u64, *b\"b104c82771698f45fd8dcfead083d482694c31ab519bcef077f126f3736fe98c8392fd5d45d88aeb76b56ccfcb0296d7\");\n\n\t// output the asig + apk\n\tpub(crate) fn get(pulse_data: Vec\u003cRawPulse\u003e) -\u003e (OpaqueSignature, OpaqueSignature) {\n\t\tlet mut apk = zero_on_g1();\n\t\tlet mut asig = zero_on_g1();\n\n\t\tfor pulse in pulse_data {\n\t\t\tlet sig_bytes = hex::decode(\u0026pulse.1).unwrap();\n\t\t\tlet sig = G1AffineOpt::deserialize_compressed(\u0026mut sig_bytes.as_slice()).unwrap();\n\t\t\tasig = (asig + sig).into();\n\n\t\t\tlet pk = compute_round_on_g1(pulse.0).unwrap();\n\t\t\tapk = (apk + pk).into();\n\t\t}\n\n\t\tlet mut asig_bytes = Vec::new();\n\t\tasig.serialize_compressed(\u0026mut asig_bytes).unwrap();\n\t\tlet asig_out = OpaqueSignature::truncate_from(asig_bytes);\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\tapk.serialize_compressed(\u0026mut apk_bytes).unwrap();\n\t\tlet apk_out = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\t(asig_out, apk_out)\n\t}\n\n\t// sk * G \\in G2\n\tfn get_beacon_pk() -\u003e Vec\u003cu8\u003e {\n\t\tlet pk_bytes = b\"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a\";\n\t\thex::decode(pk_bytes).unwrap()\n\t}\n\n\t// d = sk * Q(1000)\n\t// in the case of no aggregation, it outputs the input if valid\n\t#[test]\n\tfn can_verify_single_pulse_with_quicknet_style_verifier_no_prev() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1000u64,\n\t\t\t1,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(sig, aggr.signature);\n\t\tassert_eq!(pk, aggr.message_hash);\n\t}\n\n\t// d1 = sk * Q(1000), d2 = sk * Q(1001) =\u003e verify d = d1 + d2\n\t#[test]\n\tfn can_verify_aggregated_sigs_no_prev() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000, PULSE1001, PULSE1002]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1000u64,\n\t\t\t3,\n\t\t\tNone,\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(sig, aggr.signature);\n\t\tassert_eq!(pk, aggr.message_hash);\n\t}\n\n\t// d1 = sk * Q(1000), d2 = sk * Q(1001) =\u003e verify d = d1 + d2\n\t#[test]\n\tfn can_verify_sigs_with_aggregation() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, pk) = get(vec![PULSE1000]);\n\t\tlet (next_sig, _next_pk) = get(vec![PULSE1001, PULSE1002]);\n\n\t\tlet (expected_asig, expected_apk) = get(vec![PULSE1000, PULSE1001, PULSE1002]);\n\n\t\tlet aggr = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tnext_sig.clone(),\n\t\t\t1001u64,\n\t\t\t2,\n\t\t\tSome(Aggregate { signature: sig, message_hash: pk }),\n\t\t)\n\t\t.unwrap();\n\n\t\tassert_eq!(aggr.signature, expected_asig);\n\t\tassert_eq!(aggr.message_hash, expected_apk);\n\t}\n\n\t#[test]\n\tfn can_verify_invalid_with_mismatched_sig_and_round() {\n\t\tlet beacon_pk_bytes = get_beacon_pk();\n\t\tlet (sig, _pk) = get(vec![PULSE1000]);\n\n\t\tlet res = QuicknetAggregator::aggregate_and_verify(\n\t\t\tOpaquePublicKey::truncate_from(beacon_pk_bytes),\n\t\t\tsig.clone(),\n\t\t\t1002u64,\n\t\t\t1,\n\t\t\tNone,\n\t\t);\n\t\tassert!(res.is_err());\n\t\tassert_eq!(Err(Error::InvalidSignature), res);\n\t}\n\n\t/// Test that `message` is deterministic and returns a 32-byte SHA256 digest.\n\t#[test]\n\tfn test_message_deterministic() {\n\t\tlet round: RoundNumber = 42;\n\t\tlet prev_sig = b\"previous_signature\";\n\t\tlet msg1 = message(round, prev_sig);\n\t\tlet msg2 = message(round, prev_sig);\n\t\tassert_eq!(msg1, msg2, \"Message function should be deterministic for the same inputs\");\n\t\tassert_eq!(msg1.len(), 32, \"SHA256 digest must be 32 bytes long\");\n\t}\n\n\t/// Test that different round numbers result in different message outputs.\n\t#[test]\n\tfn test_message_different_rounds() {\n\t\tlet prev_sig = b\"prev\";\n\t\tlet msg1 = message(1, prev_sig);\n\t\tlet msg2 = message(2, prev_sig);\n\t\tassert_ne!(msg1, msg2, \"Different rounds should produce different messages\");\n\t}\n\n\t/// Test that `zero_on_g1` returns the identity element on G1.\n\t#[test]\n\tfn test_zero_on_g1() {\n\t\tlet zero_point = zero_on_g1();\n\t\tassert!(zero_point.is_zero(), \"zero_on_g1 should return the identity element (zero)\");\n\t}\n\n\t/// Test that a G1 point can be serialized and then correctly deserialized.\n\t#[test]\n\tfn test_decode_g1_roundtrip() {\n\t\t// Use the identity element as a test case.\n\t\tlet point = zero_on_g1();\n\t\tlet mut serialized = Vec::new();\n\t\tpoint.serialize_compressed(\u0026mut serialized).unwrap();\n\t\tlet decoded_point = decode_g1(\u0026serialized).expect(\"Decoding should succeed\");\n\t\tassert_eq!(point, decoded_point, \"Decoded G1 point should equal the original point\");\n\t}\n\n\t/// Test that `decode_g1` returns an error for invalid input.\n\t#[test]\n\tfn test_decode_g1_invalid() {\n\t\tlet invalid_bytes = b\"invalid bytes\";\n\t\tlet result = decode_g1(invalid_bytes);\n\t\tassert!(result.is_err(), \"Decoding invalid G1 bytes should return an error\");\n\t}\n\n\t/// Test that a G2 point (e.g. the generator) can be serialized and then correctly deserialized.\n\t#[test]\n\tfn test_decode_g2_roundtrip() {\n\t\tlet point = G2AffineOpt::generator();\n\t\tlet mut serialized = Vec::new();\n\t\tpoint.serialize_compressed(\u0026mut serialized).unwrap();\n\t\tlet decoded_point = decode_g2(\u0026serialized).expect(\"Decoding should succeed\");\n\t\tassert_eq!(\n\t\t\tpoint, decoded_point,\n\t\t\t\"Decoded G2 point should equal the original generator point\"\n\t\t);\n\t}\n\n\t/// Test that `decode_g2` returns an error for invalid input.\n\t#[test]\n\tfn test_decode_g2_invalid() {\n\t\tlet invalid_bytes = b\"invalid bytes\";\n\t\tlet result = decode_g2(invalid_bytes);\n\t\tassert!(result.is_err(), \"Decoding invalid G2 bytes should return an error\");\n\t\tassert_eq!(result, Err(Error::DeserializeG2Failure));\n\t}\n\n\t/// Test that `compute_round_on_g1` produces a valid point for a given round.\n\t#[test]\n\tfn test_compute_round_on_g1() {\n\t\tlet round = 1;\n\t\tlet result = compute_round_on_g1(round);\n\t\tassert!(result.is_ok(), \"compute_round_on_g1 should succeed for a valid round\");\n\t\tlet point = result.unwrap();\n\t\t// While it is possible (though unlikely) for a hash-to-curve result to be the identity,\n\t\t// in practice this should not happen.\n\t\tassert!(!point.is_zero(), \"The computed round point should not be the identity element\");\n\t}\n}\n","traces":[{"line":87,"address":[5299392,5304080,5301667],"length":1,"stats":{"Line":2}},{"line":94,"address":[5299497,5299613,5299772,5303985],"length":1,"stats":{"Line":2}},{"line":96,"address":[5299757],"length":1,"stats":{"Line":1}},{"line":97,"address":[5300043,5303980,5299814],"length":1,"stats":{"Line":1}},{"line":101,"address":[5300085,5300003],"length":1,"stats":{"Line":2}},{"line":102,"address":[5300490,5300136,5301618,5300240],"length":1,"stats":{"Line":2}},{"line":103,"address":[5301601,5301002,5300462,5300529],"length":1,"stats":{"Line":2}},{"line":104,"address":[5301036,5300739],"length":1,"stats":{"Line":2}},{"line":105,"address":[5301182],"length":1,"stats":{"Line":1}},{"line":109,"address":[5301692,5300167,5301715],"length":1,"stats":{"Line":2}},{"line":110,"address":[5301708],"length":1,"stats":{"Line":1}},{"line":114,"address":[5303953,5301955,5301735,5301909],"length":1,"stats":{"Line":5}},{"line":115,"address":[5301979,5303451,5303862],"length":1,"stats":{"Line":2}},{"line":116,"address":[5303599,5303893],"length":1,"stats":{"Line":2}},{"line":119,"address":[5301997],"length":1,"stats":{"Line":2}},{"line":120,"address":[5302004],"length":1,"stats":{"Line":2}},{"line":122,"address":[5302359],"length":1,"stats":{"Line":2}},{"line":123,"address":[5302371],"length":1,"stats":{"Line":1}},{"line":127,"address":[5302407],"length":1,"stats":{"Line":1}},{"line":130,"address":[5302513,5302638,5303433,5302620,5302442],"length":1,"stats":{"Line":2}},{"line":131,"address":[5302628],"length":1,"stats":{"Line":0}},{"line":132,"address":[5302578,5302671],"length":1,"stats":{"Line":2}},{"line":134,"address":[5302678],"length":1,"stats":{"Line":1}},{"line":136,"address":[5302826,5302737,5302980,5302962],"length":1,"stats":{"Line":2}},{"line":137,"address":[5378272,5378285],"length":1,"stats":{"Line":0}},{"line":138,"address":[5302891],"length":1,"stats":{"Line":1}},{"line":140,"address":[5303005],"length":1,"stats":{"Line":1}},{"line":145,"address":[5304096],"length":1,"stats":{"Line":4}},{"line":146,"address":[5304152],"length":1,"stats":{"Line":1}},{"line":147,"address":[5304173],"length":1,"stats":{"Line":4}},{"line":148,"address":[5304189],"length":1,"stats":{"Line":1}},{"line":149,"address":[5304252,5304340],"length":1,"stats":{"Line":5}},{"line":155,"address":[5305262,5305238,5304368],"length":1,"stats":{"Line":1}},{"line":156,"address":[5304407],"length":1,"stats":{"Line":1}},{"line":157,"address":[5304417],"length":1,"stats":{"Line":4}},{"line":159,"address":[5304878,5304548,5304465,5305247],"length":1,"stats":{"Line":5}},{"line":161,"address":[5304854],"length":1,"stats":{"Line":1}},{"line":162,"address":[5305116,5304999,5305098,5304928],"length":1,"stats":{"Line":5}},{"line":164,"address":[5305106],"length":1,"stats":{"Line":0}},{"line":166,"address":[5305145,5305064],"length":1,"stats":{"Line":4}},{"line":170,"address":[5305280],"length":1,"stats":{"Line":1}},{"line":171,"address":[5305288],"length":1,"stats":{"Line":4}},{"line":175,"address":[5305312],"length":1,"stats":{"Line":1}},{"line":176,"address":[5305338],"length":1,"stats":{"Line":4}},{"line":180,"address":[5305392],"length":1,"stats":{"Line":1}},{"line":181,"address":[5305418],"length":1,"stats":{"Line":3}}],"covered":43,"coverable":46},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","benchmarking.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! Benchmarking setup for pallet-drand\nuse super::*;\n\n#[allow(unused)]\nuse crate::{pallet as pallet_drand, mock::*, Pallet as Drand, types::*};\nuse ark_ec::Group;\nuse ark_std::{ops::Mul, UniformRand};\nuse frame_benchmarking::v2::*;\nuse frame_support::BoundedVec;\nuse frame_system::RawOrigin;\nuse timelock::{curves::drand::TinyBLS381, tlock::EngineBLS};\n\n#[benchmarks]\nmod benchmarks {\n\tuse super::*;\n\tuse ark_std::test_rng;\n\n\t#[benchmark]\n\tfn try_submit_asig() {\n\t\t// we mock drand here\n\t\tlet sk = \u003cTinyBLS381 as EngineBLS\u003e::Scalar::from(1);\n\t\t// let pk = \u003cTinyBLS381 as EngineBLS\u003e::PublicKeyGroup::generator().mul(sk);\n\t\t// let mut pk_bytes = Vec::new();\n\t\t// pk.serialize_compressed(\u0026mut pk_bytes).unwrap();\n\n\t\t// let mut config = drand_quicknet_config();\n\t\t// config.public_key = BoundedVec::truncate_from(pk_bytes);\n\n\t\t// pallet_drand::BeaconConfig::\u003cT\u003e::set(Some(config));\n\n\t\tlet start = 1;\n\t\tlet num_rounds = 2;\n\n\t\tlet mut asig = crate::aggregator::zero_on_g1();\n\t\tlet mut apk = crate::verifier::zero_on_g1();\n\n\t\tfor round in start..start + num_rounds {\n\t\t\tlet q_id = crate::verifier::compute_round_on_g1(round).unwrap();\n\t\t\tapk = (apk + q_id).into();\n\t\t\tasig = (asig + (q_id.mul(sk))).into();\n\t\t}\n\n\t\tlet mut asig_bytes = Vec::new();\n\t\tasig.serialize_compressed(\u0026mut asig_bytes).unwrap();\n\t\tlet bounded_asig = OpaqueSignature::truncate_from(asig_bytes);\n\n\t\tlet mut apk_bytes = Vec::new();\n\t\tapk.serialize_compressed(\u0026mut apk_bytes).unwrap();\n\t\tlet bounded_message_hash = OpaqueSignature::truncate_from(apk_bytes);\n\n\t\t#[extrinsic_call]\n\t\t_(RawOrigin::None, bounded_asig.clone(), num_rounds.clone(), Some(start));\n\n\t\tassert_eq!(\n\t\t\tAggregatedSignature::\u003cT\u003e::get(),\n\t\t\tSome(Aggregate {\n\t\t\t\tsignature: bounded_asig, \n\t\t\t\tmessage_hash:  bounded_message_hash,\n\t\t\t})\n\t\t);\n\t}\n\n\timpl_benchmark_test_suite!(Drand, crate::mock::new_test_ext(), crate::mock::Test);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","bls12_381.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#[cfg(not(feature = \"host-arkworks\"))]\nuse ark_bls12_381::{Bls12_381 as Bls12_381Opt, G1Affine as G1AffineOpt, G2Affine as G2AffineOpt};\nuse ark_ec::pairing::Pairing;\nuse ark_std::{ops::Neg, Zero};\n#[cfg(feature = \"host-arkworks\")]\nuse sp_ark_bls12_381::{\n\tBls12_381 as Bls12_381Opt, G1Affine as G1AffineOpt, G2Affine as G2AffineOpt,\n};\n\n/// An optimized way to verify Drand pulses from quicket\n/// Instead of computing two pairings and comparing them, we instead compute a multi miller loop,\n/// and then take the final exponentiation, saving a lot of computational cost.\n///\n/// This function is also inlined as a way to optimize performance.\n///\n/// * `signature`: The signature to verify\n/// * `q`: The beacon public key\n/// * `r`: The message signed by Drand, hashed to G1\n/// * `s`: A generator\n#[inline]\npub fn fast_pairing_opt(\n\tsignature: G1AffineOpt,\n\tq: G2AffineOpt,\n\tr: G1AffineOpt,\n\ts: G2AffineOpt,\n) -\u003e bool {\n\tlet looped = Bls12_381Opt::multi_miller_loop([signature.neg(), r], [q, s]);\n\tlet exp = Bls12_381Opt::final_exponentiation(looped);\n\texp.unwrap().is_zero()\n}\n","traces":[{"line":37,"address":[5643120],"length":1,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Randomness Beacon Aggregation and Verification Pallet\n//!\n//! This pallet facilitates the aggregation and verification of randomness pulses from an external\n//! verifiable randomness beacon, such as [drand](https://drand.love)'s Quicknet. It enables\n//! runtime access to externally sourced, cryptographically secure randomness while ensuring that\n//! only properly signed pulses are accepted.\n//!\n//! ## Overview\n//!\n//! - Provides a mechanism to ingest randomness pulses from an external randomness beacon.\n//! - Aggregates and verifies pulses using the [`SignatureAggregator`] trait.\n//! - Ensures that the runtime only uses verified randomness for security-critical applications.\n//! - Stores the latest aggregated signature to enable efficient verification within the runtime.\n//!\n//! This pallet is particularly useful for use cases that require externally verifiable randomness,\n//! such as fair lotteries, gaming applications, and leader election mechanisms.\n//!\n//! ## Terminology\n//!\n//! - **Randomness Pulse**: A cryptographically signed value representing a random output from an\n//!   external randomness beacon.\n//! - **Round Number**: A sequential identifier corresponding to each randomness pulse.\n//! - **Aggregated Signature**: A combined (aggregated) cryptographic signature that ensures all\n//!   observed pulses originate from the trusted randomness beacon.\n//!\n//! ## Implementation Details\n//!\n//! The pallet relies on a [`SignatureAggregator`] implementation to aggregate and verify randomness\n//! pulses. It maintains the latest observed rounds, validates incoming pulses, and aggregates valid\n//! signatures before storing them in runtime storage. It expects a monotonically increasing\n//! sequence of beacon pulses delivered in packets of size `T::SignatureToBlockRatio`, beginning at\n//! the genesis round.\n//!\n//! To be more specific, if the randomness beacon incrementally outputs pulses A -\u003e B -\u003e C -\u003e D,\n//! the genesis round expects pulse A first, and the SignatureToBlockRatio is 2, then this pallet\n//! would first expect the 'aggregated' pulse AB = A + B, which produces both an aggregated\n//! *signature* (asig) and an aggregated *public key* (apk). Subsequently, it would expected the\n//! next value to be CD = C + D. On-chain, this results in the aggregated signature, ABCD = AB + CD,\n//! which we can use to prove we have observed all pulses between A and D.\n//!\n//! ### Storage Items\n//!\n//! - `BeaconConfig`: Stores the beacon configuration details.\n//! - `GenesisRound`: The first round number from which randomness pulses are considered valid.\n//! - `LatestRound`: Tracks the latest verified round number.\n//! - `AggregatedSignature`: Stores the latest aggregated signature for verification purposes.\n//!\n//! ## Usage\n//!\n//! This pallet is designed to securely ingest verifiable randomness into the runtime.\n//! It exposes an inherent provider that automatically processes randomness pulses included\n//! in block production.\n//!\n//! ## Interface\n//!\n//! - **Extrinsics**\n//!   - `try_submit_asig`: Submit an aggregated signature for verification. This is an unsigned\n//!     extrinsic, intended to be called from the inherent.\n//!\n//! - **Inherent Implementation**\n//!   - This pallet provides an inherent that automatically submits aggregated randomness pulses\n//!     during block execution.\n//!\n//! Run `cargo doc --package pallet-randomness-beacon --open` to view this pallet's documentation.\n\n// We make sure this pallet uses `no_std` for compiling to Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n// Re-export pallet items so that they can be accessed from the crate namespace.\npub use pallet::*;\n\nextern crate alloc;\n\nuse alloc::{vec, vec::Vec};\nuse ark_serialize::CanonicalSerialize;\nuse frame_support::pallet_prelude::*;\nuse sc_consensus_randomness_beacon::types::OpaquePulse;\n\npub mod aggregator;\npub mod bls12_381;\npub mod types;\npub mod weights;\npub use weights::*;\n\nuse aggregator::{zero_on_g1, SignatureAggregator};\nuse types::*;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\n/// The buffer size required to represent an element of the signature group\nconst SERIALIZED_SIG_SIZE: usize = 48;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::ensure;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching runtime event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\t/// A type representing the weights required by the dispatchables of this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\t\t/// The beacon configuration for which this pallet is defined.\n\t\ttype BeaconConfig: Get\u003cBeaconConfiguration\u003e;\n\t\t/// something that knows how to aggregate and verify beacon pulses.\n\t\ttype SignatureAggregator: SignatureAggregator;\n\t\t/// The number of signatures per block.\n\t\ttype MaxSigsPerBlock: Get\u003cu8\u003e;\n\t}\n\n\t/// A first round number for which a pulse was observed\n\t#[pallet::storage]\n\tpub type GenesisRound\u003cT: Config\u003e = StorageValue\u003c_, RoundNumber, ValueQuery\u003e;\n\n\t/// The latest observed round\n\t#[pallet::storage]\n\tpub type LatestRound\u003cT: Config\u003e = StorageValue\u003c_, RoundNumber, ValueQuery\u003e;\n\n\t/// The aggregated signature and aggregated public key (identifier) of all observed pulses of\n\t/// randomness\n\t#[pallet::storage]\n\tpub type AggregatedSignature\u003cT: Config\u003e = StorageValue\u003c_, Aggregate, OptionQuery\u003e;\n\n\t/// Whether the asig has been updated in this block.\n\t///\n\t/// This value is updated to `true` upon successful submission of an asig by a node.\n\t/// It is then checked at the end of each block execution in the `on_finalize` hook.\n\t#[pallet::storage]\n\tpub(super) type DidUpdate\u003cT: Config\u003e = StorageValue\u003c_, bool, ValueQuery\u003e;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// The genesis round has been changed by a root address\n\t\tGenesisRoundChanged,\n\t\t/// Siganture verification succeeded for signatures associated with the given rounds.\n\t\tSignatureVerificationSuccess,\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// The input data could not be decoded or was empty\n\t\tInvalidInput,\n\t\t/// The pulse could not be verified\n\t\tVerificationFailed,\n\t\t/// The next round number is invalid (either too high or too low)\n\t\tInvalidNextRound,\n\t\t/// The network is at block 0.\n\t\tNetworkTooEarly,\n\t\t/// There must be at least one pulse provided.\n\t\tNonPositiveHeight,\n\t\t/// The genesis round is zero.\n\t\tGenesisRoundNotSet,\n\t\t/// The genesis is already set.\n\t\tGenesisRoundAlreadySet,\n\t\t/// There must be at least one signature to construct an asig\n\t\tZeroHeightProvided,\n\t\t/// There number of aggregated signatures exceeds the maximum rounds we can verify per block.\n\t\tExcessiveHeightProvided,\n\t\t/// Only one aggregated signature can be provided per block\n\t\tSignatureAlreadyVerified,\n\t}\n\n\t#[pallet::inherent]\n\timpl\u003cT: Config\u003e ProvideInherent for Pallet\u003cT\u003e {\n\t\ttype Call = Call\u003cT\u003e;\n\t\ttype Error = MakeFatalError\u003c()\u003e;\n\n\t\tconst INHERENT_IDENTIFIER: [u8; 8] =\n\t\t\tsp_consensus_randomness_beacon::inherents::INHERENT_IDENTIFIER;\n\n\t\tfn create_inherent(data: \u0026InherentData) -\u003e Option\u003cSelf::Call\u003e {\n\t\t\t// if we do not find any pulse data, then do nothing\n\t\t\tif let Ok(Some(raw_pulses)) = data.get_data::\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e(\u0026Self::INHERENT_IDENTIFIER)\n\t\t\t{\n\t\t\t\t// ignores non-deserializable messages\n\t\t\t\t// if all messages are invalid, it outputs 0 on the G1 curve (so serialization of asig always works)\n\t\t\t\tlet asig = raw_pulses\n\t\t\t\t\t.iter()\n\t\t\t\t\t.filter_map(|rp| OpaquePulse::deserialize_from_vec(rp).ok())\n\t\t\t\t\t.filter_map(|pulse| pulse.signature_point().ok())\n\t\t\t\t\t.fold(zero_on_g1(), |acc, sig| (acc + sig).into());\n\n\t\t\t\tlet mut asig_bytes = Vec::with_capacity(SERIALIZED_SIG_SIZE);\n\t\t\t\t// [SRLABS]: This error is untestable since we know the signature is correct here.\n\t\t\t\t//  Is it reasonable to use an expect?\n\t\t\t\tasig.serialize_compressed(\u0026mut asig_bytes)\n\t\t\t\t\t.expect(\"The signature is well formatted.\");\n\n\t\t\t\t// if the genesis round is not configured, then the first call sets it\n\t\t\t\tlet round = (GenesisRound::\u003cT\u003e::get() == 0)\n\t\t\t\t\t.then(|| {\n\t\t\t\t\t\t// get the round from the first pulse observed\n\t\t\t\t\t\traw_pulses.iter().find_map(|rp| {\n\t\t\t\t\t\t\tOpaquePulse::deserialize_from_vec(rp).ok().map(|p| p.round)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or(None);\n\n\t\t\t\treturn Some(Call::try_submit_asig {\n\t\t\t\t\tasig: OpaqueSignature::truncate_from(asig_bytes),\n\t\t\t\t\theight: raw_pulses.len() as RoundNumber,\n\t\t\t\t\tround,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlog::info!(\"The node provided empty pulse data to the inherent!\");\n\t\t\t}\n\n\t\t\tNone\n\t\t}\n\n\t\tfn check_inherent(call: \u0026Self::Call, _data: \u0026InherentData) -\u003e Result\u003c(), Self::Error\u003e {\n\t\t\tmatch call {\n\t\t\t\tCall::try_submit_asig { .. } =\u003e Ok(()),\n\t\t\t\t_ =\u003e unreachable!(\"other calls are not inherents\"),\n\t\t\t}\n\t\t}\n\n\t\tfn is_inherent(call: \u0026Self::Call) -\u003e bool {\n\t\t\tmatches!(call, Call::try_submit_asig { .. })\n\t\t}\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\t/// A dummy `on_initialize` to return the amount of weight that `on_finalize` requires to\n\t\t/// execute.\n\t\tfn on_initialize(_n: BlockNumberFor\u003cT\u003e) -\u003e Weight {\n\t\t\t// weight of `on_finalize`\n\t\t\tT::WeightInfo::on_finalize()\n\t\t}\n\n\t\t/// At the end of block execution, the `on_finalize` hook checks that the timestamp was\n\t\t/// updated. Upon success, it removes the boolean value from storage. If the value resolves\n\t\t/// to `false`, the pallet will panic.\n\t\t///\n\t\t/// ## Complexity\n\t\t/// - `O(1)`\n\t\tfn on_finalize(_n: BlockNumberFor\u003cT\u003e) {\n\t\t\tassert!(DidUpdate::\u003cT\u003e::take(), \"The aggregated siganture must be updated once in the block\");\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Write a set of pulses to the runtime\n\t\t///\n\t\t/// * `origin`: A None origin\n\t\t/// * `asig`: An aggregated signature\n\t\t/// * `height`: The number of sigs aggregated to construct asig\n\t\t/// * `round`: An optional genesis round number. It can only be set if the existing genesis\n\t\t///   round is 0.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(T::WeightInfo::try_submit_asig())]\n\t\tpub fn try_submit_asig(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tasig: OpaqueSignature,\n\t\t\theight: RoundNumber,\n\t\t\tround: Option\u003cRoundNumber\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_none(origin)?;\n\t\t\tensure!(\n\t\t\t\t!DidUpdate::\u003cT\u003e::exists(), \n\t\t\t\tError::\u003cT\u003e::SignatureAlreadyVerified,\n\t\t\t);\n\n\t\t\tlet config = T::BeaconConfig::get();\n\t\t\tlet mut genesis_round = GenesisRound::\u003cT\u003e::get();\n\t\t\tlet mut latest_round = LatestRound::\u003cT\u003e::get();\n\n\t\t\tensure!(height \u003e 0, Error::\u003cT\u003e::ZeroHeightProvided);\n\t\t\tensure!(\n\t\t\t\theight \u003c= T::MaxSigsPerBlock::get() as u64,\n\t\t\t\tError::\u003cT\u003e::ExcessiveHeightProvided\n\t\t\t);\n\n\t\t\tif let Some(r) = round {\n\t\t\t\t// if a round is provided and the genesis round is not set\n\t\t\t\tensure!(genesis_round == 0, Error::\u003cT\u003e::GenesisRoundAlreadySet);\n\t\t\t\tGenesisRound::\u003cT\u003e::set(r);\n\t\t\t\tgenesis_round = r;\n\t\t\t\tlatest_round = genesis_round;\n\t\t\t} else {\n\t\t\t\t//  if the genesis round is not set and a round is not provided\n\t\t\t\tensure!(\n\t\t\t\t\tGenesisRound::\u003cT\u003e::get() \u003e 0,\n\t\t\t\t\tError::\u003cT\u003e::GenesisRoundNotSet\n\t\t\t\t);\n\t\t\t}\n\t\t\t// aggregate old asig/apk with the new one and verify the aggregation\n\t\t\t// Q: do we care about the entire linear history of message hashes?\n\t\t\t// https://github.com/ideal-lab5/idn-sdk/issues/119\n\t\t\tlet aggr = T::SignatureAggregator::aggregate_and_verify(\n\t\t\t\tconfig.public_key,\n\t\t\t\tasig,\n\t\t\t\tlatest_round,\n\t\t\t\theight,\n\t\t\t\tAggregatedSignature::\u003cT\u003e::get(),\n\t\t\t)\n\t\t\t.map_err(|_| Error::\u003cT\u003e::VerificationFailed)?;\n\n\t\t\tLatestRound::\u003cT\u003e::set(latest_round.saturating_add(height));\n\t\t\tAggregatedSignature::\u003cT\u003e::set(Some(aggr));\n\t\t\tDidUpdate::\u003cT\u003e::put(true);\n\n\t\t\tSelf::deposit_event(Event::\u003cT\u003e::SignatureVerificationSuccess);\n\n\t\t\tOk(())\n\t\t}\n\t}\n}\n","traces":[{"line":140,"address":[5274365,5274498,5274352,5273749,5273648,5274432],"length":1,"stats":{"Line":4}},{"line":144,"address":[5274658,5274525,5273808,5274592,5274512,5273909],"length":1,"stats":{"Line":4}},{"line":149,"address":[5274685,5274088,5274672,5273968,5274818,5274752],"length":1,"stats":{"Line":4}},{"line":156,"address":[5274300,5274912,5274845,5274144,5274832,5274978],"length":1,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":3}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":324,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}}],"covered":51,"coverable":62},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","mock.rs"],"content":"use crate as pallet_drand_bridge;\nuse crate::{aggregator::QuicknetAggregator, *};\nuse frame_support::{\n\tderive_impl, parameter_types,\n\ttraits::{ConstU16, ConstU64, ConstU8},\n};\nuse sp_core::{sr25519::Signature, H256};\nuse sp_keystore::{testing::MemoryKeystore, KeystoreExt};\nuse sp_runtime::{\n\ttraits::{BlakeTwo256, IdentityLookup, Verify},\n\tBuildStorage,\n};\n\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n\tpub enum Test\n\t{\n\t\tSystem: frame_system,\n\t\tDrand: pallet_drand_bridge,\n\t}\n);\n\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig as frame_system::DefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Nonce = u64;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = sp_core::sr25519::Public;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Block = Block;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockHashCount = ConstU64\u003c250\u003e;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = ();\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = ConstU16\u003c42\u003e;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Test {\n\ttype Public = \u003cSignature as Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nparameter_types! {\n\tpub QuicknetBeaconConfig: BeaconConfiguration = drand_quicknet_config();\n}\n\nimpl pallet_drand_bridge::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = ();\n\ttype BeaconConfig = QuicknetBeaconConfig;\n\ttype SignatureAggregator = QuicknetAggregator;\n\ttype MaxSigsPerBlock = ConstU8\u003c2\u003e;\n}\n\n// Build genesis storage according to the mock runtime.\npub fn new_test_ext() -\u003e sp_io::TestExternalities {\n\tlet t = frame_system::GenesisConfig::\u003cTest\u003e::default().build_storage().unwrap();\n\tlet mut ext = sp_io::TestExternalities::new(t);\n\tlet keystore = MemoryKeystore::new();\n\text.register_extension(KeystoreExt::new(keystore.clone()));\n\n\text\n}\n\npub(crate) fn drand_quicknet_config() -\u003e BeaconConfiguration {\n\tbuild_beacon_configuration(\n\t\t\"83cf0f2896adee7eb8b5f01fcad3912212c437e0073e911fb90022d3e760183c8c4b450b6a0a6c3ac6a5776a2d1064510d1fec758c921cc22b0e17e63aaf4bcb5ed66304de9cf809bd274ca73bab4af5a6e9c76a4bc09e76eae8991ef5ece45a\",\n\t\t3,\n\t\t1692803367,\n\t\t\"52db9ba70e0cc0f6eaf7803dd07447a1f5477735fd3f661792ba94600c84e971\",\n\t\t\"f477d5c89f21a17c863a7f937c6a6d15859414d2be09cd448d4279af331c5d3e\",\n\t\t\"bls-unchained-g1-rfc9380\",\n\t\t\"quicknet\"\n\t)\n}\n\n/// build a beacon configuration struct\nfn build_beacon_configuration(\n\tpk_hex: \u0026str,\n\tperiod: u32,\n\tgenesis_time: u32,\n\thash_hex: \u0026str,\n\tgroup_hash_hex: \u0026str,\n\tscheme_id: \u0026str,\n\tbeacon_id: \u0026str,\n) -\u003e BeaconConfiguration {\n\tlet pk = hex::decode(pk_hex).expect(\"Valid hex\");\n\tlet hash = hex::decode(hash_hex).expect(\"Valid hex\");\n\tlet group_hash = hex::decode(group_hash_hex).expect(\"Valid hex\");\n\n\tlet public_key: OpaquePublicKey = BoundedVec::try_from(pk).expect(\"Public key within bounds\");\n\tlet hash: OpaqueHash = BoundedVec::try_from(hash).expect(\"Hash within bounds\");\n\tlet group_hash: OpaqueHash =\n\t\tBoundedVec::try_from(group_hash).expect(\"Group hash within bounds\");\n\tlet scheme_id: OpaqueHash =\n\t\tBoundedVec::try_from(scheme_id.as_bytes().to_vec()).expect(\"Scheme ID within bounds\");\n\tlet beacon_id: OpaqueHash =\n\t\tBoundedVec::try_from(beacon_id.as_bytes().to_vec()).expect(\"Scheme ID within bounds\");\n\n\tlet metadata = Metadata { beacon_id };\n\n\tBeaconConfiguration { public_key, period, genesis_time, hash, group_hash, scheme_id, metadata }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","tests.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \nuse crate::{\n\taggregator::test::*, mock::*, AggregatedSignature, Call, Error, GenesisRound, LatestRound,\n\tweights::*,\n};\nuse frame_support::{assert_noop, assert_ok, inherent::ProvideInherent, traits::OnFinalize};\n\n#[test]\nfn can_construct_pallet_and_set_genesis_params() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet actual_genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(0, actual_genesis_round);\n\t});\n}\n\n#[test]\nfn can_fail_write_pulse_when_genesis_round_zero_and_none_provided() {\n\tlet (sig, _pk) = get(vec![PULSE1000]);\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), sig, 1, None),\n\t\t\tError::\u003cTest\u003e::GenesisRoundNotSet,\n\t\t);\n\t});\n}\n\n#[test]\nfn can_submit_min_required_valid_pulses_on_genesis() {\n\tlet round = 1000u64;\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 2, Some(round)));\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig, aggr.signature);\n\t\tassert_eq!(apk, aggr.message_hash);\n\t});\n}\n\n#[test]\nfn can_fail_when_sig_height_is_0() {\n\tlet round = 1000u64;\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 0, Some(round)),\n\t\t\tError::\u003cTest\u003e::ZeroHeightProvided\n\t\t);\n\t});\n}\n\n#[test]\nfn can_fail_when_sig_height_is_exceeds_max() {\n\tlet round = 1000u64;\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig.clone(), 10, Some(round)),\n\t\t\tError::\u003cTest\u003e::ExcessiveHeightProvided\n\t\t);\n\t});\n}\n\n#[test]\nfn can_submit_valid_sigs_in_sequence() {\n\tlet round1 = 1000u64;\n\tlet round2 = 1004u64;\n\n\tlet (asig1, _apk1) = get(vec![PULSE1000, PULSE1001]);\n\tlet (asig2, _apk2) = get(vec![PULSE1002, PULSE1003]);\n\t// the aggregated values\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001, PULSE1002, PULSE1003]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\n\t\tDrand::on_finalize(1);\n\t\tSystem::set_block_number(2);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig2.clone(), 2, None));\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round1, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig, aggr.signature);\n\t\tassert_eq!(apk, aggr.message_hash);\n\n\t\tlet actual_latest = LatestRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round2, actual_latest);\n\t});\n}\n\n#[test]\nfn can_fail_to_calls_to_try_submit_asig_per_block() {\n\tlet round1 = 1000u64;\n\tlet round2 = 1004u64;\n\n\tlet (asig1, _apk1) = get(vec![PULSE1000, PULSE1001]);\n\tlet (asig2, _apk2) = get(vec![PULSE1002, PULSE1003]);\n\t// the aggregated values\n\tlet (asig, apk) = get(vec![PULSE1000, PULSE1001, PULSE1002, PULSE1003]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, None),\n\t\t\tError::\u003cTest\u003e::SignatureAlreadyVerified,\n\t\t);\n\t});\n}\n\n#[test]\nfn can_fail_to_submit_invalid_sigs_in_sequence() {\n\tlet round1 = 1000u64;\n\n\tlet (asig1, apk1) = get(vec![PULSE1000, PULSE1001]);\n\n\tnew_test_ext().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\n\t\tassert_ok!(Drand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)));\n\n\t\tDrand::on_finalize(1);\n\t\tSystem::set_block_number(2);\n\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, None),\n\t\t\tError::\u003cTest\u003e::VerificationFailed,\n\t\t);\n\t\tassert_noop!(\n\t\t\tDrand::try_submit_asig(RuntimeOrigin::none(), asig1.clone(), 2, Some(round1)),\n\t\t\tError::\u003cTest\u003e::GenesisRoundAlreadySet,\n\t\t);\n\n\t\t// then the gensis round is set to `round`\n\t\tlet genesis_round = GenesisRound::\u003cTest\u003e::get();\n\t\tassert_eq!(round1, genesis_round);\n\n\t\tlet maybe_res = AggregatedSignature::\u003cTest\u003e::get();\n\t\tassert!(maybe_res.is_some());\n\n\t\tlet aggr = maybe_res.unwrap();\n\t\tassert_eq!(asig1, aggr.signature);\n\t\tassert_eq!(apk1, aggr.message_hash);\n\n\t\tlet actual_latest = LatestRound::\u003cTest\u003e::get();\n\t\tassert_eq!(1002, actual_latest);\n\t});\n}\n\n/*\n\tInherents Tests\n*/\nuse sc_consensus_randomness_beacon::types::OpaquePulse;\nuse sp_consensus_randomness_beacon::inherents::INHERENT_IDENTIFIER;\nuse sp_inherents::InherentData;\n\n#[test]\nfn can_create_inherent_and_set_genesis_round() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(Call::try_submit_asig { asig: actual_asig, height, round: Some(1000) }) = result\n\t\t{\n\t\t\tassert_eq!(height, 2, \"The asig height should equal the number of pulses.\");\n\t\t\tassert_eq!(actual_asig, asig, \"The output should match the aggregated input.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n\n#[test]\nfn can_create_inherent_when_genesis_round_is_set() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet (asig, _apk) = get(vec![PULSE1000, PULSE1001]);\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tGenesisRound::\u003cTest\u003e::set(999);\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(Call::try_submit_asig { asig: actual_asig, height, round: None }) = result {\n\t\t\tassert_eq!(height, 2, \"The asig height should equal the number of pulses.\");\n\t\t\tassert_eq!(actual_asig, asig, \"The output should match the aggregated input.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n\n#[test]\nfn can_not_create_inherent_when_data_is_unavailable() {\n\tlet inherent_data = InherentData::new();\n\tnew_test_ext().execute_with(|| {\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tassert!(result.is_none());\n\t});\n}\n\n#[test]\nfn can_check_inherent() {\n\t// setup the inherent data\n\tlet (asig1, _apk1) = get(vec![PULSE1000]);\n\tlet pulse1 = OpaquePulse { round: 1000u64, signature: asig1.to_vec().try_into().unwrap() };\n\tlet (asig2, _apk2) = get(vec![PULSE1001]);\n\tlet pulse2 = OpaquePulse { round: 1001u64, signature: asig2.to_vec().try_into().unwrap() };\n\n\tlet bytes: Vec\u003cVec\u003cu8\u003e\u003e = vec![pulse1.serialize_to_vec(), pulse2.serialize_to_vec()];\n\tlet mut inherent_data = InherentData::new();\n\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026bytes.clone()).unwrap();\n\n\tnew_test_ext().execute_with(|| {\n\t\tGenesisRound::\u003cTest\u003e::set(999);\n\t\tlet result = Drand::create_inherent(\u0026inherent_data);\n\t\tif let Some(call) = result {\n\t\t\tassert!(Drand::is_inherent(\u0026call), \"The inherent should be allowed.\");\n\t\t\tlet res = Drand::check_inherent(\u0026call, \u0026inherent_data);\n\t\t\tassert!(res.is_ok(), \"The inherent should be allowed.\");\n\t\t} else {\n\t\t\tpanic!(\"Expected Some(Call::try_submit_asig), got None\");\n\t\t}\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","types.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse codec::{Decode, Encode};\nuse frame_support::pallet_prelude::*;\nuse serde::{Deserialize, Serialize};\n\n/// Represents an opaque public key used in drand's quicknet\npub type OpaquePublicKey = BoundedVec\u003cu8, ConstU32\u003c96\u003e\u003e;\n/// Represents an element of the signature group\npub type OpaqueSignature = BoundedVec\u003cu8, ConstU32\u003c48\u003e\u003e;\n/// an opaque bounded storage type for 64 bit hashes\npub type OpaqueHash = BoundedVec\u003cu8, ConstU32\u003c64\u003e\u003e;\n/// the round number to track rounds of the beacon\npub type RoundNumber = u64;\n\n/// Represents an aggregated signature and aggregated public key pair\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\t// Serialize,\n\t// Deserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct Aggregate {\n\t/// A signature (e.g. output from the randomness beacon) in G1\n\tpub signature: OpaqueSignature,\n\t/// The message signed by the signature, hashed to G1\n\tpub message_hash: OpaqueSignature,\n}\n\n/// A drand chain configuration\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\tSerialize,\n\tDeserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct BeaconConfiguration {\n\tpub public_key: OpaquePublicKey,\n\tpub period: u32,\n\tpub genesis_time: u32,\n\tpub hash: OpaqueHash,\n\tpub group_hash: OpaqueHash,\n\tpub scheme_id: OpaqueHash,\n\tpub metadata: Metadata,\n}\n\n/// metadata for the drand beacon configuration\n#[derive(\n\tClone,\n\tDebug,\n\tDecode,\n\tDefault,\n\tPartialEq,\n\tEncode,\n\tSerialize,\n\tDeserialize,\n\tMaxEncodedLen,\n\tTypeInfo,\n)]\npub struct Metadata {\n\tpub beacon_id: OpaqueHash,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","pallets","randomness-beacon","src","weights.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO: weights generation and benchmarking: https://github.com/ideal-lab5/idn-sdk/issues/56\nuse frame_support::weights::Weight;\n\npub trait WeightInfo {\n\tfn on_finalize() -\u003e Weight;\n\tfn try_submit_asig() -\u003e Weight;\n}\n\nimpl WeightInfo for () {\n\tfn on_finalize() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n\tfn try_submit_asig() -\u003e Weight {\n\t\tWeight::from_parts(2_956_000, 1627)\n\t}\n}\n","traces":[{"line":26,"address":[5384016],"length":1,"stats":{"Line":0}},{"line":27,"address":[5384017],"length":1,"stats":{"Line":0}},{"line":29,"address":[5384048],"length":1,"stats":{"Line":0}},{"line":30,"address":[5384049],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","driemworks","ideal","idn-sdk","primitives","consensus","randomness-beacon","src","inherents.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nuse alloc::vec::Vec;\nuse sp_inherents::{Error, InherentData, InherentIdentifier};\n\npub const INHERENT_IDENTIFIER: InherentIdentifier = *b\"rngpulse\";\n\npub type InherentType = Vec\u003cVec\u003cu8\u003e\u003e;\n\n#[cfg(feature = \"std\")]\npub struct InherentDataProvider {\n\tdata: InherentType,\n}\n\n#[cfg(feature = \"std\")]\nimpl InherentDataProvider {\n\tpub fn new(data: InherentType) -\u003e Self {\n\t\tSelf { data }\n\t}\n}\n\n#[cfg(feature = \"std\")]\nimpl core::ops::Deref for InherentDataProvider {\n\ttype Target = InherentType;\n\n\tfn deref(\u0026self) -\u003e \u0026Self::Target {\n\t\t\u0026self.data\n\t}\n}\n\n#[cfg(feature = \"std\")]\n#[async_trait::async_trait]\nimpl sp_inherents::InherentDataProvider for InherentDataProvider {\n\tasync fn provide_inherent_data(\u0026self, inherent_data: \u0026mut InherentData) -\u003e Result\u003c(), Error\u003e {\n\t\tinherent_data.put_data(INHERENT_IDENTIFIER, \u0026self.data)\n\t}\n\n\tasync fn try_handle_error(\n\t\t\u0026self,\n\t\t_: \u0026InherentIdentifier,\n\t\t_: \u0026[u8],\n\t) -\u003e Option\u003cResult\u003c(), Error\u003e\u003e {\n\t\tNone\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\n\tuse super::{InherentDataProvider as RandInherentDataProvider, *};\n\tuse core::ops::Deref;\n\tuse sp_inherents::InherentDataProvider;\n\n\t#[test]\n\tpub fn can_construct_inherent_data_provider() {\n\t\tlet data: InherentType = vec![vec![1]];\n\t\tlet provider = RandInherentDataProvider::new(data.clone());\n\t\tassert_eq!(\u0026data, provider.deref())\n\t}\n\n\t#[tokio::test]\n\tpub async fn can_provide_inherent_data() {\n\t\tlet extra_data = vec![vec![1]];\n\t\tlet mut inherent_data = InherentData::new();\n\t\tlet provider = RandInherentDataProvider::new(extra_data.clone());\n\n\t\tlet res = provider.provide_inherent_data(\u0026mut inherent_data).await;\n\t\tassert!(res.is_ok());\n\n\t\tlet data = inherent_data.get_data::\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e(\u0026INHERENT_IDENTIFIER).unwrap().unwrap();\n\t\tassert_eq!(extra_data, data)\n\t}\n\n\t#[tokio::test]\n\tpub async fn try_handle_error_returns_none() {\n\t\tlet extra_data = vec![vec![1]];\n\t\tlet mut inherent_data = InherentData::new();\n\t\tlet provider = RandInherentDataProvider::new(extra_data.clone());\n\t\tlet res = provider.try_handle_error(\u0026[1u8; 8], \u0026vec![1]).await;\n\t\tassert!(res.is_none());\n\t}\n}\n","traces":[{"line":31,"address":[2211552],"length":1,"stats":{"Line":2}},{"line":40,"address":[2211584],"length":1,"stats":{"Line":1}},{"line":48,"address":[2179656,2179505,2179264,2179294,2179377],"length":1,"stats":{"Line":3}},{"line":49,"address":[2179565],"length":1,"stats":{"Line":1}},{"line":57,"address":[2179997],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","driemworks","ideal","idn-sdk","primitives","consensus","randomness-beacon","src","lib.rs"],"content":"/*\n * Copyright 2025 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate alloc;\n\npub mod inherents;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","support","traits","src","lib.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # IDN Traits\n\npub mod rand {\n\n\t/// A trait for dispatching random data.\n\tpub trait Dispatcher\u003cR, O\u003e {\n\t\t/// Dispatch the given random data.\n\t\tfn dispatch(rnd: R) -\u003e O;\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","driemworks","ideal","idn-sdk","support","traits","src","rand_consumer.rs"],"content":"/*\n * Copyright 2024 by Ideal Labs, LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//! # Randomness consumer trait\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>